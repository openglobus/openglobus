var og =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/og/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/og/Clock.js":
/*!*************************!*\
  !*** ./src/og/Clock.js ***!
  \*************************/
/*! exports provided: Clock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
/* harmony import */ var _Events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Events.js */ "./src/og/Events.js");
/* harmony import */ var _astro_jd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./astro/jd.js */ "./src/og/astro/jd.js");
/**
 * @module og/Clock
 */






/**
 * Class represents application timer that stores custom current julian datetime, and time speed multiplier.
 * @class
 * @param {Object} [params]: - Clock parameters:
 * @param {number} [params.startDate=0.0] - Julian start date.
 * @param {number} [params.endDate=0.0] - Julian end date.
 * @param {number} [params.currentDate] - Julian current date. Default: current date.
 * @param {number} [params.multiplier=1.0] - Time speed multiolier.
 */
class Clock {

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    constructor(params) {
        params = params || {};

        this._id = Clock._staticCounter++;

        /**
         * Clock name.
         * @public
         * @type {string}
         */
        this.name = params.name || "";

        /**
         * Clock events.
         * @public
         * @type {Events}
         */
        this.events = new _Events_js__WEBPACK_IMPORTED_MODULE_0__["Events"]([
            "tick",
            "end"
        ]);

        /**
         * Start julian date clock loop.
         * @public
         * @type {number}
         */
        this.startDate = params.startDate || 0;

        /**
         * End julian date clock loop.
         * @public
         * @type {number}
         */
        this.endDate = params.endDate || 0;

        var currentDate = params.currentDate || _astro_jd_js__WEBPACK_IMPORTED_MODULE_1__["DateToUTC"](new Date());
        if (params.startDate && currentDate < params.startDate) {
            currentDate = params.startDate;
        }
        if (params.endDate && currentDate > params.endDate) {
            currentDate = params.endDate;
        }

        /**
         * Current julian datetime.
         * @public
         * @type {number}
         */
        this.currentDate = currentDate;

        /**
         * Timer speed multiplier.
         * @public
         * @type {number}
         */
        this.multiplier = params.multiplier !== undefined ? params.multiplier : 1.0;

        /**
         * Animation frame delta time.
         * @public
         * @readonly
         * @type {number}
         */
        this.deltaTicks = 0;

        /**
         * Timer activity.
         * @public
         * @type {boolean}
         */
        this.active = true;
    }

    /**
     * Sets current clock datetime.
     * @public
     * @param {Object} date - JavaScript Date object.
     */
    setDate(date) {
        var d = _astro_jd_js__WEBPACK_IMPORTED_MODULE_1__["DateToUTC"](date);
        if (this.startDate && d < this.startDate) {
            d = this.startDate;
        }
        if (this.endDate && d > this.endDate) {
            d = this.endDate;
        }
        this.currentDate = d;
    }

    /**
     * Returns current application date.
     * @public
     * @returns {Date} - Current date.
     */
    getDate() {
        return _astro_jd_js__WEBPACK_IMPORTED_MODULE_1__["UTCtoDate"](this.currentDate);
    }

    reset() {
        if (this.startDate) {
            this.currentDate = this.startDate;
        }
    }

    _tick(dt) {
        this.deltaTicks = dt * this.multiplier;
        if (this.active) {
            var cd = _astro_jd_js__WEBPACK_IMPORTED_MODULE_1__["addMilliseconds"](this.currentDate, this.deltaTicks);
            if (this.multiplier > 0) {
                if (this.endDate && cd > this.endDate) {
                    this.currentDate = this.startDate;
                    this.events.dispatch(this.events.end, this);
                } else {
                    this.currentDate = cd;
                }
            } else {
                if (this.startDate && cd < this.startDate) {
                    this.currentDate = this.endDate;
                    this.events.dispatch(this.events.end, this);
                } else {
                    this.currentDate = cd;
                }
            }
            this.events.dispatch(this.events.tick, this);
        }
    }

    /**
     * @public
     * @param {Clock} clock - Clock instance to compare.
     * @returns {boolean} - Returns true if a clock is the same instance.
     */
    equal(clock) {
        return this._id === clock._id;
    }
};



/***/ }),

/***/ "./src/og/Events.js":
/*!**************************!*\
  !*** ./src/og/Events.js ***!
  \**************************/
/*! exports provided: Events */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Events", function() { return Events; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/shared.js */ "./src/og/utils/shared.js");
/**
 * @module og/Events
 */





/**
 * Base events class to handle custom events.
 * @class
 * @param {Array.<string>} [eventNames] - Event names that could be dispatched.
 */
class Events {

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    constructor(eventNames) {
        /**
         * Registered event names.
         * @protected
         * @type {Array.<string>}
         */
        this._eventNames = [];
        eventNames && this.registerNames(eventNames);

        /**
         * Event identifier.
         * @protected
         * @type {number}
         */
        this._counter = 0;

        /**
         * Stop propagation flag
         * @protected
         * @type {boolean}
         */
        this._stopPropagation = false;

        this._stampCache = {};

        this.__id = Events.__staticCounter++;
    }

    /**
     * Function that creates event object properties that would be dispatched.
     * @public
     * @param {Array.<string>} eventNames - Specified event names list.
     */
    registerNames(eventNames) {
        for (var i = 0; i < eventNames.length; i++) {
            this[eventNames[i]] = { "active": true, "handlers": [] };
            this._eventNames.push(eventNames[i]);
        }
    }

    /**
     * Returns true if event callback has stamped.
     * @protected
     * @param {Object} name - Event identifier.
     * @param {Object} obj - Event callback.
     * @return {boolean} -
     */
    _stamp(name, obj) {

        var ogid = Object(_utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["stamp"])(obj);

        var st = name + "_" + this.__id + "_" + ogid;

        if (!this._stampCache[st]) {
            this._stampCache[st] = ogid;
            return true;
        }

        return false;
    }

    /**
     * Attach listener.
     * @public
     * @param {string} name - Event name to listen.
     * @param {eventCallback} callback - Event callback function.
     * @param {Object} sender - Event callback function owner. 
     */
    on(name, callback, sender) {
        if (this._stamp(name, callback)) {
            this[name] && this[name].handlers.unshift({ "sender": sender || this, "callback": callback });
        }
    }

    /**
     * Stop listening event name with specified callback function.
     * @public
     * @param {string} name - Event name.
     * @param {eventCallback} callback - Attached  event callback.
     */
    off(name, callback) {
        var st = name + "_" + this.__id + "_" + callback._openglobus_id;
        if (callback._openglobus_id && this._stampCache[st]) {
            var h = this[name].handlers;
            var i = h.length;
            var indexToRemove = -1;
            while (i--) {
                var hi = h[i];
                if (hi.callback._openglobus_id === callback._openglobus_id) {
                    indexToRemove = i;
                    break;
                }
            }

            if (indexToRemove !== -1) {
                h.splice(indexToRemove, 1);
                this._stampCache[st] = undefined;
                delete this._stampCache[st];
            }
        }
    }

    /**
     * Dispatch event.
     * @public
     * @param {Object} event - Event instance property that created by event name.
     * @param {Object} [obj] - Event object.
     */
    dispatch(event, obj) {
        if (event && event.active) {
            var h = event.handlers;
            var i = h.length;
            while (i-- && !this._stopPropagation) {
                var e = h[i];
                e.callback.call(e.sender, obj);
            }
        }
        this._stopPropagation = false;
    }

    /**
     * Brakes events propagation.
     * @public
     */
    stopPropagation() {
        this._stopPropagation = true;
    }

    /**
     * Removes all events.
     * @public
     */
    clear() {
        for (var i = 0; i < this._eventNames.length; i++) {
            var e = this[this._eventNames[i]];
            e.handlers.length = 0;
            e.handlers = [];
        }
        this._eventNames.length = 0;
        this._eventNames = [];
    }
};



/***/ }),

/***/ "./src/og/Extent.js":
/*!**************************!*\
  !*** ./src/og/Extent.js ***!
  \**************************/
/*! exports provided: Extent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Extent", function() { return Extent; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./src/og/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LonLat.js */ "./src/og/LonLat.js");
/**
 * @module og/Extent
 */







/**
 * Represents geographical coordinates extent.
 * @class
 * @param {og.LonLat} [sw] - South West extent corner coordiantes.
 * @param {og.LonLat} [ne] - North East extent corner coordiantes.
 */
const Extent = function (sw, ne) {
    /**
     * @public
     */
    this.southWest = sw || new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"]();

    /**
     * @public
     */
    this.northEast = ne || new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"]();
};

/**
 * Whole mercator extent.
 * @const
 */
Extent.FULL_MERC = new Extent(_LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"].SW_MERC, _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"].NE_MERC);

/**
 * Degrees extent from north mercator limit to north pole.
 * @const
 */
Extent.NORTH_POLE_DEG = new Extent(_LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"].NW_MERC_DEG, new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](180.0, 90.0));

/**
 * Degrees extent from south pole to south mercator limit.
 * @const
 */
Extent.SOUTH_POLE_DEG = new Extent(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](-180.0, -90.0), _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"].SE_MERC_DEG);

/**
 * Creates extent instance from values in array.
 * @static
 * @param {Array.<number,number,number,number>} arr - South west and north east longitude and latidudes packed in array.
 * @return {og.Extent} Extent object.
 */
Extent.createFromArray = function (arr) {
    return new Extent(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](arr[0], arr[1]), new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](arr[2], arr[3]));
};

/**
 * Creates bound extent instance by coordinate array.
 * @static
 * @param {Array.<og.LonLat>} arr - Coordinate array.
 * @return {og.Extent} Extent object.
 */
Extent.createByCoordinates = function (arr) {
    var lonmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], lonmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"],
        latmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], latmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];
    for (var i = 0; i < arr.length; i++) {
        var vi = arr[i];
        if (vi.lon < lonmin) lonmin = vi.lon;
        if (vi.lon > lonmax) lonmax = vi.lon;
        if (vi.lat < latmin) latmin = vi.lat;
        if (vi.lat > latmax) latmax = vi.lat;
    }
    return new Extent(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](lonmin, latmin), new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](lonmax, latmax));
};

/**
 * Creates bound extent instance by coordinate array.
 * @static
 * @param {Array.<Array<number,number>>} arr - Coordinate array.
 * @return {og.Extent} Extent object.
 */
Extent.createByCoordinatesArr = function (arr) {
    var lonmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], lonmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"],
        latmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], latmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];
    for (var i = 0; i < arr.length; i++) {
        var vi = arr[i];
        if (vi[0] < lonmin) lonmin = vi[0];
        if (vi[0] > lonmax) lonmax = vi[0];
        if (vi[1] < latmin) latmin = vi[1];
        if (vi[1] > latmax) latmax = vi[1];
    }
    return new Extent(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](lonmin, latmin), new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](lonmax, latmax));
};

/**
 * Creates extent by meractor grid tile coordinates.
 * @static
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @returns {og.Extent}
 */
Extent.fromTile = function (x, y, z, width, height) {
    width = width || _mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE_DOUBLE"];
    height = height || _mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE_DOUBLE"];
    var H = Math.pow(2, z),
        W = Math.pow(2, z),
        lnSize = width / W,
        ltSize = height / H;

    var left = -width * 0.5 + x * lnSize,
        top = height * 0.5 - y * ltSize,
        bottom = top - ltSize,
        right = left + lnSize;

    return new Extent(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](left, bottom), new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](right, top));
};

/**
 * Sets current bounding extent object by coordinate array.
 * @public
 * @param {Array.<og.LonLat>} arr - Coordinate array.
 * @return {og.Extent} Current extent.
 */
Extent.prototype.setByCoordinates = function (arr) {
    var lonmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], lonmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"],
        latmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], latmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];
    for (var i = 0; i < arr.length; i++) {
        var vi = arr[i];
        if (vi.lon < lonmin) lonmin = vi.lon;
        if (vi.lon > lonmax) lonmax = vi.lon;
        if (vi.lat < latmin) latmin = vi.lat;
        if (vi.lat > latmax) latmax = vi.lat;
    }
    this.southWest.lon = lonmin;
    this.southWest.lat = latmin;
    this.northEast.lon = lonmax;
    this.northEast.lat = latmax;
    return this;
};

/**
 * Determines if point inside extent.
 * @public
 * @param {LonLat} lonlat - Coordinate point.
 * @return {boolean} Returns true if point inside extent.
 */
Extent.prototype.isInside = function (lonlat) {
    var sw = this.southWest,
        ne = this.northEast;
    return lonlat.lon >= sw.lon && lonlat.lon <= ne.lon &&
        lonlat.lat >= sw.lat && lonlat.lat <= ne.lat;
};

/**
 * Returns true if two extent overlap each other.
 * @public
 * @param {Extent} e - Another extent.
 * @return {boolean}
 */
Extent.prototype.overlaps = function (e) {
    var sw = this.southWest,
        ne = this.northEast;
    return sw.lon <= e.northEast.lon && ne.lon >= e.southWest.lon &&
        sw.lat <= e.northEast.lat && ne.lat >= e.southWest.lat;
};

/**
 * Gets extent width.
 * @public
 * @return {number} Extent width.
 */
Extent.prototype.getWidth = function () {
    return this.northEast.lon - this.southWest.lon;
};

/**
 * Gets extent height.
 * @public
 * @return {number} Extent height.
 */
Extent.prototype.getHeight = function () {
    return this.northEast.lat - this.southWest.lat
};

/**
 * Creates clone instance of the current extent.
 * @public
 * @return {og.Extent} Extent clone.
 */
Extent.prototype.clone = function () {
    return new Extent(this.southWest.clone(), this.northEast.clone());
};

/**
 * Gets the center coordinate of the extent.
 * @public
 * @return {number} Center coordinate.
 */
Extent.prototype.getCenter = function () {
    var sw = this.southWest, ne = this.northEast;
    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](sw.lon + (ne.lon - sw.lon) * 0.5, sw.lat + (ne.lat - sw.lat) * 0.5);
};

/**
 * @public
 */
Extent.prototype.getNorthWest = function () {
    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.southWest.lon, this.northEast.lat);
};

/**
 * @public
 */
Extent.prototype.getNorthEast = function () {
    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.northEast.lon, this.northEast.lat);
};

Extent.prototype.getSouthWest = function () {
    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.southWest.lon, this.southWest.lat);
};

/**
 * @public
 */
Extent.prototype.getSouthEast = function () {
    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.northEast.lon, this.southWest.lat);
};

/**
 * @public
 */
Extent.prototype.getNorth = function () {
    return this.northEast.lat;
};

Extent.prototype.getEast = function () {
    return this.northEast.lon;
};

/**
 * @public
 */
Extent.prototype.getWest = function () {
    return this.southWest.lon;
};

/**
 * @public
 */
Extent.prototype.getSouth = function () {
    return this.southWest.lat;
};

/**
 * Returns extents are equals.
 * @param {og.Extent} extent - Extent.
 * @returns {boolean}
 */
Extent.prototype.equals = function (extent) {
    return this.southWest.lon === extent.southWest.lon && this.southWest.lat === extent.southWest.lat &&
        this.northEast.lon === extent.northEast.lon && this.northEast.lat === extent.northEast.lat;
};

/**
 * Converts extent coordinates to mercator projection coordinates.
 * @public
 * @return {og.Extent} New instance of the current extent.
 */
Extent.prototype.forwardMercator = function () {
    return new Extent(this.southWest.forwardMercator(), this.northEast.forwardMercator());
};

/**
 * Converts extent coordinates from mercator projection to degrees.
 * @public
 * @return {og.Extent} New instance of the current extent.
 */
Extent.prototype.inverseMercator = function () {
    return new Extent(this.southWest.inverseMercator(), this.northEast.inverseMercator());
};

/**
 * Gets cartesian bounding bounds of the current ellipsoid.
 * @public
 * @param {og.Ellipsoid} ellipsoid - Ellipsoid.
 * @return {Array.<number,number,number,number,number,number>} Cartesian 3d coordinate array.
 */
Extent.prototype.getCartesianBounds = function (ellipsoid) {
    var xmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], xmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"], ymin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"],
        ymax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"], zmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], zmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];

    var v = [new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.southWest.lon, this.southWest.lat),
    new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.southWest.lon, this.northEast.lat),
    new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.northEast.lon, this.northEast.lat),
    new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](this.northEast.lon, this.southWest.lat)];

    for (var i = 0; i < v.length; i++) {
        var coord = ellipsoid.lonLatToCartesian(v[i]);
        var x = coord.x, y = coord.y, z = coord.z;
        if (x < xmin) xmin = x;
        if (x > xmax) xmax = x;
        if (y < ymin) ymin = y;
        if (y > ymax) ymax = y;
        if (z < zmin) zmin = z;
        if (z > zmax) zmax = z;
    }

    return [xmin, xmax, ymin, ymax, zmin, zmax];
};

Extent.prototype.toString = function () {
    return "[" + this.southWest.lon + ", " + this.southWest.lat + ", " + this.northEast.lon + ", " + this.northEast.lat + "]";
};



/***/ }),

/***/ "./src/og/Frustum.js":
/*!***************************!*\
  !*** ./src/og/Frustum.js ***!
  \***************************/
/*! exports provided: Frustum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
/**
 * @module og/Frustum
 */



/**
 * Frustum object, part of the camera object.
 * @class
 */
class Frustum {
    constructor() {
        /**
         * Frustum planes.
         * @private
         * @type {Array.<Array.<number>>}
         */
        this._f = new Array(6);
        for (var i = 0; i < 6; i++)
            this._f[i] = new Array(4);
    }
    /**
     * Normalize frustum plane.
     * @static
     * @param {Array.<number>} plane - Frustum plane coordinates.
     */
    static planeNormalize(plane) {
        var t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);
        plane[0] /= t;
        plane[1] /= t;
        plane[2] /= t;
        plane[3] /= t;
    }

    /**
     * Camera's projection matrix values.
     * @public
     * @param {Array.<number>} clip - Projection matrix parameters.
     */
    setFrustum(clip) {
        /* Right */
        this._f[0][0] = clip[3] - clip[0];
        this._f[0][1] = clip[7] - clip[4];
        this._f[0][2] = clip[11] - clip[8];
        this._f[0][3] = clip[15] - clip[12];
        Frustum.planeNormalize(this._f[0]);

        /* Left */
        this._f[1][0] = clip[3] + clip[0];
        this._f[1][1] = clip[7] + clip[4];
        this._f[1][2] = clip[11] + clip[8];
        this._f[1][3] = clip[15] + clip[12];
        Frustum.planeNormalize(this._f[1]);

        /* Bottom */
        this._f[2][0] = clip[3] + clip[1];
        this._f[2][1] = clip[7] + clip[5];
        this._f[2][2] = clip[11] + clip[9];
        this._f[2][3] = clip[15] + clip[13];
        Frustum.planeNormalize(this._f[2]);

        /* Top */
        this._f[3][0] = clip[3] - clip[1];
        this._f[3][1] = clip[7] - clip[5];
        this._f[3][2] = clip[11] - clip[9];
        this._f[3][3] = clip[15] - clip[13];
        Frustum.planeNormalize(this._f[3]);

        /* Backward */
        this._f[4][0] = clip[3] - clip[2];
        this._f[4][1] = clip[7] - clip[6];
        this._f[4][2] = clip[11] - clip[10];
        this._f[4][3] = clip[15] - clip[14];
        Frustum.planeNormalize(this._f[4]);

        /* Forward */
        this._f[5][0] = clip[3] + clip[2];
        this._f[5][1] = clip[7] + clip[6];
        this._f[5][2] = clip[11] + clip[10];
        this._f[5][3] = clip[15] + clip[14];
        Frustum.planeNormalize(this._f[5]);
    }

    /**
     * Returns true if a point in the frustum.
     * @public
     * @param {og.math.Vec3} point - Cartesian point.
     * @returns {boolean}
     */
    containsPoint(point) {
        var d;
        for (var p = 0; p < 6; p++) {
            d = point.dotArr(this._f[p]) + this._f[p][3];
            if (d <= 0)
                return false;
        }
        return true;
    }

    /**
     * Returns true if the frustum contains a bonding sphere.
     * @public
     * @param {og.bv.Sphere} sphere - Bounding sphere.
     * @returns {boolean}
     */
    containsSphere(sphere) {
        var r = -sphere.radius;
        if (sphere.center.dotArr(this._f[0]) + this._f[0][3] <= r) return false;
        if (sphere.center.dotArr(this._f[1]) + this._f[1][3] <= r) return false;
        if (sphere.center.dotArr(this._f[2]) + this._f[2][3] <= r) return false;
        if (sphere.center.dotArr(this._f[3]) + this._f[3][3] <= r) return false;
        if (sphere.center.dotArr(this._f[4]) + this._f[4][3] <= r) return false;
        if (sphere.center.dotArr(this._f[5]) + this._f[5][3] <= r) return false;
        return true;
    }

    /**
     * Returns true if the frustum contains a bounding box.
     * @public
     * @param {og.bv.Box} box - Bounding box.
     * @returns {boolean}
     */
    containsBox(box) {
        var result = true, cout, cin;

        for (var i = 0; i < 6; i++) {
            cout = 0; cin = 0;
            for (var k = 0; k < 8 && (cin == 0 || cout == 0); k++) {
                var d = box.vertices[k].dotArr(this._f[i]) + this._f[i][3];
                if (d < 0)
                    cout++;
                else
                    cin++;
            }
            if (cin == 0)
                return false;
            else if (cout > 0)
                result = true;
        }
        return (result);
    }
};




/***/ }),

/***/ "./src/og/Globe.js":
/*!*************************!*\
  !*** ./src/og/Globe.js ***!
  \*************************/
/*! exports provided: Globe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Globe", function() { return Globe; });
/* harmony import */ var _terrain_EmptyTerrain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./terrain/EmptyTerrain.js */ "./src/og/terrain/EmptyTerrain.js");
/* harmony import */ var _webgl_Handler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/Handler.js */ "./src/og/webgl/Handler.js");
/* harmony import */ var _scene_Planet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scene/Planet.js */ "./src/og/scene/Planet.js");
/* harmony import */ var _renderer_Renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer/Renderer.js */ "./src/og/renderer/Renderer.js");
/* harmony import */ var _ellipsoid_wgs84_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ellipsoid/wgs84.js */ "./src/og/ellipsoid/wgs84.js");
/* harmony import */ var _control_EarthCoordinates_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control/EarthCoordinates.js */ "./src/og/control/EarthCoordinates.js");
/* harmony import */ var _control_MouseNavigation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control/MouseNavigation.js */ "./src/og/control/MouseNavigation.js");
/* harmony import */ var _control_TouchNavigation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./control/TouchNavigation.js */ "./src/og/control/TouchNavigation.js");
/* harmony import */ var _control_Sun_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./control/Sun.js */ "./src/og/control/Sun.js");
/* harmony import */ var _control_ZoomControl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./control/ZoomControl.js */ "./src/og/control/ZoomControl.js");
/**
 * @module og/Globe
 */















/** @const {string} */
const CANVAS_ID_PREFIX = "globus_viewport_";
/** @const {string} */
const PLANET_NAME_PREFIX = "globus_planet_";

/**
 * Creates a WebGL context with globe.
 * @class
 *
 * @example <caption>Basic initialization</caption>
 * globus = new og.Globe({
 *     'atmosphere': false,
 *     'target': 'globus',
 *     'name': 'Earth',
 *     'controls': [
 *          new og.control.MouseNavigation({ autoActivate: true }),
 *          new og.control.KeyboardNavigation({ autoActivate: true }),
 *          new og.control.EarthCoordinates({ autoActivate: true, center: false }),
 *          new og.control.LayerSwitcher({ autoActivate: true }),
 *          new og.control.ZoomControl({ autoActivate: true }),
 *          new og.control.TouchNavigation({ autoActivate: true }),
 *          new og.control.Sun({ autoActivate: true })
 *      ],
 *     'skybox': skybox,
 *     'terrain': terrain,
 *     'layers': [
 *          new og.layer.XYZ("OpenStreetMap", { isBaseLayer: true, url: "http://b.tile.openstreetmap.org/{z}/{x}/{y}.png", visibility: true, attribution: 'Data @ <a href="http://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="http://www.openstreetmap.org/copyright">ODbL</a>' })
 *      ],
 *     'autoActivated': true
 * });
 *
 * @param {object} options - Options:
 * @param {string} options.target - HTML element id where planet canvas have to be created.
 * @param {boolean} [options.skybox] - Render skybox. null - default.
 * @param {boolean} [options.atmosphere] - Render planet with atmosphere. False - default.
 * @param {string} [options.name] - Planet name. Default is unic identifier.
 * @param {og.terrain.Terrain} [options.terrain] - Terrain provider. Default no terrain - og.terrain.EmptyTerrain.
 * @param {Array.<og.control.BaseControl>} [options.controls] - Renderer controls array.
 * @param {Array.<og.layer.Layer>} [options.layers] - Planet layers.
 * @param {og.Extent} [options.viewExtent] - Viewable starting extent.
 * @param {boolean} [options.autoActivate] - Globe rendering auto activation flag. True is default.
 */
class Globe {
    constructor(options) {

        //Canvas creation.
        var _canvasId = CANVAS_ID_PREFIX + Globe._staticCounter++;

        this._canvas = document.createElement("canvas");
        this._canvas.id = _canvasId;
        this._canvas.style.width = "100%";
        this._canvas.style.height = "100%";
        this._canvas.style.display = "block";
        this._canvas.style.opacity = "1.0";

        /**
         * Dom element where WebGL canvas creates
         * @public
         * @type {Element}
         */
        this.div = document.getElementById(options.target);
        this.div.appendChild(this._canvas);
        this.div.classList.add("ogViewport");
        function _disableWheel() { return false; }
        function _enableWheel() { return true; }
        this.div.onmouseenter = function () { document.onmousewheel = _disableWheel; };
        this.div.onmouseleave = function () { document.onmousewheel = _enableWheel; };

        //WegGL handler creation
        var _handler = new _webgl_Handler_js__WEBPACK_IMPORTED_MODULE_1__["Handler"](_canvasId, { 'alpha': false, 'antialias': false });
        _handler.initialize();

        /**
         * Interface for the renderer context(events, input states, renderer nodes etc.)
         * @public
         * @type {og.Renderer}
         */
        this.renderer = new _renderer_Renderer_js__WEBPACK_IMPORTED_MODULE_3__["Renderer"](_handler);
        this.renderer.initialize();
        this.renderer.div = this.div;
        this.renderer.div.attributions = document.createElement("div");
        this.renderer.div.attributions.classList.add("ogAttribution");
        this.div.appendChild(this.renderer.div.attributions);

        //Skybox
        if (options.skybox) {
            this.renderer.addRenderNode(options.skybox);
        }

        /**
         * Planet node name. Access with this.renderer.<name>
         * @private
         * @type {String}
         */
        this._planetName = options.name ? options.name : PLANET_NAME_PREFIX + Globe._staticCounter;

        if (options.atmosphere) {
            /**
             * Render node renders a planet.
             * @public
             * @type {og.scene.Planet|og.scene.PlanetAtmosphere}
             */

            //TODO:

        } else {
            this.planet = new _scene_Planet_js__WEBPACK_IMPORTED_MODULE_2__["Planet"](this._planetName, options.ellipsoid ? options.ellipsoid : _ellipsoid_wgs84_js__WEBPACK_IMPORTED_MODULE_4__["wgs84"]);
        }

        //Attach terrain provider
        if (options.terrain) {
            this.planet.setTerrain(options.terrain);
        } else {
            this.planet.setTerrain(new _terrain_EmptyTerrain_js__WEBPACK_IMPORTED_MODULE_0__["EmptyTerrain"]());
        }

        this.renderer.addRenderNode(this.planet);

        this.sun;

        //Add controls
        if (options.controls) {
            this.planet.addControls(options.controls);
        } else {
            this.planet.addControls([
                new _control_MouseNavigation_js__WEBPACK_IMPORTED_MODULE_6__["MouseNavigation"](),
                new _control_TouchNavigation_js__WEBPACK_IMPORTED_MODULE_7__["TouchNavigation"](),
                new _control_ZoomControl_js__WEBPACK_IMPORTED_MODULE_9__["ZoomControl"](),
                new _control_EarthCoordinates_js__WEBPACK_IMPORTED_MODULE_5__["EarthCoordinates"]()
            ]);
        }

        var _controls = this.renderer.controls;
        for (var i = 0; i < _controls.length; i++) {
            if (_controls[i] instanceof _control_Sun_js__WEBPACK_IMPORTED_MODULE_8__["Sun"]) {
                this.sun = _controls[i];
                break;
            }
        }

        if (!this.sun) {
            this.sun = new _control_Sun_js__WEBPACK_IMPORTED_MODULE_8__["Sun"]();
            this.planet.addControl(this.sun);
        }

        if (options.sun) {
            if (options.sun.active !== undefined && !options.sun.active) {
                this.sun.deactivate();
            }
        }

        if (options.layers) {
            this.planet.addLayers(options.layers);
        }

        //TODO: view center, altitude, extent
        if (options.viewExtent) {
            this.planet.viewToExtent(options.viewExtent);
        }

        this._opacityCounter = 0;
        this._fadeHandler = null;
        this._stopHandler = null;

        //Run!
        if (Globe.isUndefined(options.autoActivate) || options.autoActivate) {
            this.fadeIn(500);
            this.renderer.start();
        }
    }

    /**
     * Starts screen brightness fading in effect by the duration time.
     * @public
     * @param {number} duration - fadein duration time.
     */
    fadeIn(duration) {
        clearInterval(this._stopHandler);
        clearInterval(this._fadeHandler);
        this._canvas.style.opacity = 0.0;
        this._opacityCounter = 0.0;
        var delta = 10.0;
        var d = 1.0 / (duration / delta);

        this._fadeHandler = setInterval(() => {
            this._opacityCounter += d;
            if (this._opacityCounter >= 1) {
                this._opacityCounter = 1.0;
                clearInterval(this._fadeHandler);
            }
            this._canvas.style.opacity = this._opacityCounter;
        }, delta);
    }

    /**
     * Starts screen brightness fading out effect by the duration time.
     * @public
     * @param {number} duration - Fadeout duration time.
     */
    fadeOut(duration) {
        clearInterval(this._stopHandler);
        clearInterval(this._fadeHandler);
        this._canvas.style.opacity = 1.0;
        this._opacityCounter = 1.0;
        var delta = 10.0;
        var d = 1 / (duration / delta);

        this._fadeHandler = setInterval(() => {
            this._opacityCounter -= d;
            if (this._opacityCounter <= 0.0) {
                this._opacityCounter = 0.0;
                clearInterval(this._fadeHandler);
            }
            this._canvas.style.opacity = this._opacityCounter;
        }, delta);
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    /**
     * Returns true if the object pointer is undefined.
     * @function
     * @param {Object} obj - Object pointer.
     * @returns {boolean} Returns true if object is undefined.
     */
    static isUndefined(obj) {
        return obj === void 0;
    }
};



/***/ }),

/***/ "./src/og/ImageCanvas.js":
/*!*******************************!*\
  !*** ./src/og/ImageCanvas.js ***!
  \*******************************/
/*! exports provided: ImageCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageCanvas", function() { return ImageCanvas; });
/**
 * @module og/ImageCanvas
 */



/**
 * Usefull class for working with JS canvas object.
 * @class
 * @param {number} [width] - Canvas width. Default 256.
 * @param {number} [height] - Canvas height. Default 256.
 */
class ImageCanvas {
    constructor(width, height) {
        /**
         * Canvas object.
         * @protected
         * @type {Object}
         */
        this._canvas = document.createElement("canvas");
        this._canvas.width = width || 256;
        this._canvas.height = height || 256;

        /**
         * Canvas context.
         * @protected
         * @type {Object}
         */
        this._context = this._canvas.getContext('2d');
    }

    /**
     * Returns canvas object.
     * @public
     * @returns {Object}
     */
    getCanvas() {
        return this._canvas;
    }

    /**
     * Returns canvas context pointer.
     * @public
     * @returns {Object}
     */
    getContext() {
        return this._context;
    }

    /**
     * Fills canvas RGBA with zeroes.
     * @public
     */
    fillEmpty() {
        var imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
        var pixels = imgd.data;
        for (var i = 0, n = pixels.length; i < n; i += 4) {
            pixels[i] = pixels[i + 1] = pixels[i + 2] = pixels[i + 3] = 0;
        }
        this._context.putImageData(imgd, 0, 0);
    }

    /**
     * Gets canvas pixels RGBA data.
     * @public
     * @returns {Array.<number>}
     */
    getData() {
        var imgd = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
        return imgd.data;
    }

    /**
     * Fill the canvas by color.
     * @public
     * @param {string} color - CSS string color.
     */
    fillColor(color) {
        this._context.fillStyle = color;
        this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
    };

    /**
     * Sets RGBA pixel data.
     * @public
     * @param {Array.<number>} data - Array RGBA data.
     */
    setData(data) {
        var imageData = this._context.createImageData(this._canvas.width, this._canvas.height);
        imageData.data.set(data);
        this._context.putImageData(imageData, 0, 0);
    }

    /**
     * Resize canvas.
     * @public
     * @param {number} width - Width.
     * @param {number} height - Height.
     */
    resize(width, height) {
        this._canvas.width = width;
        this._canvas.height = height;
        this._context = this._canvas.getContext('2d');
    }

    /**
     * Draw an image on the canvas.
     * @public
     * @param {Image} img - Draw image.
     * @param {number} [x] - Left top image corner X coordinate on the canvas.
     * @param {number} [y] - Left top image corner Y coordinate on the canvas.
     * @param {number} [width] - Image width slice. Image width is default.
     * @param {number} [height] - Image height slice. Image height is default.
     */
    drawImage(img, x, y, width, height) {
        this._context = this._canvas.getContext('2d');
        this._context.drawImage(img, x || 0, y || 0, width || img.width, height || img.height);
    }

    /**
     * Converts canvas to JS image object.
     * @public
     * @returns {Image}
     */
    getImage() {
        var img = new Image();
        img.width = this.getWidth();
        img.height = this.getHeight();
        img.src = this._canvas.toDataURL("image/png");
        return img;
    }

    /**
     * Get measured text width.
     * @public
     * @param {string} text - Measured text.
     * @returns {number}
     */
    getTextWidth(text) {
        var metrics = this._context.measureText(text);
        return Math.round(metrics.width);
    }

    /**
     * Draw a text on the canvas.
     * @public
     * @param {string} text - Text.
     * @param {number} [x] - Canvas X - coordinate. 0 - default.
     * @param {number} [y] - Canvas Y - coordinate. 0 - default.
     * @param {string} [font] - Font style. 'normal 14px Verdana' - is default.
     * @param {string} [color] - Css font color.
     */
    drawText(text, x, y, font, color) {
        this._context.fillStyle = color || 'black';
        this._context.font = font || 'normal 14px Verdana';
        this._context.fillText(text, x || 0, y || 14);
    }

    /**
     * Gets canvas width.
     * @public
     * @returns {number}
     */
    getWidth() {
        return this._canvas.width;
    }

    /**
     * Gets canvas height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this._canvas.height;
    }

    /**
     * Load image to canvas.
     * @public
     * @param {string} url - Image url.
     * @pararm {imageCallback} [callback] - Image onload callback.
     */
    loadImage(url, callback) {
        var img = new Image();
        var that = this;
        img.onload = function () {
            that.resize(img.width, img.height);
            that._context.drawImage(img, 0, 0, img.width, img.height);
            callback && callback(img);
        }
        img.src = url;
    }

    /**
     * Open canvas image in the new window.
     * @public
     */
    openImage() {
        var img = this.getImage();
        var dataUrl = img.src;
        var windowContent = '<!DOCTYPE html>';
        windowContent += '<html>'
        windowContent += '<head><title>Print</title></head>';
        windowContent += '<body>'
        windowContent += '<img src="' + dataUrl + '">';
        windowContent += '</body>';
        windowContent += '</html>';
        var printWin = window.open('', '', 'width=' + img.width + 'px ,height=' + img.height + 'px');
        printWin.document.open();
        printWin.document.write(windowContent);
        printWin.document.close();
        printWin.focus();
    }


    destroy() {
        this._canvas.width = 1;
        this._canvas.height = 1;
        this._canvas = null;
        this._context = null;
    }
};



/***/ }),

/***/ "./src/og/Lock.js":
/*!************************!*\
  !*** ./src/og/Lock.js ***!
  \************************/
/*! exports provided: Lock, Key */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lock", function() { return Lock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Key", function() { return Key; });
/**
 * @module og/Lock
 */



class Lock {

    constructor() {
        this._lock = 0;
    }

    lock(key) {
        this._lock |= (1 << key._id);
    }

    free(key) {
        this._lock &= ~(1 << key._id);
    }

    isFree() {
        return this._lock === 0;
    }

    isLocked() {
        return this._lock !== 0;
    }
};

class Key {

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    constructor() {
        this._id = Key._staticCounter++;
    }
};




/***/ }),

/***/ "./src/og/LonLat.js":
/*!**************************!*\
  !*** ./src/og/LonLat.js ***!
  \**************************/
/*! exports provided: LonLat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LonLat", function() { return LonLat; });
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mercator.js */ "./src/og/mercator.js");
/**
 * @module og/LonLat
 */





/**
 * Represents a geographical point with a certain latitude, longitude and height.
 * @class
 * @param {number} [lon] - Longitude.
 * @param {number} [lat] - Latitude.
 * @param {number} [height] - Height over the surface.
 */
const LonLat = function (lon, lat, height) {

    /**
     * Longitude.
     * @public
     * @type {number}
     */
    this.lon = lon || 0;

    /**
     * Latitude.
     * @public
     * @type {number}
     */
    this.lat = lat || 0;

    /**
     * Height.
     * @public
     * @type {number}
     */
    this.height = height || 0;
};

/**
 * Creates coordinates array.
 * @static
 * @param{Array.<Array<number,number,number>>} arr - Coordinates array data.
 * @return{Array.<og.LonLat>} the same coordinates array but each element is LonLat instance.
 */
LonLat.join = function (arr) {
    var res = [];
    for (var i = 0; i < arr.length; i++) {
        var ai = arr[i];
        res[i] = new LonLat(ai[0], ai[1], ai[2]);
    }
    return res;
};

/**
 * Creates an object by coordinate array.
 * @static
 * @param {Array.<number,number,number>} arr - Coordiante array, where first is longitude, second is latitude and third is a height.
 * @returns {og.LonLat}
 */
LonLat.createFromArray = function (arr) {
    return new LonLat(arr[0], arr[1], arr[2]);
};

/**
 * Converts degrees to mercator coordinates.
 * @static
 * @param {number} lon - Degrees longitude.
 * @param {number} lat - Degrees latitude.
 * @param {number} [height] - Height.
 * @returns {og.LonLat}
 */
LonLat.forwardMercator = function (lon, lat, height) {
    var x = lon * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"] / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / Math.PI * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"];
    return new LonLat(x, y, height);
};

/**
 * Converts mercator to degrees coordinates.
 * @static
 * @param {number} x - Mercator longitude.
 * @param {number} y - Mercator latitude.
 * @param {number} [height] - Height.
 * @returns {og.LonLat}
 */
LonLat.inverseMercator = function (x, y, height) {
    var lon = 180 * x / _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"];
    var lat = 180 / Math.PI * (2 * Math.atan(Math.exp((y / _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"]) * Math.PI)) - Math.PI / 2);
    return new LonLat(lon, lat, height);
};

/**
 * Sets coordinates.
 * @public
 * @param {number} [lon] - Longitude.
 * @param {number} [lat] - Latitude.
 * @param {number} [height] - Height.
 * @returns {og.LonLat}
 */
LonLat.prototype.set = function (lon, lat, height) {
    this.lon = lon || 0;
    this.lat = lat || 0;
    this.height = height || 0;
    return this;
};

/**
 * Copy coordinates.
 * @public
 * @param {og.LonLat} [lonLat] - Coordinates to copy.
 * @returns {og.LonLat}
 */
LonLat.prototype.copy = function (lonLat) {
    this.lon = lonLat.lon;
    this.lat = lonLat.lat;
    this.height = lonLat.height;
    return this;
};

/**
 * Clone the coordiante.
 * @public
 * @returns {og.LonLat}
 */
LonLat.prototype.clone = function () {
    return new LonLat(this.lon, this.lat, this.height);
};

/**
 * Converts to mercator coordinates.
 * @public
 * @returns {og.LonLat}
 */
LonLat.prototype.forwardMercator = function () {
    return LonLat.forwardMercator(this.lon, this.lat, this.height);
};

LonLat.prototype.forwardMercatorEPS01 = function () {
    var lat = this.lat;
    if (lat > 89.9) {
        lat = 89.9;
    } else if (lat < -89.9) {
        lat = -89.9;
    }
    return new LonLat(
        this.lon * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"] / 180,
        Math.log(Math.tan((90 + lat) * Math.PI / 360)) / Math.PI * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"]);
};


/**
 * Converts from mercator coordinates.
 * @public
 * @returns {og.LonLat}
 */
LonLat.prototype.inverseMercator = function () {
    return LonLat.inverseMercator(this.lon, this.lat, this.height);
};

/**
 * Compares coordinates.
 * @public
 * @param {og.LonLat} b - Coordinate to compare with.
 * @returns {boolean}
 */
LonLat.prototype.equal = function (b) {
    if (b.height) {
        return this.lon == b.lon && this.lat == b.lat && this.height == b.height;
    } else {
        return this.lon == b.lon && this.lat == b.lat;
    }
};



/***/ }),

/***/ "./src/og/QueueArray.js":
/*!******************************!*\
  !*** ./src/og/QueueArray.js ***!
  \******************************/
/*! exports provided: QueueArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueueArray", function() { return QueueArray; });
/**
 * @module og/QueueArray
 */



class QueueArray {
    constructor(size) {
        this._size = size || 2048;
        this._array = new Array(this._size);
        this._popIndex = parseInt(this._size * 0.5);
        this._shiftIndex = this._popIndex;
        this.length = 0;
    }

    clear() {
        this._array.length = 0;
        this._array = new Array(this._size);
        this._popIndex = parseInt(this._size * 0.5);
        this._shiftIndex = this._popIndex;
        this.length = 0;
    }

    push(data) {
        this.length++;
        this._array[this._popIndex++] = data;
    }

    pop() {
        if (this.length) {
            this.length--;
            var res = this._array[--this._popIndex]
            this._array[this._popIndex] = null;
            if (!this._array[this._popIndex - 1]) {
                this._popIndex = parseInt(this._size * 0.5);
                this._shiftIndex = this._popIndex;
            }
            return res;
        }
        return undefined;
    }

    unshift(data) {
        this.length++;
        this._array[--this._shiftIndex] = data;
    }

    shift() {
        if (this.length) {
            this.length--;
            var res = this._array[this._shiftIndex];
            this._array[this._shiftIndex++] = null;
            if (!this._array[this._shiftIndex]) {
                this._popIndex = parseInt(this._size * 0.5);
                this._shiftIndex = this._popIndex;
            }
            return res;
        }
        return undefined;
    }

    each(callback) {
        for (var i = this._shiftIndex; i < this._popIndex; i++) {
            callback(this._array[i]);
        }
    }
};



/***/ }),

/***/ "./src/og/Rectangle.js":
/*!*****************************!*\
  !*** ./src/og/Rectangle.js ***!
  \*****************************/
/*! exports provided: Rectangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return Rectangle; });
/**
 * @module og/Rectangle
 */



/**
 * 2D Rectangle class.
 * @class
 * @param {number} [left] - Left coordinate. 0 - default.
 * @param {number} [top] - Top coordinate. 0 - default.
 * @param {number} [right] - Right coordinate. 0 - default.
 * @param {number} [bottom] - Bottom coordinate. 0 - default.
*/
class Rectangle {
    constructor(left, top, right, bottom) {

        /**
         * Left coordinate.
         * @public
         * @type {number}
         */
        this.left = left || 0;

        /**
         * Right coordinate.
         * @public
         * @type {number}
         */
        this.right = right || 0;

        /**
         * Top coordinate.
         * @public
         * @type {number}
         */
        this.top = top || 0;

        /**
         * Top coordinate.
         * @public
         * @type {number}
         */
        this.bottom = bottom || 0;
    }

    /**
     * Clone rectangle object.
     * @public
     * @returns {og.Rectangle}
     */
    clone() {
        return new Rectangle(this.left, this.top, this.right, this.bottom);
    }

    /**
     * Returns rectangle width.
     * @public
     * @type {number}
     */
    getWidth() {
        return Math.abs(this.right - this.left);
    }

    /**
     * Returns rectangle height.
     * @public
     * @type {number}
     */
    getHeight() {
        return Math.abs(this.bottom - this.top);
    }

    /**
     * Returns rectangle area.
     * @public
     * @type {number}
     */
    getSquare() {
        return this.getHeight() * this.getWidth();
    }

    /**
     * Returns rectangle diagonal size.
     * @public
     * @type {number}
     */
    getDiagonal() {
        var w = this.getWidth(),
            h = this.getHeight();
        return Math.sqrt(h * h + w * w);
    }

    /**
     * Returns true if rectangle fits their size in width and height.
     * @public
     * @param {number} width - Width.
     * @param {number} height - Height.
     * @type {boolean}
     */
    fit(width, height) {
        return (this.getWidth() == width && this.getHeight() == height);
    }
};



/***/ }),

/***/ "./src/og/Stack.js":
/*!*************************!*\
  !*** ./src/og/Stack.js ***!
  \*************************/
/*! exports provided: Stack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/**
 * @module og/Stack
 */



class Node {
    constructor() {
        this.next = null;
        this.prev = null;
        this.data = null;
    }
};

class Stack {
    constructor(size = 256) {

        this._current = new Node();
        this._head = this._current;

        for (var i = 0; i < size; i++) {
            var n = new Node();
            n.prev = this._current;
            this._current.next = n;
            this._current = n;
        }
        this._current = this._head;
    }

    current() {
        return this._current;
    }

    push(data) {
        this._current = this._current.next;
        this._current.data = data;
    };

    pop(data) {
        this._current = this._current.prev;
        return this._current.next.data;
    }

    popPrev(data) {
        this._current = this._current.prev;
        return this._current.data;
    }
};




/***/ }),

/***/ "./src/og/ajax.js":
/*!************************!*\
  !*** ./src/og/ajax.js ***!
  \************************/
/*! exports provided: ajax */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ajax", function() { return ajax; });
/**
 * @module og/ajax
 */



/**
 * Ajax parameters.
 * @namespace og.ajax
 */
const ajax = {
    /**
     * Ajax ready state result.
     * @enum
     */
    ReadyState:
    {
        Uninitialized: 0,
        Loading: 1,
        Loaded: 2,
        Interactive: 3,
        Complete: 4
    },
    /**
     * Ajax status code.
     * @enum
     */
    Status:
    {
        OK: 200,
        Created: 201,
        Accepted: 202,
        NoContent: 204,
        BadRequest: 400,
        Forbidden: 403,
        NotFound: 404,
        Gone: 410,
        ServerError: 500
    },
    /**
     * Ajax query method.
     * @enum
     */
    Method: {
        Get: "GET",
        Post: "POST"
    },
    /**
     * Ajax query type is asynchronous.
     * @type {boolean}
     */
    Asynchronous: true,
    /**
     * Ajax query type is synchronous.
     * @type {boolean}
     */
    Synchronous: false
};

/**
 * Xhr object that returned by ajax query.
 * @class
 * @param {Object} xhr - Current ActiveXObject object.
 */
const Xhr = function (xhr) {
    /**
     * ActiveXObject object.
     * @private
     * @type {Object}
     */
    var _xhr = xhr;

    /**
     * Aborts current ajax.
     * @public
     */
    this.abort = function () {
        _xhr.aborted = true;
        _xhr.abort();
    };
};

const defaultParams = {
    type: ajax.Method.Get,
    async: ajax.Asynchronous,
    data: null,
    sender: null,
    responseType: "text"
};

function createXMLHttp() {
    var xhr = null;
    if (typeof XMLHttpRequest !== undefined) {
        xhr = new XMLHttpRequest;
        return xhr;
    } else if (window.ActiveXObject) {
        var ieXMLHttpVersions = ['MSXML2.XMLHttp.5.0', 'MSXML2.XMLHttp.4.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp', 'Microsoft.XMLHttp'];
        for (var i = 0; i < ieXMLHttpVersions.length; i++) {
            try {
                xhr = new ActiveXObject(ieXMLHttpVersions[i]);
                return xhr;
            } catch (e) {
                console.log('error: og.ajax.createXMLHttp creation filed.');
            }
        }
    }
};

/**
 * Send an ajax request.
 * @function
 * @param {string} url - Url path.
 * @param {Object} [params] - Ajax parameters:
 * @param {ajax.Method|string} [params.type] - 'POST' or 'GET' ajax method. 'GET' is default.
 * @param {boolean} [params.async] - Asynchronous ajax flag. True is default.
 * @param {Object} [params.data] - Qery data.
 * @param {Object} [params.sender] - Sender object, that success callback binded with. ActiveXObject is default.
 * @param {string} [params.responseType] - Responce data type. Culd be 'text', 'json', 'jsonp', 'html'. 'text' is default.
 * @param {ajax.Xhr~successCallback} [params.success] - The callback that handles the success response.
 * @param {ajax.Xhr~errorCallback} [params.error] - The callback that handles the failed response.
 * @param {ajax.Xhr~abortCallback} [params.abort] - The callback that handles aborted requests.
 * @returns {ajax.Xhr} - Returns object that could be aborted.
 */
ajax.request = function (url, params) {

    params = params || {};

    var p = {}, i;

    for (i in defaultParams) {
        p[i] = defaultParams[i];
    }

    for (i in params) {
        p[i] = params[i];
    }

    p.data = params.data;

    var xhr = createXMLHttp();

    var customXhr = new Xhr(xhr);

    var body = null, d;

    if (p.type === ajax.Method.Post) {
        if (p.data) {
            body = "";
            for (key in p.data) {
                d = p.data[key];
                body += key + "=" + encodeURIComponent(d instanceof Object ? JSON.stringify(d) : d) + "&";
            }
            body = body.slice(0, -1);
        }
        xhr.open(p.type, url, p.async);
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    } else if (p.data) {
        var tail = "?";
        for (key in p.data) {
            d = p.data[key];
            tail += key + "=" + encodeURIComponent(d instanceof Object ? JSON.stringify(d) : d) + "&";
        }
        tail = tail.slice(0, -1);
        xhr.open(p.type, url + tail, p.async);
    } else {
        xhr.open(p.type, url, p.async);
    }

    if (p.async)
        xhr.responseType = p.responseType;

    xhr.overrideMimeType("text/plain");

    xhr.onreadystatechange = function () {
        if (xhr.readyState === ajax.ReadyState.Complete) {
            if (xhr.status === ajax.Status.OK) {
                if (params.success)
                    /**
                     * Success callback.
                     * @callback ajax.Xhr~successCallback
                     * @param {Object} Response data
                     */
                    params.success.call(params.sender || customXhr, xhr.response);
            } else if (xhr.aborted) {
                /**
                 * Abort callback.
                 * @callback ajax.Xhr~abortCallback
                 * @param {Object} Response data
                 * @param {Object} Status object
                 */
                params.abort && params.abort.call(params.sender || customXhr, xhr.response, xhr.status);
            } else {
                /**
                 * Error callback.
                 * @callback ajax.Xhr~errorCallback
                 * @param {Object} Response data
                 * @param {Object} Status object
                 */
                params.error && params.error.call(params.sender || customXhr, xhr.response, xhr.status);
            }
            delete xhr['onreadystatechange'];
            xhr.onreadystatechange = null;
            xhr = null;
        } else {
            //still loading
        }
    };

    xhr.send(body);

    return customXhr;
};



/***/ }),

/***/ "./src/og/astro/astro.js":
/*!*******************************!*\
  !*** ./src/og/astro/astro.js ***!
  \*******************************/
/*! exports provided: J2000_OBLIQUITY, AU_TO_METERS, TDT_TAI, EARTH_GRAVITATIONAL_PARAMETER, SUN_GRAVITATIONAL_PARAMETER, TAItoTDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J2000_OBLIQUITY", function() { return J2000_OBLIQUITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AU_TO_METERS", function() { return AU_TO_METERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TDT_TAI", function() { return TDT_TAI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EARTH_GRAVITATIONAL_PARAMETER", function() { return EARTH_GRAVITATIONAL_PARAMETER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUN_GRAVITATIONAL_PARAMETER", function() { return SUN_GRAVITATIONAL_PARAMETER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAItoTDB", function() { return TAItoTDB; });
/* harmony import */ var _jd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jd.js */ "./src/og/astro/jd.js");
/**
 * @module og/astro/astro
 */






/**
 * Angle between J2000 mean equator and the ecliptic plane.
 * 23 deg 26' 21".448 (Seidelmann, _Explanatory Supplement to the
 * Astronomical Almanac_ (1992), eqn 3.222-1.
 * @const
 * @type{Number}
 */
const J2000_OBLIQUITY = 23.4392911;

/**
 * IAU 1976 value
 * @const
 * @type{Number}
 */
const AU_TO_METERS = 1.49597870e+11;

/**
 * Terestrial and atomic time difference.
 * @const
 * @type{Number}
 */
const TDT_TAI = 32.184;

/**
 * Earth gravitational parameter product of gravitational constant G and the mass M of the Earth.
 * @const
 * @type{Number}
 */
const EARTH_GRAVITATIONAL_PARAMETER = 3.98600435e14;

/**
 * Sun gravitational parameter product of gravitational constant G and the mass M of the Sun.
 * @const
 * @type{Number}
 */
const SUN_GRAVITATIONAL_PARAMETER = 1.32712440018e20;

/**
 * Converts atomic time to barycentric dynamical time.
 * @param {Number} tai - Atomic time.
 * @returns {Number} - returns barycentric dynamical time.
 */
function TAItoTDB(tai) {
    tai += og.astro.TDT_TAI * _jd_js__WEBPACK_IMPORTED_MODULE_0__["ONE_BY_SECONDS_PER_DAY"];
    var g = 6.239996 + 0.0172019696544 * (tai - _jd_js__WEBPACK_IMPORTED_MODULE_0__["J2000"]);
    return tai + 0.001658 * Math.sin(g + 1.671e-2 * Math.sin(g)) * _jd_js__WEBPACK_IMPORTED_MODULE_0__["ONE_BY_SECONDS_PER_DAY"];
};

/***/ }),

/***/ "./src/og/astro/earth.js":
/*!*******************************!*\
  !*** ./src/og/astro/earth.js ***!
  \*******************************/
/*! exports provided: getSunPosition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSunPosition", function() { return getSunPosition; });
/* harmony import */ var _jd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jd.js */ "./src/og/astro/jd.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _astro_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./astro.js */ "./src/og/astro/astro.js");
/* harmony import */ var _math_Quat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Quat.js */ "./src/og/math/Quat.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/astro/earth
 */










/**
 * Returns Sun position in the geocentric coordinate system by the time.
 * @param {Number} jDate - Julian date time.
 * @returns {og.math.Vector3} - Sun geocentric coordinates.
 */
function getSunPosition(jDate) {
    //http://stjarnhimlen.se/comp/tutorial.html
    // a  Mean distance, or semi-major axis
    // e  Eccentricity
    // T  Time at perihelion

    // q  Perihelion distance  = a * (1 - e)    
    // Q  Aphelion distance    = a * (1 + e)

    // i  Inclination, i.e. the "tilt" of the orbit relative to the
    //    ecliptic.  The inclination varies from 0 to 180 degrees. If
    //    the inclination is larger than 90 degrees, the planet is in
    //    a retrogade orbit, i.e. it moves "backwards".  The most
    //    well-known celestial body with retrogade motion is Comet Halley.

    // N  (usually written as "Capital Omega") Longitude of Ascending
    //    Node. This is the angle, along the ecliptic, from the Vernal
    //    Point to the Ascending Node, which is the intersection between
    //    the orbit and the ecliptic, where the planet moves from south
    //    of to north of the ecliptic, i.e. from negative to positive
    //    latitudes.

    // w  (usually written as "small Omega") The angle from the Ascending
    //    node to the Perihelion, along the orbit.

    // P  Orbital period       = 365.256898326 * a**1.5/sqrt(1+m) days,
    //    where m = the mass of the planet in solar masses (0 for
    //    comets and asteroids). sqrt() is the square root function.

    // n  Daily motion         = 360_deg / P    degrees/day

    // t  Some epoch as a day count, e.g. Julian Day Number. The Time
    //    at Perihelion, T, should then be expressed as the same day count.

    // t - T   Time since Perihelion, usually in days

    // M  Mean Anomaly         = n * (t - T)  =  (t - T) * 360_deg / P
    //    Mean Anomaly is 0 at perihelion and 180 degrees at aphelion

    // L  Mean Longitude       = M + w + N

    // E  Eccentric anomaly, defined by Kepler's equation:   M = E - e * sin(E)
    //    An auxiliary angle to compute the position in an elliptic orbit

    // v  True anomaly: the angle from perihelion to the planet, as seen
    //    from the Sun

    // r  Heliocentric distance: the planet's distance from the Sun.

    // x,y,z  Rectangular coordinates. Used e.g. when a heliocentric
    //        position (seen from the Sun) should be converted to a
    //        corresponding geocentric position (seen from the Earth).

    var d = jDate - _jd_js__WEBPACK_IMPORTED_MODULE_0__["J2000"];

    var w = 282.9404 + 4.70935E-5 * d;                  //longitude of perihelion
    var a = 1.000000;                                   //mean distance, a.u.
    var e = 0.016709 - 1.151E-9 * d;                    //eccentricity
    var M = _math_js__WEBPACK_IMPORTED_MODULE_1__["rev"](356.0470 + 0.9856002585 * d);   //mean anomaly

    var oblecl = _astro_js__WEBPACK_IMPORTED_MODULE_2__["J2000_OBLIQUITY"] - 3.563E-7 * d; //obliquity of the ecliptic

    var L = _math_js__WEBPACK_IMPORTED_MODULE_1__["rev"](w + M); //Sun's mean longitude

    var E = M + _math_js__WEBPACK_IMPORTED_MODULE_1__["DEGREES"] * e * Math.sin(M * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]) * (1 + e * Math.cos(M * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"])); //eccentric anomaly

    //Sun rectangular coordiantes, where the X axis points towards the perihelion
    var x = Math.cos(E * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]) - e;
    var y = Math.sin(E * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]) * Math.sqrt(1 - e * e);

    var r = Math.sqrt(x * x + y * y);           // distance
    var v = Math.atan2(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__["DEGREES"]; // true anomaly

    var lon = _math_js__WEBPACK_IMPORTED_MODULE_1__["rev"](v + w); //longitude of the Sun

    //the Sun's ecliptic rectangular coordinates
    x = r * Math.cos(lon * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]);
    y = r * Math.sin(lon * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]);

    //We use oblecl, and rotate these coordinates
    var xequat = x;
    var yequat = y * Math.cos(oblecl * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]);
    var zequat = y * Math.sin(oblecl * _math_js__WEBPACK_IMPORTED_MODULE_1__["RADIANS"]);

    var theta = _math_js__WEBPACK_IMPORTED_MODULE_1__["TWO_PI"] * (d * 24.0 / 23.9344694 - 259.853 / 360.0); // Siderial spin time

    return _math_Quat_js__WEBPACK_IMPORTED_MODULE_3__["Quat"].yRotation(-theta).mulVec3(new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](-yequat * _astro_js__WEBPACK_IMPORTED_MODULE_2__["AU_TO_METERS"],
        zequat * _astro_js__WEBPACK_IMPORTED_MODULE_2__["AU_TO_METERS"], -xequat * _astro_js__WEBPACK_IMPORTED_MODULE_2__["AU_TO_METERS"]));

    //Convert to RA and Decl
    //var RA = Math.atan2(yequat, xequat) * math.DEGREES;
    //var Decl = Math.atan2(zequat, Math.sqrt(xequat * xequat + yequat * yequat)) * math.DEGREES;
};


/***/ }),

/***/ "./src/og/astro/jd.js":
/*!****************************!*\
  !*** ./src/og/astro/jd.js ***!
  \****************************/
/*! exports provided: SECONDS_PER_MILLISECOND, MILLISECONDS_PER_SECOND, SECONDS_PER_MINUTE, ONE_BY_SECONDS_PER_MINUTE, MINUTES_PER_HOUR, HOURS_PER_DAY, ONE_BY_HOURS_PER_DAY, SECONDS_PER_HOUR, ONE_BY_SECONDS_PER_HOUR, SECONDS_PER_12_HOURS, MINUTES_PER_DAY, ONE_BY_MINUTES_PER_DAY, SECONDS_PER_DAY, MILLISECONDS_PER_DAY, ONE_BY_MILLISECONDS_PER_DAY, ONE_BY_SECONDS_PER_DAY, DAYS_PER_JULIAN_CENTURY, DAYS_PER_JULIAN_YEAR, PICOSECOND, MODIFIED_JULIAN_DATE_DIFFERENCE, J2000, T, getDayNumber, DateToUTC, DateToTAI, UTCtoTAI, TAItoUTC, UTCtoDate, TAItoDate, addMilliseconds, addSeconds, addHours, addMinutes, addDays, getMilliseconds, getSeconds, getHours, getMinutes, getDays, secondsToDays, daysToSeconds, J2000TAI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDS_PER_MILLISECOND", function() { return SECONDS_PER_MILLISECOND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MILLISECONDS_PER_SECOND", function() { return MILLISECONDS_PER_SECOND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDS_PER_MINUTE", function() { return SECONDS_PER_MINUTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_SECONDS_PER_MINUTE", function() { return ONE_BY_SECONDS_PER_MINUTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MINUTES_PER_HOUR", function() { return MINUTES_PER_HOUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOURS_PER_DAY", function() { return HOURS_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_HOURS_PER_DAY", function() { return ONE_BY_HOURS_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDS_PER_HOUR", function() { return SECONDS_PER_HOUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_SECONDS_PER_HOUR", function() { return ONE_BY_SECONDS_PER_HOUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDS_PER_12_HOURS", function() { return SECONDS_PER_12_HOURS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MINUTES_PER_DAY", function() { return MINUTES_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_MINUTES_PER_DAY", function() { return ONE_BY_MINUTES_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SECONDS_PER_DAY", function() { return SECONDS_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MILLISECONDS_PER_DAY", function() { return MILLISECONDS_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_MILLISECONDS_PER_DAY", function() { return ONE_BY_MILLISECONDS_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_SECONDS_PER_DAY", function() { return ONE_BY_SECONDS_PER_DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DAYS_PER_JULIAN_CENTURY", function() { return DAYS_PER_JULIAN_CENTURY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DAYS_PER_JULIAN_YEAR", function() { return DAYS_PER_JULIAN_YEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PICOSECOND", function() { return PICOSECOND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODIFIED_JULIAN_DATE_DIFFERENCE", function() { return MODIFIED_JULIAN_DATE_DIFFERENCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J2000", function() { return J2000; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDayNumber", function() { return getDayNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateToUTC", function() { return DateToUTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateToTAI", function() { return DateToTAI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UTCtoTAI", function() { return UTCtoTAI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAItoUTC", function() { return TAItoUTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UTCtoDate", function() { return UTCtoDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAItoDate", function() { return TAItoDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMilliseconds", function() { return addMilliseconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSeconds", function() { return addSeconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addHours", function() { return addHours; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMinutes", function() { return addMinutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addDays", function() { return addDays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMilliseconds", function() { return getMilliseconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSeconds", function() { return getSeconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHours", function() { return getHours; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMinutes", function() { return getMinutes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDays", function() { return getDays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "secondsToDays", function() { return secondsToDays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "daysToSeconds", function() { return daysToSeconds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J2000TAI", function() { return J2000TAI; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/**
 * @module og/astro/jd
 */





/**
 * Seconds in millisecond.
 * @const
 * @default
 */
const SECONDS_PER_MILLISECOND = 0.001;

/**
 * Milliseconds in second.
 * @const
 * @default
 */
const MILLISECONDS_PER_SECOND = 1000.0;

/**
 * Seconds in minute.
 * @const
 * @default
 */
const SECONDS_PER_MINUTE = 60.0;

/**
 * One by seconds in minute.
 * @const
 * @default
 */
const ONE_BY_SECONDS_PER_MINUTE = 1.0 / SECONDS_PER_MINUTE;

/**
 * Minutes in hour.
 * @const
 * @default
 */
const MINUTES_PER_HOUR = 60.0;

/**
 * Hours in day.
 * @const
 * @default
 */
const HOURS_PER_DAY = 24.0;

/**
 * One by hours in day.
 * @const
 * @default
 */
const ONE_BY_HOURS_PER_DAY = 1.0 / HOURS_PER_DAY;

/**
 * Seconds in hour.
 * @const
 * @default
 */
const SECONDS_PER_HOUR = 3600.0;

/**
 * One by seconds in hour.
 * @const
 * @default
 */
const ONE_BY_SECONDS_PER_HOUR = 1.0 / SECONDS_PER_HOUR;

/**
 * Seconds in 12 hours.
 * @const
 * @default
 */
const SECONDS_PER_12_HOURS = 12.0 * SECONDS_PER_HOUR;

/**
 * Minutes in day.
 * @const
 * @default
 */
const MINUTES_PER_DAY = 1440.0;

/**
 * One by minutes in day.
 * @const
 * @default
 */
const ONE_BY_MINUTES_PER_DAY = 1.0 / MINUTES_PER_DAY;

/**
 * Seconds in day.
 * @const
 * @default
 */
const SECONDS_PER_DAY = 86400.0;

/**
 * Milliseconds in day.
 * @const
 * @default
 */
const MILLISECONDS_PER_DAY = 86400000.0;

/**
 * One by milliseconds in day.
 * @const
 * @default
 */
const ONE_BY_MILLISECONDS_PER_DAY = 1.0 / MILLISECONDS_PER_DAY;

/**
 * One by seconds in day.
 * @const
 * @default
 */
const ONE_BY_SECONDS_PER_DAY = 1.0 / SECONDS_PER_DAY;

/**
 * Days in julian century.
 * @const
 * @default
 */
const DAYS_PER_JULIAN_CENTURY = 36525.0;

/**
 * Days in julian year.
 * @const
 * @default
 */
const DAYS_PER_JULIAN_YEAR = 365.25;

/**
 * Seconds in picosecond.
 * @const
 * @default
 */
const PICOSECOND = 0.000000001;

/**
 * Modified julian date difference.
 * @const
 * @default
 */
const MODIFIED_JULIAN_DATE_DIFFERENCE = 2400000.5;

/**
 * Julian date of 2000 year. Epoch.
 * @const
 * @default
 */
const J2000 = 2451545.0;

/**
 * Returns julian days from Epoch.
 * @param {number} jd - Julian date.
 * @returns {number} Days from epoch
 */
function T(jd) {
    return (jd - J2000) / DAYS_PER_JULIAN_CENTURY;
};

/**
 * Gets the date's julian day.
 * @param {number} year - Year.
 * @param {number} month - Month.
 * @param {number} day - Day.
 * @returns {Number} Day number
 */
function getDayNumber(year, month, day) {
    var a = ((month - 14) / 12) | 0;
    var b = year + 4800 + a;
    return (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) -
        (((3 * (((b + 100) / 100) | 0)) / 4) | 0) + day - 32075;
};

/**
 * Converts javascript date to the universal(UTC) julian date.
 * @param {Date} date - Date.
 * @returns {number} UTC julian date
 */
function DateToUTC(date) {
    var dayNumber = getDayNumber(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate());

    var hour = date.getUTCHours() - 12;
    if (hour < 0) {
        hour += 24;
    }

    var secondsOfDay =
        date.getUTCSeconds() + hour * SECONDS_PER_HOUR +
        date.getUTCMinutes() * SECONDS_PER_MINUTE +
        date.getUTCMilliseconds() * SECONDS_PER_MILLISECOND;

    if (secondsOfDay >= SECONDS_PER_12_HOURS) {
        dayNumber--;
    }

    var extraDays = secondsOfDay * ONE_BY_SECONDS_PER_DAY | 0;
    dayNumber += extraDays;
    secondsOfDay -= SECONDS_PER_DAY * extraDays;

    if (secondsOfDay < 0) {
        dayNumber--;
        secondsOfDay += SECONDS_PER_DAY;
    }

    return dayNumber + secondsOfDay * ONE_BY_SECONDS_PER_DAY;
};

/**
 * Converts javascript date to the atomic(TAI) julian date.
 * @param {Date} date - Date.
 * @returns {number} TAI julian date
 */
function DateToTAI(date) {
    return UTCtoTAI(DateToUTC(date));
};

/**
 * Converts coordinated universal(UTC) julian date to atomic(TAI) julian date.
 * @param {number} jd - UTC julian date.
 * @returns {number} TAI julian date
 */
function UTCtoTAI(jd) {
    var leapSeconds = leapSecondsTable;

    var index = Object(_utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["binarySearch"])(leapSeconds, jd, function (a, b) {
        return a - b.jd;
    });

    if (index < 0) {
        index = ~index;
    }

    if (index >= leapSeconds.length) {
        index = leapSeconds.length - 1;
    }

    var offset = leapSeconds[index].leapSeconds;

    if (index !== 0) {
        if ((leapSeconds[index].jd - jd) * SECONDS_PER_DAY > offset) {
            offset = leapSeconds[index - 1].leapSeconds;
        }
    }

    return jd + offset * ONE_BY_SECONDS_PER_DAY;
};

/**
 * Converts atomic julian date(TAI) to the coordinated universal(UTC) julian date.
 * @param {number} tai - TAI julian date.
 * @returns {number} UTC julian date
 */
function TAItoUTC(tai) {
    var leapSeconds = leapSecondsTable;
    var index = Object(_utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["binarySearch"])(leapSeconds, tai, function (a, b) {
        return a - b.jd;
    });

    if (index < 0) {
        index = ~index;
    }

    if (index >= leapSeconds.length) {
        return tai - leapSeconds[index - 1].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }

    if (index === 0) {
        return tai - leapSeconds[0].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }

    var diff = (leapSeconds[index].jd - tai) * SECONDS_PER_DAY;

    if (diff === 0) {
        return tai - leapSeconds[index].leapSeconds * ONE_BY_SECONDS_PER_DAY;
    }

    if (diff <= 1.0) {
        return null;
    }

    return tai - leapSeconds[index - 1].leapSeconds * ONE_BY_SECONDS_PER_DAY;
};

/**
 * Converts UTC julian date to the javascript date object.
 * @param {number} utc - UTC julian date.
 * @returns {Date} JavaScript Date object
 */
function UTCtoDate(utc) {
    var julianDayNumber = utc | 0;
    var secondsOfDay = (utc - julianDayNumber) * SECONDS_PER_DAY;

    if (secondsOfDay >= SECONDS_PER_12_HOURS) {
        julianDayNumber++;
    }

    var L = (julianDayNumber + 68569) | 0;
    var N = (4 * L / 146097) | 0;
    L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
    var I = ((4000 * (L + 1)) / 1461001) | 0;
    L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
    var J = ((80 * L) / 2447) | 0;
    var day = (L - (((2447 * J) / 80) | 0)) | 0;
    L = (J / 11) | 0;
    var month = (J + 2 - 12 * L) | 0;
    var year = (100 * (N - 49) + I + L) | 0;

    var hour = secondsOfDay * ONE_BY_SECONDS_PER_HOUR | 0;
    var remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
    var minute = remainingSeconds * ONE_BY_SECONDS_PER_MINUTE | 0;
    remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
    var second = remainingSeconds | 0;
    var millisecond = (remainingSeconds - second) * MILLISECONDS_PER_SECOND | 0;

    hour += 12;
    if (hour > 23) {
        hour -= 24;
    }

    return new Date(Date.UTC(year, month - 1, day, hour, minute, second, millisecond));
};

/**
 * Converts TAI julian date to the javascript date object.
 * @param {number} tai - TAI julian date.
 * @returns {Date} JavaScript Date object
 */
function TAItoDate(tai) {

    var utc = TAItoUTC(tai);
    if (!utc) {
        utc = TAItoUTC(addSeconds(tai, -1));
        og.console.logWrn("TAItoDate:336 - can't conv utc.");
    }

    return UTCtoDate(utc);
};

/**
 * Adds milliseconds to the julian date.
 * @param {number} jd - Julian date.
 * @param {number} milliseconds - Milliseconds to add.
 * @returns {number} Julian date
 */
function addMilliseconds(jd, milliseconds) {
    return jd + milliseconds * ONE_BY_MILLISECONDS_PER_DAY;
};

/**
 * Adds seconds to the julian date.
 * @param {number} jd - Julian date.
 * @param {number} seconds - Seconds to add.
 * @returns {number} Julian date
 */
function addSeconds(jd, seconds) {
    return jd + seconds * ONE_BY_SECONDS_PER_DAY;
};

/**
 * Adds hours to the julian date.
 * @param {number} jd - Julian date.
 * @param {number} hours - Hours to add.
 * @returns {number} Julian date
 */
function addHours(jd, hours) {
    return jd + hours * ONE_BY_HOURS_PER_DAY;
};

/**
 * Adds minutes to the julian date.
 * @param {number} jd - Julian date.
 * @param {number} minutes - Minutes to add.
 * @returns {number} Julian date
 */
function addMinutes(jd, minutes) {
    return jd + minutes * MINUTES_PER_DAY;
};

/**
 * Adds days to the julian date.
 * @param {number} jd - Julian date.
 * @param {number} days - Days to add.
 * @returns {number} Julian date
 */
function addDays(jd, days) {
    return jd + days;
};

/**
 * Gets milliseconds of a julian date.
 * @param {number} js - julian date.
 * @returns {number} Milliseconds
 */
function getMilliseconds(jd) {
    var s = jd - (jd | 0);
    s *= SECONDS_PER_DAY;
    return (s - (s | 0)) * MILLISECONDS_PER_SECOND | 0;
};

/**
 * Gets seconds of a julian date.
 * @param {number} js - julian date.
 * @returns {number} Seconds
 */
function getSeconds(jd) {
    var s = jd - (jd | 0);
    return s * SECONDS_PER_DAY;
};

/**
 * Gets hours of a julian date.
 * @param {number} js - julian date.
 * @returns {number} Hours
 */
function getHours(jd) {
    var julianDayNumber = jd | 0;
    var secondsOfDay = (jd - julianDayNumber) * SECONDS_PER_DAY;

    var hour = secondsOfDay * ONE_BY_SECONDS_PER_HOUR | 0;
    var remainingSeconds = secondsOfDay - hour * SECONDS_PER_HOUR;
    var minute = remainingSeconds * ONE_BY_SECONDS_PER_MINUTE | 0;
    remainingSeconds = remainingSeconds - minute * SECONDS_PER_MINUTE;
    var second = remainingSeconds | 0;
    var millisecond = (remainingSeconds - second) * MILLISECONDS_PER_SECOND | 0;

    hour += 12 + minute / 60 + second / 3600 + millisecond / 1000;
    if (hour > 23) {
        hour -= 24;
    }

    return hour;
};

/**
 * Gets minutes of a julian date.
 * @param {number} js - julian date.
 * @returns {number} Minutes
 */
function getMinutes(jd) {
    var s = jd - (jd | 0);
    return s * MINUTES_PER_DAY | 0;
};

/**
 * Gets days of a julian date.
 * @param {number} js - julian date.
 * @returns {number} Days
 */
function getDays(jd) {
    return jd | 0;
};

/**
 * Returns days in seconds.
 * @param {number} s - Seconds.
 * @returns {number} Days
 */
function secondsToDays(s) {
    return s * ONE_BY_SECONDS_PER_DAY;
};

/**
 * Returns seconds in days.
 * @param {number} d - Days.
 * @returns {number} Seconds
 */
function daysToSeconds(d) {
    return d * SECONDS_PER_DAY;
};

function __ls(jd, leapSeconds) {
    return {
        "jd": jd,
        "leapSeconds": leapSeconds
    };
};

const leapSecondsTable = [
    __ls(2441317.5, 10.0),  // 1972-01-01T00:00:00.000Z
    __ls(2441499.5, 11.0),  // 1972-07-01T00:00:00.000Z
    __ls(2441683.5, 12.0),  // 1973-01-01T00:00:00.000Z
    __ls(2442048.5, 13.0),  // 1974-01-01T00:00:00.000Z
    __ls(2442413.5, 14.0),  // 1975-01-01T00:00:00.000Z
    __ls(2442778.5, 15.0),  // 1976-01-01T00:00:00.000Z
    __ls(2443144.5, 16.0),  // 1977-01-01T00:00:00.000Z
    __ls(2443509.5, 17.0),  // 1978-01-01T00:00:00.000Z
    __ls(2443874.5, 18.0),  // 1979-01-01T00:00:00.000Z
    __ls(2444239.5, 19.0),  // 1980-01-01T00:00:00.000Z
    __ls(2444786.5, 20.0),  // 1981-07-01T00:00:00.000Z
    __ls(2445151.5, 21.0),  // 1982-07-01T00:00:00.000Z
    __ls(2445516.5, 22.0),  // 1983-01-01T00:00:00.000Z
    __ls(2446247.5, 23.0),  // 1985-07-01T00:00:00.000Z
    __ls(2447161.5, 24.0),  // 1988-01-01T00:00:00.000Z
    __ls(2447892.5, 25.0),  // 1990-01-01T00:00:00.000Z
    __ls(2448257.5, 26.0),  // 1991-01-01T00:00:00.000Z
    __ls(2448804.5, 27.0),  // 1992-07-01T00:00:00.000Z
    __ls(2449169.5, 28.0),  // 1993-07-01T00:00:00.000Z
    __ls(2449534.5, 29.0),  // 1994-07-01T00:00:00.000Z
    __ls(2450083.5, 30.0),  // 1996-01-01T00:00:00.000Z
    __ls(2450630.5, 31.0),  // 1997-07-01T00:00:00.000Z
    __ls(2451179.5, 32.0),  // 1999-01-01T00:00:00.000Z
    __ls(2453736.5, 33.0),  // 2006-01-01T00:00:00.000Z
    __ls(2454832.5, 34.0),  // 2009-01-01T00:00:00.000Z
    __ls(2456109.5, 35.0),  // 2012-07-01T00:00:00.000Z
    __ls(2457204.5, 36.0)   // 2015-07-01T00:00:00.000Z
];

const J2000TAI = UTCtoTAI(J2000);


/***/ }),

/***/ "./src/og/bv/Box.js":
/*!**************************!*\
  !*** ./src/og/bv/Box.js ***!
  \**************************/
/*! exports provided: Box */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/bv/Box
 */





/**
 * Bounding box class.
 * @class
 */
class Box {
    constructor() {
        /**
         * Vertices array.
         * @public
         * @type{Array.<og.math.Vector3>}
         */
        this.vertices = [new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](), new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"]()];
    }

    /**
     * Sets bounding box coordinates by the bounds array.
     * @param {Array.<number>} bounds - Bounds is an array where [minX, maxX, minY, maxY, minZ, maxZ]
     */
    setFromBounds(bounds) {
        var xmin = bounds[0], xmax = bounds[1],
            ymin = bounds[2], ymax = bounds[3],
            zmin = bounds[4], zmax = bounds[5];

        this.vertices[0].set(xmin, ymin, zmin);
        this.vertices[1].set(xmax, ymin, zmin);
        this.vertices[2].set(xmax, ymin, zmax);
        this.vertices[3].set(xmin, ymin, zmax);
        this.vertices[4].set(xmin, ymax, zmin);
        this.vertices[5].set(xmax, ymax, zmin);
        this.vertices[6].set(xmax, ymax, zmax);
        this.vertices[7].set(xmin, ymax, zmax);
    }

    /**
     * Sets bounding box coordiantes by ellipsoid geodetic extend.
     * @param {og.Ellipsoid} ellipsoid - Ellipsoid.
     * @param {og.Extent} extent - Geodetic extent.
     */
    setFromExtent(ellipsoid, extent) {
        this.setFromBounds(extent.getCartesianBounds(ellipsoid));
    }
};



/***/ }),

/***/ "./src/og/bv/Sphere.js":
/*!*****************************!*\
  !*** ./src/og/bv/Sphere.js ***!
  \*****************************/
/*! exports provided: Sphere */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/bv/Sphere
 */





/**
 * Bounding sphere class.
 * @class
 * @param {Number} [radius] - Bounding sphere radius.
 * @param {og.math.Vector3} [center] - Bounding sphere coordiantes.
 */
class Sphere {
    constructor(radius, center) {

        /**
         * Sphere radius.
         * @public
         * @type {Number}
         */
        this.radius = radius || 0;

        /**
         * Sphere coordiantes.
         * @public
         * @type {og.math.Vector3}
         */
        this.center = center ? center.clone() : new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"]();
    }

    /**
     * Sets bounding sphere coordinates by the bounds array.
     * @param {Array.<number>} bounds - Bounds is an array where [minX, maxX, minY, maxY, minZ, maxZ]
     */
    setFromBounds(bounds) {
        this.center.set(bounds[0] + (bounds[1] - bounds[0]) / 2, bounds[2] + (bounds[3] - bounds[2]) / 2, bounds[4] + (bounds[5] - bounds[4]) / 2);
        this.radius = this.center.distance(new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](bounds[0], bounds[2], bounds[4]));
    }

    /**
     * Sets bounding sphere coordiantes by ellipsoid geodetic extend.
     * @param {og.Ellipsoid} ellipsoid - Ellipsoid.
     * @param {og.Extent} extent - Geodetic extent.
     */
    setFromExtent(ellipsoid, extent) {
        this.setFromBounds(extent.getCartesianBounds(ellipsoid));
    }
};




/***/ }),

/***/ "./src/og/camera/Camera.js":
/*!*********************************!*\
  !*** ./src/og/camera/Camera.js ***!
  \*********************************/
/*! exports provided: Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _Events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Events.js */ "./src/og/Events.js");
/* harmony import */ var _Frustum_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Frustum.js */ "./src/og/Frustum.js");
/* harmony import */ var _math_Vec2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vec2.js */ "./src/og/math/Vec2.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/* harmony import */ var _math_Mat3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Mat3.js */ "./src/og/math/Mat3.js");
/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Mat4.js */ "./src/og/math/Mat4.js");
/**
 * @module og/camera/Camera
 */












/**
 * Camera class.
 * @class
 * @param {og.Renderer} [renderer] - Renderer uses the camera instance.
 * @param {Object} [options] - Camera options:
 * @param {Object} [options.name] - Camera name.
 * @param {number} [options.viewAngle=30] - Camera angle of view. Default is 30.0
 * @param {number} [options.near=1] - Camera near plane distance. Default is 1.0
 * @param {number} [options.far=og.math.MAX] - Camera far plane distance. Deafult is og.math.MAX
 * @param {og.math.Vector3} [options.eye=[0,0,0]] - Camera eye position. Default (0,0,0)
 * @param {og.math.Vector3} [options.look=[0,0,0]] - Camera look position. Default (0,0,0)
 * @param {og.math.Vector3} [options.up=[0,1,0]] - Camera eye position. Default (0,1,0)
 *
 * @fires og.Camera#viewchange
 */
class Camera {
    constructor(renderer, options) {

        /**
         * Assigned renderer.
         * @public
         * @type {og.Renderer}
         */
        this.renderer = null;

        /**
         * Camera events handler.
         * @public
         * @type {og.Events}
         */
        this.events = new _Events_js__WEBPACK_IMPORTED_MODULE_1__["Events"](EVENT_NAMES);

        /**
         * Camera position.
         * @public
         * @type {og.math.Vector3}
         */
        this.eye = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"]();

        /**
         * Camera frustum. 
         * @public
         * @type {og.Frustum}
         */
        this.frustum = new _Frustum_js__WEBPACK_IMPORTED_MODULE_2__["Frustum"]();

        /**
         * Aspect ratio.
         * @protected
         * @type {Number}
         */
        this._aspect = options.aspect || 0;

        /**
         * Camera near distance.
         * @protected
         * @type {Number}
         */
        this._nearDist = 0;

        /**
         * Camera far distance.
         * @protected
         * @type {Number}
         */
        this._farDist = 0;

        /**
         * Camera view angle in degrees.
         * @protected
         * @type {Number}
         */
        this._viewAngle = 0;

        /**
         * Camera normal matrix.
         * @protected
         * @type {og.math.Matrix3}
         */
        this._normalMatrix = new _math_Mat3_js__WEBPACK_IMPORTED_MODULE_6__["Mat3"]();

        /**
         * Camera projection matrix.
         * @protected
         * @type {og.math.Matrix4}
         */
        this._projectionMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]();

        /**
         * Camera view matrix.
         * @protected
         * @type {og.math.Matrix4}
         */
        this._viewMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]();

        /**
         * Product of projection and view matrices.
         * @protected
         * @type {og.math.Matrix4}
         */
        this._projectionViewMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]();

        /**
         * Inverse projectionView Matrix.
         * @protected
         * @type {og.math.Matrix4}
         */
        this._inverseProjectionViewMatrix = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]();

        /**
         * Camera projection matrix for small near and far distances.
         * @protected
         * @type {og.math.Matrix4}
         */
        this._projectionMatrixPrecise = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]();

        /**
         * Camera right vector.
         * @protected
         * @type {og.math.Vector3}
         */
        this._u = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](0, 1, 0); //up x n

        /**
         * Camera up vector.
         * @protected
         * @type {og.math.Vector3}
         */
        this._v = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](1, 0, 0); //n x u - UP

        this.slope = 0;

        /**
         * Camera forward vector.
         * @protected
         * @type {og.math.Vector3}
         */
        this._n = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](0, 0, 1); //eye - look - FORWARD

        this._pu = this._u;
        this._pv = this._v;
        this._pn = this._n;
        this._peye = this.eye;
        this._moved = false;

        this._tanViewAngle_hrad = 0;
        this._tanViewAngle_hradOneByHeight = 0;

        this.renderer = renderer;

        renderer && this._initialize(options);
    }

    /**
     * Updates model view matrix.
     * @protected
     */
    _setViewMatrix() {
        var u = this._u,
            v = this._v,
            n = this._n,
            eye = this.eye;

        this._viewMatrix.set([u.x, v.x, n.x, 0,
        u.y, v.y, n.y, 0,
        u.z, v.z, n.z, 0,
        -eye.dot(u), -eye.dot(v), -eye.dot(n), 1.0]);
    }

    checkMoveEnd() {
        var u = this._u,
            v = this._v,
            n = this._n,
            eye = this.eye;

        if (this.events.moveend.handlers.length) {
            if (this._peye.equal(eye) &&
                this._pu.equal(u) &&
                this._pv.equal(v) &&
                this._pn.equal(n)) {
                if (this._moved) {
                    this.events.dispatch(this.events.moveend, this);
                }
                this._moved = false;
            } else {
                this._moved = true;
            }
        }

        this._pu = u;
        this._pv = v;
        this._pn = n;
        this._peye = eye;
    }

    /**
     * Camera initialization.
     * @public
     * @param {og.Renderer} renderer - OpenGlobus renderer object.
     * @param {Object} [options] - Camera options:
     * @param {number} [options.viewAngle] - Camera angle of view. Default is 30.0
     * @param {number} [options.near] - Camera near plane distance. Default is 1.0
     * @param {number} [options.far] - Camera far plane distance. Deafult is og.math.MAX
     * @param {og.math.Vector3} [options.eye] - Camera eye position. Default (0,0,0)
     * @param {og.math.Vector3} [options.look] - Camera look position. Default (0,0,0)
     * @param {og.math.Vector3} [options.up] - Camera eye position. Default (0,1,0)
     */
    _initialize(options) {

        this.setProjectionMatrix(
            options.viewAngle || defaultOptions.viewAngle,
            this._aspect || this.renderer.handler.getClientAspect(),
            options.near || defaultOptions.near,
            options.far || defaultOptions.far);

        this.set(
            options.eye || defaultOptions.eye.clone(),
            options.look || defaultOptions.look.clone(),
            options.up || defaultOptions.up.clone());
    }

    getUp() {
        return this._v;
    }

    getDown() {
        return this._v.negateTo();
    }

    getRight() {
        return this._u;
    }

    getLeft() {
        return this._u.negateTo();
    }

    getForward() {
        return this._n;
    }

    getBackward() {
        return this._n.negateTo();
    }

    /**
     * Clone camera instance to another one.
     * @public
     * @virtual
     * @returns {og.Camera} - Cloned camera instance.
     */
    clone() {
        var newcam = new Camera();
        newcam.eye.copy(cam.eye);
        newcam._u.copy(cam._u);
        newcam._v.copy(cam._v);
        newcam._n.copy(cam._n);
        newcam.renderer = cam.renderer;
        newcam._projectionMatrix.copy(cam._projectionMatrix);
        newcam._viewMatrix.copy(cam._viewMatrix);
        newcam._projectionViewMatrix.copy(cam._projectionViewMatrix);
        newcam._inverseProjectionViewMatrix.copy(cam._inverseProjectionViewMatrix);
        newcam.frustum.setFrustum(newcam._projectionViewMatrix);
        return newcam;
    }

    /**
     * Updates camera view space.
     * @public
     * @virtual
     */
    update() {

        this._setViewMatrix();

        this._projectionViewMatrix = this._projectionMatrix.mul(this._viewMatrix);
        this.frustum.setFrustum(this._projectionViewMatrix._m);
        this._inverseProjectionViewMatrix = this._projectionViewMatrix.inverseTo();
        this._normalMatrix = this._viewMatrix.toMatrix3();//this._viewMatrix.toInverseMatrix3().transposeTo();

        this.events.dispatch(this.events.viewchange, this);
    }

    /**
     * Refresh camera matrices.
     * @public
     */
    refresh() {
        this.setProjectionMatrix(this._viewAngle, this._aspect, this._nearDist, this._farDist);
        this.update();
    }

    /**
     * Sets aspect ratio.
     * @public
     * @param {Number} aspect - Camera aspect ratio.
     */
    setAspectRatio(aspect) {
        this._aspect = aspect;
        this.refresh();
    }

    /**
     * Returns aspect ratio.
     * @public
     * @returns {number} - Aspect ratio.
     */
    getAspectRatio() {
        return this._aspect;
    }

    /**
     * Sets far camera distance.
     * @public
     * @param {number} distance - Far distance.
     */
    setFar(distance) {
        this._farDist = distance;
        this.refresh();
    }

    /**
     * Gets far distance.
     * @public
     * @returns {number} - Far plane distance.
     */
    getFar() {
        return this._farDist;
    }

    /**
     * Sets camera's near distance.
     * @public
     * @param {number} distance - Near distance.
     */
    setNear(distance) {
        this._nearDist = distance;
        this.refresh();
    }

    /**
     * Gets near distance.
     * @public
     * @returns {number} - Near plane distance.
     */
    getNear() {
        return this._nearDist;
    }

    /**
     * Sets up camera projection matrix.
     * @public
     * @param {nnumber} angle - Camera's view angle.
     * @param {number} aspect - Screen aspect ration.
     * @param {number} near - Near camera distance.
     * @param {number} far - Far camera distance.
     */
    setProjectionMatrix(angle, aspect, near, far) {
        this._viewAngle = angle;
        this._aspect = aspect;
        this._nearDist = near;
        this._farDist = far;

        this._tanViewAngle_hrad = Math.tan(angle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS_HALF"]);
        this._tanViewAngle_hradOneByHeight = this._tanViewAngle_hrad * this.renderer.handler._oneByHeight;

        var c = this.renderer.handler.canvas;
        this._projSizeConst = Math.min(c.clientWidth, c.clientHeight) / (this._viewAngle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"]);

        this._projectionMatrix.setPerspective(angle, aspect, near, far);
        this._projectionMatrixPrecise.setPerspective(angle, aspect, 0.1, 10);
    }

    /**
     * Sets camera view angle in degrees.
     * @public
     * @param {number} angle - View angle.
     */
    setViewAngle(angle) {
        this._viewAngle = angle;
        this.refresh();
    }

    /**
     * Sets camera to eye position.
     * @public
     * @param {og.math.Vector3} eye - Camera position.
     * @param {og.math.Vector3} look - Look point.
     * @param {og.math.Vector3} up - Camera up vector.
     * @returns {og.Camera} - This camera.
     */
    set(eye, look, up) {
        this.eye.x = eye.x;
        this.eye.y = eye.y;
        this.eye.z = eye.z;
        look = look || this._n;
        up = up || this._v;
        this._n.x = eye.x - look.x;
        this._n.y = eye.y - look.y;
        this._n.z = eye.z - look.z;
        this._u.copy(up.cross(this._n));
        this._n.normalize();
        this._u.normalize();
        this._v.copy(this._n.cross(this._u));
        return this;
    }

    /**
     * Sets camera look point.
     * @public
     * @param {og.math.Vector3} look - Look point.
     * @param {og.math.Vector3} [up] - Camera up vector otherwise camera current up vector(this._v)
     */
    look(look, up) {
        this._n.set(this.eye.x - look.x, this.eye.y - look.y, this.eye.z - look.z);
        this._u.copy((up || this._v).cross(this._n));
        this._n.normalize();
        this._u.normalize();
        this._v.copy(this._n.cross(this._u));
    }

    /**
     * Slides camera to vector d - (du, dv, dn).
     * @public
     * @param {number} du - delta X.
     * @param {number} dv - delta Y.
     * @param {number} dn - delta Z.
     */
    slide(du, dv, dn) {
        this.eye.x += du * this._u.x + dv * this._v.x + dn * this._n.x;
        this.eye.y += du * this._u.y + dv * this._v.y + dn * this._n.y;
        this.eye.z += du * this._u.z + dv * this._v.z + dn * this._n.z;
    }

    /**
     * Roll the camera to the angle in degrees.
     * @public
     * @param {number} angle - Delta roll angle in degrees.
     */
    roll(angle) {
        var cs = Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * angle);
        var sn = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * angle);
        var t = this._u.clone();
        this._u.set(cs * t.x - sn * this._v.x, cs * t.y - sn * this._v.y, cs * t.z - sn * this._v.z);
        this._v.set(sn * t.x + cs * this._v.x, sn * t.y + cs * this._v.y, sn * t.z + cs * this._v.z);
    }

    /**
     * Pitch the camera to the angle in degrees.
     * @public
     * @param {number} angle - Delta pitch angle in degrees.
     */
    pitch(angle) {
        var cs = Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * angle);
        var sn = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * angle);
        var t = this._n.clone();
        this._n.set(cs * t.x - sn * this._v.x, cs * t.y - sn * this._v.y, cs * t.z - sn * this._v.z);
        this._v.set(sn * t.x + cs * this._v.x, sn * t.y + cs * this._v.y, sn * t.z + cs * this._v.z);
    }

    /**
     * Yaw the camera to the angle in degrees.
     * @public
     * @param {number} angle - Delta yaw angle in degrees.
     */
    yaw(angle) {
        var cs = Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * angle);
        var sn = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * angle);
        var t = this._u.clone();
        this._u.set(cs * t.x - sn * this._n.x, cs * t.y - sn * this._n.y, cs * t.z - sn * this._n.z);
        this._n.set(sn * t.x + cs * this._n.x, sn * t.y + cs * this._n.y, sn * t.z + cs * this._n.z);
    }

    /**
     * Returns normal vector direction to to the unprojected screen point from camera eye.
     * @public
     * @param {number} x - Scren X coordinate.
     * @param {number} y - Scren Y coordinate.
     * @returns {og.math.Vector3} - Direction vector.
     */
    unproject(x, y) {
        var c = this.renderer.handler.canvas,
            w = c.width * 0.5,
            h = c.height * 0.5;

        var px = (x - w) / w,
            py = -(y - h) / h;

        var world1 = this._inverseProjectionViewMatrix.mulVec4(new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_5__["Vec4"](px, py, -1, 1)).affinity(),
            world2 = this._inverseProjectionViewMatrix.mulVec4(new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_5__["Vec4"](px, py, 0, 1)).affinity();

        return world2.subA(world1).toVec3().normalize();
    }

    /**
     * Gets projected 3d point to the 2d screen coordiantes.
     * @public
     * @param {og.math.Vector3} v - Cartesian 3d coordiantes.
     * @returns {og.math.Vector2} - Screen point coordinates.
     */
    project(v) {
        var r = this._projectionViewMatrix.mulVec4(v.toVector4()),
            c = this.renderer.handler.canvas;
        return new _math_Vec2_js__WEBPACK_IMPORTED_MODULE_3__["Vec2"]((1 + r.x / r.w) * c.width * 0.5, (1 - r.y / r.w) * c.height * 0.5);
    }

    /**
     * Rotates camera around center point.
     * @public
     * @param {number} angle - Rotation angle in radians.
     * @param {boolaen} isArc - If true camera up vector gets from current up vector every frame,
     * otherwise up is always input parameter.
     * @param {og.math.Vector3} center - Point that the camera rotates around.
     * @param {og.math.Vecto3} [up] - Camera up vector.
     */
    rotateAround(angle, isArc, center, up) {
        center = center || _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"].ZERO;
        up = up || _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"].UP;

        var rot = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]().setRotation(isArc ? this._v : up, angle);
        var tr = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]().setIdentity().translate(center);
        var ntr = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_7__["Mat4"]().setIdentity().translate(center.negateTo());

        var trm = tr.mul(rot).mul(ntr);

        this.eye = trm.mulVec3(this.eye);
        this._v = rot.mulVec3(this._v).normalize();
        this._u = rot.mulVec3(this._u).normalize();
        this._n = rot.mulVec3(this._n).normalize();
    }

    /**
     * Rotates camera around center point by horizontal.
     * @public
     * @param {number} angle - Rotation angle in radians.
     * @param {boolaen} isArc - If true camera up vector gets from current up vector every frame,
     * otherwise up is always input parameter.
     * @param {og.math.Vector3} center - Point that the camera rotates around.
     * @param {og.math.Vector3} [up] - Camera up vector.
     */
    rotateHorizontal(angle, isArc, center, up) {
        this.rotateAround(angle, isArc, center, up);
    }

    /**
     * Rotates camera around center point by vecrtical.
     * @param {number} angle - Rotation angle in radians.
     * @param {og.math.Vector3} center - Point that the camera rotates around.
     */
    rotateVertical(angle, center) {
        this.rotateAround(angle, false, center, this._u);
    }

    /**
     * Gets 3d size factor. Uses in LOD distance calculation.
     * @public
     * @param {og.math.Vector3} p - Far point.
     * @param {og.math.Vector3} r - Far point.
     * @returns {number} - Size factor.
     */
    projectedSize(p, r) {
        return Math.atan(r / this.eye.distance(p)) * this._projSizeConst;
    }

    /**
     * Returns normal matrix.
     * @public
     * @returns {og.math.Matrix3} - Normal matrix.
     */
    getNormalMatrix() {
        return this._normalMatrix;
    }

    /**
     * Returns projection matrix.
     * @public
     * @returns {og.math.Matrix4} - Projection matrix.
     */
    getProjectionMatrix() {
        return this._projectionMatrix;
    }

    /**
     * Returns model matrix.
     * @public
     * @returns {og.math.Matrix4} - View matrix.
     */
    getViewMatrix() {
        return this._viewMatrix;
    }

    /**
     * Returns projection and model matrix product.
     * @public
     * @return {og.math.Matrix4} - Projection-view matrix.
     */
    getProjectionViewMatrix() {
        return this._projectionViewMatrix;
    }

    /**
     * Returns inverse projection and model matrix product.
     * @public
     * @returns {og.math.Matrix4} - Inversed projection-view matrix.
     */
    getInverseProjecttionViewMatrix() {
        return this._inverseProjectionViewMatrix;
    }
};

const EVENT_NAMES = [
    /**
     * When camera has been updated.
     * @event og.Camera#viewchange
     */
    "viewchange",

    /**
     * Camera is stopped.
     * @event og.Camera#moveend
     */
    "moveend"
];

const defaultOptions = {
    'viewAngle': 30,
    'near': 1,
    'far': _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"],
    'eye': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](0, 0, 0),
    'look': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](0, 0, 0),
    'up': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_4__["Vec3"](0, 1, 0)
};



/***/ }),

/***/ "./src/og/camera/PlanetCamera.js":
/*!***************************************!*\
  !*** ./src/og/camera/PlanetCamera.js ***!
  \***************************************/
/*! exports provided: PlanetCamera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlanetCamera", function() { return PlanetCamera; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera.js */ "./src/og/camera/Camera.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _Lock_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Lock.js */ "./src/og/Lock.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Mat4.js */ "./src/og/math/Mat4.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Ray.js */ "./src/og/math/Ray.js");
/**
 * @module og/camera/PlanetCamera
 */












/**
 * Planet camera.
 * @class
 * @extends {og.Camera}
 * @param {og.RenderNode} planet - Planet render node.
 * @param {Object} [options] - Planet camera options:
 * @param {Object} [options.name] - Camera name.
 * @param {number} [options.viewAngle] - Camera angle of view. Default is 35.0
 * @param {number} [options.near] - Camera near plane distance. Default is 1.0
 * @param {number} [options.far] - Camera far plane distance. Deafult is og.math.MAX
 * @param {number} [options.minAltitude] - Minimal altitude for the camera. Deafult is 50
 * @param {og.math.Vector3} [options.eye] - Camera eye position. Default (0,0,0)
 * @param {og.math.Vector3} [options.look] - Camera look position. Default (0,0,0)
 * @param {og.math.Vector3} [options.up] - Camera eye position. Default (0,1,0)
 */
class PlanetCamera extends _Camera_js__WEBPACK_IMPORTED_MODULE_2__["Camera"] {
    constructor(planet, options) {
        super(planet.renderer, options);
        /**
         * Assigned camera's planet.
         * @public
         * @type {og.scene.Planet}
         */
        this.planet = planet;

        /**
         * Minimal alltitude that camera can reach over the terrain.
         * @public
         * @type {number}
         */
        this.minAltitude = options.minAltitude || 50;

        /**
         * Current geographical degree position.
         * @protected
         * @type {og.LonLat}
         */
        this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);

        /**
         * Current geographical mercator position.
         * @protected
         * @type {og.LonLat}
         */
        this._lonLatMerc = this._lonLat.forwardMercator();

        /**
         * Current altitude.
         * @protected
         * @type {number}
         */
        this._terrainAltitude = this._lonLat.height;

        /**
         * Cartesian coordinates on the terrain.
         * @protected
         * @type {og.math.Vector3}
         */
        this._terrainPoint = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"]();

        /**
         * Quad node that camera flies over.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._insideSegment = null;

        this.slope = 0;

        /**
         * Coordinates that depends on what segment class we are fling over.
         * It can be WGS84 or Mercator coordinates. Gets in og.quadTree.Node
         * @protected
         * @type {og.LonLat}
         */
        this._insideSegmentPosition = null;

        this._keyLock = new _Lock_js__WEBPACK_IMPORTED_MODULE_4__["Key"]();

        //Camera's flying frames
        this._framesArr = [];
        this._framesCounter = 0;
        this._numFrames = 50;
        this._completeCallback = null;
        this._flying = false;
    }

    /**
     * Clone planet camera instance to another one.
     * @public
     * @virtual
     * @returns {og.PlanetCamera}
     */
    clone() {
        var newcam = new PlanetCamera();
        newcam.eye.copy(cam.eye);
        newcam._u.copy(cam._u);
        newcam._v.copy(cam._v);
        newcam._n.copy(cam._n);
        newcam.renderer = cam.renderer;
        newcam._projectionMatrix.copy(cam._projectionMatrix);
        newcam._viewMatrix.copy(cam._viewMatrix);
        newcam._projectionViewMatrix.copy(cam._projectionViewMatrix);
        newcam._inverseProjectionViewMatrix.copy(cam._inverseProjectionViewMatrix);
        newcam.frustum.setFrustum(newcam._projectionViewMatrix);
        newcam.planet = cam.planet;
        newcam._lonLat = cam._lonLat.clone();
        return newcam;
    }

    /**
     * Updates camera view space.
     * @public
     * @virtual
     */
    update() {

        this._setViewMatrix();

        this._projectionViewMatrix = this._projectionMatrix.mul(this._viewMatrix);
        this.frustum.setFrustum(this._projectionViewMatrix._m);

        this._inverseProjectionViewMatrix = this._projectionMatrixPrecise.mul(this._viewMatrix).inverseTo();

        //this._normalMatrix = this._viewMatrix.toInverseMatrix3().transposeTo();
        this._normalMatrix = this._viewMatrix.toMatrix3();

        this.updateGeodeticPosition();

        this.slope = this._n.dot(this.eye.normal());

        this.events.dispatch(this.events.viewchange, this);
    }

    updateGeodeticPosition() {
        this._lonLat = this.planet.ellipsoid.cartesianToLonLat(this.eye);
        if (Math.abs(this._lonLat.lat) <= _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MAX_LAT"]) {
            this._lonLatMerc = this._lonLat.forwardMercator();
        }
    }

    /**
     * Sets altitude over the terrain.
     * @public
     * @param {number} alt - Altitude over the terrain.
     */
    setAltitude(alt) {
        var n = this.eye.normal();
        var t = this._terrainPoint;
        this.eye.x = n.x * alt + t.x;
        this.eye.y = n.y * alt + t.y;
        this.eye.z = n.z * alt + t.z;
        this._terrainAltitude = alt;
        this.update();
    }

    /**
     * Gets altitude over the terrain.
     * @public
     */
    getAltitude() {
        return this._terrainAltitude;
    }

    /**
     * Moves camera to the geographical position.
     * @public
     * @param {og.LonLat} lonlat - Geographical position.
     */
    setLonLat(lonlat, up) {
        this._lonLat.set(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
        var newEye = this.planet.ellipsoid.lonLatToCartesian(this._lonLat);
        var rot = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_6__["Mat4"]().rotateBetweenVectors(newEye.normal(), this.eye.normal());
        this.eye = newEye;
        this._v = rot.mulVec3(this._v);
        this._u = rot.mulVec3(this._u);
        this._n = rot.mulVec3(this._n);
    }

    /**
     * Returns camera geographical position.
     * @public
     * @returns {og.LonLat}
     */
    getLonLat() {
        return this._lonLat;
    }

    /**
     * Returns camera height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this._lonLat.height;
    }

    /**
     * Places camera to view to the geographical point.
     * @public
     * @param {og.LonLat} lonlat - New camera and camera view position.
     * @param {og.math.Vector3} [up] - Camera UP vector. Default (0,1,0)
     */
    viewLonLat(lonlat, up) {
        this._lonLat.set(lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
        var el = this.planet.ellipsoid;
        var newEye = el.lonLatToCartesian(this._lonLat);
        var newLook = el.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](this._lonLat.lon, this._lonLat.lat, 0));
        this.set(newEye, newLook, up || _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].UP);
    }

    /**
     * Gets position by viewable extent.
     * @public
     * @param {og.Extent} extent - Viewable extent.
     * @returns {og.math.Vector3}
     */
    getExtentPosition(extent) {

        var north = extent.getNorth();
        var south = extent.getSouth();
        var east = extent.getEast();
        var west = extent.getWest();

        if (west > east) {
            east += 360;
        }

        var e = this.planet.ellipsoid;

        var cart = new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](east, north);
        var northEast = e.lonLatToCartesian(cart);
        cart.lat = south;
        var southEast = e.lonLatToCartesian(cart);
        cart.lon = west;
        var southWest = e.lonLatToCartesian(cart);
        cart.lat = north;
        var northWest = e.lonLatToCartesian(cart);

        var center = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].sub(northEast, southWest).scale(0.5).addA(southWest);

        var mag = center.length();
        if (mag < 0.000001) {
            cart.lon = (east + west) * 0.5;
            cart.lat = (north + south) * 0.5;
            center = e.lonLatToCartesian(cart);
        }

        northWest.subA(center);
        southEast.subA(center);
        northEast.subA(center);
        southWest.subA(center);

        var direction = center.normal();//ellipsoid.getSurfaceNormal(center).negate().normalize();
        var right = direction.cross(_math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].UP).normalize();
        var up = right.cross(direction).normalize();

        var height = Math.max(
            Math.abs(up.dot(northWest)),
            Math.abs(up.dot(southEast)),
            Math.abs(up.dot(northEast)),
            Math.abs(up.dot(southWest))
        );

        var width = Math.max(
            Math.abs(right.dot(northWest)),
            Math.abs(right.dot(southEast)),
            Math.abs(right.dot(northEast)),
            Math.abs(right.dot(southWest))
        );

        var tanPhi = Math.tan(this._viewAngle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * 0.5);
        var tanTheta = this._aspect * tanPhi;
        var d = Math.max(width / tanTheta, height / tanPhi);

        center.normalize();
        center.scale(mag + d);
        return center;
    }

    /**
     * View current extent.
     * @public
     * @param {og.Extent} extent - Current extent.
     */
    viewExtent(extent) {
        this.stopFlying();
        this.set(this.getExtentPosition(extent), _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO, _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].UP);
        this.refresh();
    }

    /**
     * Flies to the current extent.
     * @public
     * @param {og.Extent} extent - Current extent.
     * @param {og.math.Vector3} [up] - Camera UP in the end of flying. Default - (0,1,0)
     * @param {cameraCallback} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {cameraCallback} [startCallback] - Callback that calls befor the flying begins.
     */
    flyExtent(extent, up, completeCallback, startCallback) {
        this.flyCartesian(this.getExtentPosition(extent), _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO,
            up, completeCallback, startCallback);
    }

    /**
     * Flies to the cartesian coordinates.
     * @public
     * @param {og.math.Vector3} cartesian - Finish cartesian coordinates.
     * @param {og.math.Vector3} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
     * @param {og.math.Vector3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
     * @param {cameraCallback} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {cameraCallback} [startCallback] - Callback that calls befor the flying begins.
     */
    flyCartesian(cartesian, look, up, completeCallback, startCallback) {

        //???????
        //if (this.eye.distance(cartesian) < 23000) {
        //    return;
        //}

        this.stopFlying();

        this._completeCallback = completeCallback;

        if (startCallback) {
            startCallback.call(this);
        }

        var _look = look || _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO;
        if (look instanceof _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"]) {
            _look = this.planet.ellipsoid.lonLatToCartesian(look);
        }

        var ground_a = this.planet.ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](this._lonLat.lon, this._lonLat.lat));
        var v_a = this._v,
            n_a = this._n;

        var lonlat_b = this.planet.ellipsoid.cartesianToLonLat(cartesian);
        var up_b = up || _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].UP;
        var ground_b = this.planet.ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](lonlat_b.lon, lonlat_b.lat, 0));
        var eye_b = cartesian;
        var n_b = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].sub(eye_b, _look);
        var u_b = up_b.cross(n_b);
        n_b.normalize();
        u_b.normalize();
        var v_b = n_b.cross(u_b);

        var an = ground_a.normal();
        var bn = ground_b.normal();
        var anbn = 1.0 - an.dot(bn);
        var hM_a = _math_js__WEBPACK_IMPORTED_MODULE_0__["SQRT_HALF"] * Math.sqrt((anbn) > 0.0 ? anbn : 0.0);

        var maxHeight = 6639613;
        var currMaxHeight = Math.max(this._lonLat.height, lonlat_b.height);
        if (currMaxHeight > maxHeight) {
            maxHeight = currMaxHeight;
        }
        var max_h = currMaxHeight + 2.5 * hM_a * (maxHeight - currMaxHeight);
        var zero = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO;

        //camera path and orientations calculation
        for (var i = 0; i <= this._numFrames; i++) {
            var d = 1 - i / this._numFrames;
            d = d * d * (3 - 2 * d);
            d *= d;

            //Error here
            var g_i = ground_a.smerp(ground_b, d).normalize();
            var ground_i = this.planet.getRayIntersectionEllipsoid(new _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"](zero, g_i));
            var t = 1 - d;
            var height_i = this._lonLat.height * d * d * d + max_h * 3 * d * d * t + max_h * 3 * d * t * t + lonlat_b.height * t * t * t;

            var eye_i = ground_i.addA(g_i.scale(height_i));
            var up_i = v_a.smerp(v_b, d);
            var look_i = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].add(eye_i, n_a.smerp(n_b, d).negateTo());

            var n = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](eye_i.x - look_i.x, eye_i.y - look_i.y, eye_i.z - look_i.z);
            var u = up_i.cross(n);
            n.normalize();
            u.normalize();

            var v = n.cross(u);
            this._framesArr[i] = {
                "eye": eye_i,
                "n": n,
                "u": u,
                "v": v
            };
        }

        this._framesCounter = this._numFrames;
        this._flying = true;
    }

    /**
     * Flies to the geo coordiantes.
     * @public
     * @param {og.LonLat} lonlat - Finish coordinates.
     * @param {og.math.Vector3} [look] - Camera LOOK in the end of flying. Default - (0,0,0)
     * @param {og.math.Vector3} [up] - Camera UP vector in the end of flying. Default - (0,1,0)
     * @param {cameraCallback} [completeCallback] - Callback that calls after flying when flying is finished.
     * @param {cameraCallback} [startCallback] - Callback that calls befor the flying begins.
     */
    flyLonLat(lonlat, look, up, completeCallback, startCallback) {
        var _lonlat = new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](lonlat.lon, lonlat.lat, lonlat.height || this._lonLat.height);
        this.flyCartesian(this.planet.ellipsoid.lonLatToCartesian(_lonlat), look, up, completeCallback, startCallback);
    }

    /**
     * Breaks the flight.
     * @public
     */
    stopFlying() {

        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);

        this._flying = false;
        this._framesArr.length = 0;
        this._framesArr = [];
        this._framesCounter = -1;
    }

    /**
     * Returns camera is flying.
     * @public
     * @returns {boolean}
     */
    isFlying() {
        return this._flying;
    }

    /**
     * Rotates around planet to the left.
     * @public
     * @param {number} angle - Rotation angle.
     * @param {boolean} [spin] - If its true rotates around globe spin.
     */
    rotateLeft(angle, spin) {
        this.rotateHorizontal(angle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], spin ^ true, _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO);
        this.update();
    }

    /**
     * Rotates around planet to the right.
     * @public
     * @param {number} angle - Rotation angle.
     * @param {boolean} [spin] - If its true rotates around globe spin.
     */
    rotateRight(angle, spin) {
        this.rotateHorizontal(-angle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], spin ^ true, _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO);
        this.update();
    }

    /**
     * Rotates around planet to the north pole.
     * @public
     * @param {number} angle - Rotation angle.
     */
    rotateUp(angle) {
        this.rotateVertical(angle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO);
        this.update();
    }

    /**
     * Rotates around planet to the south pole.
     * @public
     * @param {number} angle - Rotation angle.
     */
    rotateDown(angle) {
        this.rotateVertical(-angle * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"].ZERO);
        this.update();
    }

    /**
     * Prepare camera to the frame. Used in render node frame function.
     * @public
     */
    prepareFrame() {
        if (this._flying) {
            var c = this._numFrames - this._framesCounter;

            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);

            this.eye = this._framesArr[c].eye;
            this._u = this._framesArr[c].u;
            this._v = this._framesArr[c].v;
            this._n = this._framesArr[c].n;
            this.update();
            this._framesCounter--;

            if (this._framesCounter < 0) {
                this.stopFlying();
                if (this._completeCallback) {
                    this._completeCallback();
                    this._completeCallback = null;
                }
            }
        } else {
            this._terrainAltitude = this._lonLat.height;
            if (this._lonLat.height < 1000000) {
                this._terrainAltitude = this._insideSegment.getTerrainPoint(this._terrainPoint, this.eye, this._insideSegmentPosition);
                if (this._terrainAltitude < this.minAltitude) {
                    this.setAltitude(this.minAltitude);
                }
            }
        }
    }
};



/***/ }),

/***/ "./src/og/cons.js":
/*!************************!*\
  !*** ./src/og/cons.js ***!
  \************************/
/*! exports provided: Cons, cons */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cons", function() { return Cons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cons", function() { return cons; });


/**
 * Console logging singleton object.
 * @class
 */
class Cons {
    constructor() {
        this._container = document.createElement("div");
        this._container.classList.add("ogConsole");
        this._container.style.display = "none";
        document.body.appendChild(this._container);

        this._visibility = false;
    }

    getVisibility() {
        return this._visibility;
    }

    setVisibility(visibility) {
        if (this._visibility != visibility) {
            this._visibility = visibility;
            if (this._visibility) {
                this.show();
            } else {
                this.hide();
            }
        }
    }

    /**
     * Show console panel.
     * @public
     */
    show() {
        this._container.style.display = "block";
        this._visibility = true;
    }

    /**
     * Hide console panel.
     * @public
     */
    hide() {
        this._container.style.display = "none";
        this._visibility = false;
    }

    /**
     * Adds error text in the console.
     * @public
     * @param {string} str - Error text.
     */
    logErr(str) {
        var d = document.createElement("div");
        d.classList.add("ogConsole-text");
        d.classList.add("ogConsole-error");
        d.innerHTML = "error: " + str;
        this._container.appendChild(d);
        this.show();
    }

    /**
     * Adds warning text in the console.
     * @public
     * @param {string} str - Warning text.
     */
    logWrn(str) {
        var d = document.createElement("div");
        d.classList.add("ogConsole-text");
        d.classList.add("ogConsole-warning");
        d.innerHTML = "warning: " + str;
        this._container.appendChild(d);
        this.show();
    }

    /**
     * Adds log text in the console.
     * @public
     * @param {string} str - Log text.
     * @param {Object} [style] - HTML style.
     */
    log(str, style) {
        var d = document.createElement("div");
        d.classList.add("ogConsole-text");
        if (style) {
            for (var s in style) {
                d.style[s] = style[s];
            }
        }
        d.innerHTML = str;
        this._container.appendChild(d);
        this.show();
    }
}

const cons = new Cons();



/***/ }),

/***/ "./src/og/control/BaseControl.js":
/*!***************************************!*\
  !*** ./src/og/control/BaseControl.js ***!
  \***************************************/
/*! exports provided: BaseControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseControl", function() { return BaseControl; });
/**
 * @module og/control/BaseControl
 */



/**
 * Base control class for implementing renderer controls.
 * All other controls extend from this class.
 * @class
 * @param {Object} [options] - Control activation options:
 * @param {Boolean} [options.autoActivated=true] - If true - calls initialize function after the renderer assigning.
 */
class BaseControl {
    constructor(options) {
        options = options || {};

        /**
         * Control initialized.
         * @protected
         * @type {Boolean}
         */
        this._initialized = false;

        /**
         * Assigned renderer.
         * @public
         * @type {og.Renderer}
         */
        this.renderer = null;

        /**
         * Auto activation flag.
         * @public
         * @type {Boolean}
         */
        this.autoActivate = options.autoActivate != undefined ? options.autoActivate : true;

        /**
         * Control activity.
         * @protected
         * @type {Boolean}
         */
        this._active = false;
    }

    /**
     * Control initialization function have to be overriden.
     * @public
     * @virtual
     */
    oninit() { }

    /**
     * Control renderer assigning function have to be overriden.
     * @public
     * @virtual
     */
    onadd() { }

    /**
     * Control remove function have to be overriden.
     * @public
     * @virtual
     */
    onremove() { }

    /**
     * Control activation function have to be overriden.
     * @public
     * @virtual
     */
    onactivate() { }

    /**
     * Control deactivation function have to be overriden.
     * @public
     * @virtual
     */
    ondeactivate() { }

    /**
     * Assign renderer to the control.
     * @public
     * @type {og.Renderer}
     */
    addTo(renderer) {
        if (renderer) {
            this.renderer = renderer;
            renderer.controls.push(this);
            this.onadd && this.onadd();
            if (this.autoActivate) {
                this.oninit && this.oninit();
                this._initialized = true;
                this._active = true;
            }
        }
    }

    /**
     * Assign renderer to the control.
     * @public
     */
    remove() {
        this.onremove && this.onremove();
        this.renderer = null;
        this._active = false;
        this._initialized = false;
    }

    /**
     * Activate control.
     * @public
     */
    activate() {
        this._active = true;
        this.onactivate && this.onactivate();
    }

    /**
     * Deactivate control.
     * @public
     */
    deactivate() {
        this._active = false;
        this.ondeactivate && this.ondeactivate();
    }

    /**
     * Is control active.
     * @public
     */
    isActive() {
        return this._active;
    }
};



/***/ }),

/***/ "./src/og/control/EarthCoordinates.js":
/*!********************************************!*\
  !*** ./src/og/control/EarthCoordinates.js ***!
  \********************************************/
/*! exports provided: earthCoordinates, EarthCoordinates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "earthCoordinates", function() { return earthCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EarthCoordinates", function() { return EarthCoordinates; });
/* harmony import */ var _BaseControl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseControl.js */ "./src/og/control/BaseControl.js");
/**
 * @module og/control/EarthCoordinates
 */





function dec2deg(base) {
    var t, t2;
    var degrees = base < 0 ? Math.ceil(base) : Math.floor(base);
    var minutes = Math.floor(t = Math.abs((base - degrees)) * 60);
    var seconds = Math.floor(t2 = (t - minutes) * 6000);
    seconds = seconds / 100.00;
    return (numToFixedString(degrees, 3) + "\u00B0" +
        numToFixedString(minutes, 2) + "\u0027" +
        numToFixedString(seconds.toFixed(2), 2) + "\u0022");
};

function numToFixedString(num, fixed) {
    var dl = num.toString().split('.')[0].length;
    var white = "&nbsp;";
    for (var i = dl; i < fixed; i++) {
        white += '&nbsp;&nbsp;';
    }
    return white + num.toString();
};

function toDecimal(ll) {
    return ll.lat.toFixed(5) + ", " + ll.lon.toFixed(5);
};

function toDegrees(ll) {
    return dec2deg(ll.lat) + ", " + dec2deg(ll.lon);
};

function toMercator(ll) {
    var m = ll.forwardMercator();
    return m.lat.toFixed(5) + ", " + m.lon.toFixed(5);
};

const DisplayTypesConverters = [
    toDecimal,
    toDegrees,
    toMercator
];

/**
 * Control displays mouse or screen center Earth coordinates.
 * @class
 * @extends {og.control.BaseControl}
 * @param {Object} [options] - Options:
 * @param {Boolean} [options.center] - Earth coordiantes by screen center otherwise mouse pointer. False is default.
 * @param {Boolean} [options.type] - Coordinates shown: 0 - is decimal degrees, 1 - degrees, 2 - mercator geodetic coordinates.
 */
class EarthCoordinates extends _BaseControl_js__WEBPACK_IMPORTED_MODULE_0__["BaseControl"] {
    constructor(options) {
        super(options);

        options = options || {};

        /**
         * Display type.
         * @private
         * @type {Boolean}
         */
        this._displayType = options.type || 0;

        /**
         * Current coordinates type converter.
         * @private
         * @function
         */
        this._converter = DisplayTypesConverters[0];

        /**
         * Display dom element.
         * @private
         * @type {Object}
         */
        this._display = null;

        /**
         * Screen center or mouse pointer coordinates show flag.
         * @private
         * @type {Boolean}
         */

        var pad = false;
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            pad = true;
        }

        this._center = options.center || pad;

        /**
         * Current position.
         * @public
         * @type {og.math.Vector3}
         */
        this.position = null;
    }

    oninit() {
        this._display = document.createElement('div');
        this._display.className = 'ogEarthCoordinatesControl';
        var that = this;

        function _refresh(el) {
            if (that._displayType >= DisplayTypesConverters.length)
                that._displayType = 0;
            if (that._displayType == 0) {
                el.style.width = "275px";
            } else if (that._displayType == 1) {
                el.style.width = "355px";
            } else if (that._displayType == 2) {
                el.style.width = "350px";
            }
            that._converter = DisplayTypesConverters[that._displayType];
            that._showPosition();
        };

        this._display.onclick = function (e) {
            that._displayType += 1;
            _refresh(this);
        };

        this.renderer.div.appendChild(this._display);

        _refresh(this._display);

        let centerDiv = document.createElement('div');
        centerDiv.className = 'ogCenterIcon';
        centerDiv.innerHTML = '<svg width="12" height="12"><g><path stroke-width="1" stroke-opacity="1" d="M6 0L6 12M0 6L12 6" stroke="#009DFF"></path></g></svg>';
        this.renderer.div.appendChild(centerDiv);

        if (this._center) {
            this.renderer.activeCamera.events.on("moveend", this._grabCoordinates, this);
            centerDiv.style.display = "block";
        } else {
            this.renderer.events.on("mousemove", this._onMouseMove, this);
            centerDiv.style.display = "none";
        }

    }

    /**
     * Sets coordinates capturing type.
     * @public
     * @param {Boolean} center - True - capture screen center, false - mouse pointer.
     */
    setCenter(center) {
        if (center != this._center) {
            this._center = center;
            if (center) {
                this.renderer.events.off("mousemove", this._onMouseMove);
                this.renderer.activeCamera.events.on("moveend", this._grabCoordinates, this);
                centerDiv.style.display = "block";
            } else {
                this.renderer.events.off("draw", this._draw);
                this.renderer.events.on("mousemove", this._onMouseMove, this);
                centerDiv.style.display = "none";
            }
        }
    }

    _showPosition() {
        if (this.position) {
            this.position.height = ((this.position.height > 10000 || this.position.height < -10000) ? 0 : this.position.height);
            this._display.innerHTML = "Lat/Lon: " + this._converter(this.position) + " h(km): " + (this.position.height > 0 ? "~" + (Math.round(this.position.height) / 1000).toFixed(2) : "-");
        } else {
            this._display.innerHTML = "Lat/Lon: " + "_____________________";
        }
    }

    _grabCoordinates() {
        var r = this.renderer;
        var ts = r.events.touchState;
        this.position = this.planet.getLonLatFromPixelTerrain(r.handler.getCenter());
        this._showPosition();
    }

    _onMouseMove() {
        var r = this.renderer;
        var ms = r.events.mouseState;
        if (!(ms.leftButtonDown || ms.rightButtonDown) &&
            r.controlsBag.scaleRot <= 0 &&
            !r.activeCamera._flying) {
            this.position = this.planet.getLonLatFromPixelTerrain(ms, true);
            this._showPosition();
        }
    }
};

function earthCoordinates(options) {
    return new EarthCoordinates(options);
};




/***/ }),

/***/ "./src/og/control/MouseNavigation.js":
/*!*******************************************!*\
  !*** ./src/og/control/MouseNavigation.js ***!
  \*******************************************/
/*! exports provided: MouseNavigation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseNavigation", function() { return MouseNavigation; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _BaseControl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseControl.js */ "./src/og/control/BaseControl.js");
/* harmony import */ var _input_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../input/input.js */ "./src/og/input/input.js");
/* harmony import */ var _Lock_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Lock.js */ "./src/og/Lock.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Mat4.js */ "./src/og/math/Mat4.js");
/* harmony import */ var _math_Quat_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Quat.js */ "./src/og/math/Quat.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Ray.js */ "./src/og/math/Ray.js");
/* harmony import */ var _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../bv/Sphere.js */ "./src/og/bv/Sphere.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/control/MouseNavigation
 */















/**
 * Mouse planet camera dragging control.
 * @class
 * @extends {og.control.BaseControl}
 * @param {Object} [options] - Control options.
 */
class MouseNavigation extends _BaseControl_js__WEBPACK_IMPORTED_MODULE_1__["BaseControl"] {
    constructor(options) {
        super(options);

        options = options || {};

        this.grabbedPoint = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
        this._eye0 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
        this.pointOnEarth = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
        this.earthUp = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
        this.inertia = 0.007;
        this.grabbedSpheroid = new _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_8__["Sphere"]();
        this.planet = null;
        this.qRot = new _math_Quat_js__WEBPACK_IMPORTED_MODULE_6__["Quat"]();
        this.scaleRot = 0;

        this.distDiff = 0.33;
        this.stepsCount = 5;
        this.stepsForward = null;
        this.stepIndex = 0;

        this._keyLock = new _Lock_js__WEBPACK_IMPORTED_MODULE_3__["Key"]();
    }

    static getMovePointsFromPixelTerrain(cam, planet, stepsCount, delta, point, forward, dir) {

        var steps = []

        var eye = cam.eye.clone(),
            n = cam._n.clone(),
            u = cam._u.clone(),
            v = cam._v.clone();

        var a = planet.getCartesianFromPixelTerrain(point, true);

        if (!dir) {
            dir = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"].sub(a, cam.eye).normalize();
        }

        var d = a ? delta * cam.eye.distance(a) / stepsCount : 1000;

        if (forward) {
            d = -d;
        } else {
            d *= 2;
        }

        var scaled_n = n.scaleTo(d);

        if (a && cam._lonLat.height > 9000 && cam.slope > 0.6) {
            var grabbedSpheroid = new _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_8__["Sphere"]();
            grabbedSpheroid.radius = a.length();

            var rotArr = [],
                eyeArr = []

            var breaked = false;
            for (var i = 0; i < stepsCount; i++) {
                eye.addA(scaled_n);
                var b = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"](eye, dir).hitSphere(grabbedSpheroid);
                eyeArr[i] = eye.clone();
                if (b) {
                    rotArr[i] = new _math_Mat4_js__WEBPACK_IMPORTED_MODULE_5__["Mat4"]().rotateBetweenVectors(a.normal(), b.normal());
                } else {
                    breaked = true;
                    break;
                }
            }

            if (!breaked) {
                for (var i = 0; i < stepsCount; i++) {
                    var rot = rotArr[i];
                    steps[i] = {};
                    steps[i].eye = rot.mulVec3(eyeArr[i]);
                    steps[i].v = rot.mulVec3(v);
                    steps[i].u = rot.mulVec3(u);
                    steps[i].n = rot.mulVec3(n);
                }
            } else {
                eye = cam.eye.clone();
                for (var i = 0; i < stepsCount; i++) {
                    steps[i] = {};
                    steps[i].eye = eye.addA(scaled_n).clone();
                    steps[i].v = v;
                    steps[i].u = u;
                    steps[i].n = n;
                }
            }
        } else {
            for (var i = 0; i < stepsCount; i++) {
                steps[i] = {};
                steps[i].eye = eye.addA(dir.scaleTo(-d)).clone();
                steps[i].v = v;
                steps[i].u = u;
                steps[i].n = n;
            }
        }

        return steps;
    }

    onactivate() {
        this.renderer.events.on("mousewheel", this.onMouseWheel, this);
        this.renderer.events.on("lhold", this.onMouseLeftButtonDown, this);
        this.renderer.events.on("rhold", this.onMouseRightButtonDown, this);
        this.renderer.events.on("ldown", this.onMouseLeftButtonClick, this);
        this.renderer.events.on("lup", this.onMouseLeftButtonUp, this);
        this.renderer.events.on("rdown", this.onMouseRightButtonClick, this);
        this.renderer.events.on("ldblclick", this.onMouseLeftButtonDoubleClick, this);
        this.renderer.events.on("draw", this.onDraw, this);
    }

    ondeactivate() {
        this.renderer.events.off("mousewheel", this.onMouseWheel);
        this.renderer.events.off("lhold", this.onMouseLeftButtonDown);
        this.renderer.events.off("rhold", this.onMouseRightButtonDown);
        this.renderer.events.off("ldown", this.onMouseLeftButtonClick);
        this.renderer.events.off("lup", this.onMouseLeftButtonUp);
        this.renderer.events.off("rdown", this.onMouseRightButtonClick);
        this.renderer.events.off("ldblclick", this.onMouseLeftButtonDoubleClick);
        this.renderer.events.off("draw", this.onDraw);
    };

    onMouseWheel(event) {

        if (this.stepIndex)
            return;

        this.planet.stopFlying();

        this.stopRotation();

        this._deactivate = true;

        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);

        var ms = this.renderer.events.mouseState;
        this.stepIndex = this.stepsCount;
        this.stepsForward = MouseNavigation.getMovePointsFromPixelTerrain(this.renderer.activeCamera,
            this.planet, this.stepsCount, this.distDiff, ms, event.wheelDelta > 0, ms.direction);
    }

    oninit() {
        this.activate();
    }

    onMouseLeftButtonDoubleClick() {
        this.planet.stopFlying();
        this.stopRotation();
        var p = this.planet.getCartesianFromPixelTerrain(this.renderer.events.mouseState, true),
            g = this.planet.ellipsoid.cartesianToLonLat(p);
        if (this.renderer.events.isKeyPressed(_input_input_js__WEBPACK_IMPORTED_MODULE_2__["input"].KEY_SHIFT)) {
            this.planet.flyLonLat(new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](g.lon, g.lat, this.renderer.activeCamera.eye.distance(p) * 2.0));
        } else {
            this.planet.flyLonLat(new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](g.lon, g.lat, this.renderer.activeCamera.eye.distance(p) * 0.57));
        }
    }

    onMouseLeftButtonClick() {
        if (this._active) {
            this.renderer.handler.canvas.classList.add("ogGrabbingPoiner");
            this.grabbedPoint = this.planet.getCartesianFromMouseTerrain(true);
            if (this.grabbedPoint) {
                this._eye0.copy(this.renderer.activeCamera.eye);
                this.grabbedSpheroid.radius = this.grabbedPoint.length();
                this.stopRotation();
            }
        }
    }

    stopRotation() {
        this.qRot.clear();
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }

    onMouseLeftButtonUp(e) {
        this.renderer.handler.canvas.classList.remove("ogGrabbingPoiner");
    }

    onMouseLeftButtonDown(e) {
        if (this._active) {
            if (!this.grabbedPoint)
                return;

            this.planet.stopFlying();

            if (this.renderer.events.mouseState.moving) {

                var cam = this.renderer.activeCamera;

                if (cam.slope > 0.28) {
                    var targetPoint = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"](cam.eye, e.direction).hitSphere(this.grabbedSpheroid);
                    if (targetPoint) {
                        this.scaleRot = 1;
                        this.qRot = _math_Quat_js__WEBPACK_IMPORTED_MODULE_6__["Quat"].getRotationBetweenVectors(targetPoint.normal(), this.grabbedPoint.normal());
                        var rot = this.qRot;
                        cam.eye = rot.mulVec3(cam.eye);
                        cam._v = rot.mulVec3(cam._v);
                        cam._u = rot.mulVec3(cam._u);
                        cam._n = rot.mulVec3(cam._n);
                        cam.update();
                    }
                } else {
                    var p0 = this.grabbedPoint,
                        p1 = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"].add(p0, cam._u),
                        p2 = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"].add(p0, p0.normal());

                    var px = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
                    if (new _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"](cam.eye, e.direction).hitPlane(p0, p1, p2, px) === _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"].INSIDE) {
                        cam.eye = this._eye0.addA(px.subA(p0).negate());
                        cam.update();
                    }
                }
            } else {
                this.scaleRot = 0;
            }
        }
    }

    onMouseRightButtonClick(e) {
        this.stopRotation();
        this.planet.stopFlying();
        this.pointOnEarth = this.planet.getCartesianFromPixelTerrain({ x: e.x, y: e.y }, true);
        if (this.pointOnEarth) {
            this.earthUp = this.pointOnEarth.normal();
        }
    };

    onMouseRightButtonDown(e) {
        var cam = this.renderer.activeCamera;
        if (this.pointOnEarth && this.renderer.events.mouseState.moving) {
            this.renderer.controlsBag.scaleRot = 1;
            var l = 0.5 / cam.eye.distance(this.pointOnEarth) * cam._lonLat.height * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
            if (l > 0.007) l = 0.007;
            cam.rotateHorizontal(l * (e.x - e.prev_x), false, this.pointOnEarth, this.earthUp);
            cam.rotateVertical(l * (e.y - e.prev_y), this.pointOnEarth);
            cam.update();
        }
    }

    onDraw(e) {

        if (this._active) {

            var r = this.renderer;
            var cam = r.activeCamera;
            var prevEye = cam.eye.clone();

            if (this.stepIndex) {
                r.controlsBag.scaleRot = 1;
                var sf = this.stepsForward[this.stepsCount - this.stepIndex--];
                cam.eye = sf.eye;
                cam._v = sf.v;
                cam._u = sf.u;
                cam._n = sf.n;
                cam.update();
            } else {
                if (this._deactivate) {
                    this._deactivate = false;

                    this.planet.layerLock.free(this._keyLock);
                    this.planet.terrainLock.free(this._keyLock);
                    this.planet._normalMapCreator.free(this._keyLock);
                }
            }

            if (r.events.mouseState.leftButtonDown || !this.scaleRot)
                return;

            this.scaleRot -= this.inertia;
            if (this.scaleRot <= 0) {
                this.scaleRot = 0;
            } else {
                r.controlsBag.scaleRot = this.scaleRot;
                var rot = this.qRot.slerp(_math_Quat_js__WEBPACK_IMPORTED_MODULE_6__["Quat"].IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
                if (!(rot.x || rot.y || rot.z)) {
                    this.scaleRot = 0;
                }
                cam.eye = rot.mulVec3(cam.eye);
                cam._v = rot.mulVec3(cam._v);
                cam._u = rot.mulVec3(cam._u);
                cam._n = rot.mulVec3(cam._n);
                cam.update();
            }

            if (cam.eye.distance(prevEye) / cam._terrainAltitude > 0.01) {
                this.planet.layerLock.lock(this._keyLock);
                this.planet.terrainLock.lock(this._keyLock);
                this.planet._normalMapCreator.lock(this._keyLock);
            } else {
                this.planet.layerLock.free(this._keyLock);
                this.planet.terrainLock.free(this._keyLock);
                this.planet._normalMapCreator.free(this._keyLock);
            }
        }
    }
};



/***/ }),

/***/ "./src/og/control/Sun.js":
/*!*******************************!*\
  !*** ./src/og/control/Sun.js ***!
  \*******************************/
/*! exports provided: sun, Sun */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sun", function() { return sun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sun", function() { return Sun; });
/* harmony import */ var _BaseControl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseControl.js */ "./src/og/control/BaseControl.js");
/* harmony import */ var _astro_earth_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../astro/earth.js */ "./src/og/astro/earth.js");
/* harmony import */ var _input_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../input/input.js */ "./src/og/input/input.js");
/* harmony import */ var _light_LightSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../light/LightSource.js */ "./src/og/light/LightSource.js");
/* harmony import */ var _math_Quat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Quat.js */ "./src/og/math/Quat.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/control/Sun
 */










/**
 * Real Sun geocentric position control that place the Sun on the right place by the Earth.
 * @class
 * @extends {og.control.BaseControl}
 * @param {Object} [options] - Control options.
 */
class Sun extends _BaseControl_js__WEBPACK_IMPORTED_MODULE_0__["BaseControl"] {
    constructor(options) {
        super(options);

        options = options || {};

        /**
         * Earth planet node.
         * @public
         * @type {og.scene.Planet}
         */
        this.planet = null;

        /**
         * Sunlight position placed in the camera eye.
         * @private
         * @type {boolean}
         */
        //this._isCameraSunlight = false;

        this.offsetVertical = options.offsetVertical || -5000000;

        this.offsetHorizontal = options.offsetHorizontal || 5000000;

        /**
         * Light source.
         * @public
         * @type {og.LightSource}
         */
        this.sunlight = null;

        /**
         * Current frame handler clock date and time.
         * @private
         * @type {Number}
         */
        this._currDate = 0;

        /**
         * Previous frame handler clock date and time.
         * @private
         * @type {Number}
         */
        this._prevDate = 0;

        this._clockPtr = null;

        this._lightOn = false;

        this._stopped = options.stopped || false;
    }

    oninit() {

        this.planet.lightEnabled = true;

        //sunlight initialization
        this.sunlight = new _light_LightSource_js__WEBPACK_IMPORTED_MODULE_3__["LightSource"]("Sun", {
            'ambient': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"](0.15, 0.15, 0.25),
            'diffuse': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"](0.9, 0.9, 0.8),
            'specular': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"](0.1, 0.1, 0.06),
            'shininess': 110
        });
        this.sunlight.addTo(this.planet);

        var that = this;
        this.renderer.events.on("draw", this._draw, this);

        this.renderer.events.on("charkeypress", _input_input_js__WEBPACK_IMPORTED_MODULE_2__["input"].KEY_L, function () {
            that.planet.lightEnabled = !that.planet.lightEnabled;
        });

        if (!this._clockPtr)
            this._clockPtr = this.renderer.handler.defaultClock;
    }

    stop() {
        this._stopped = true;
    }

    onactivate() {
        this._stopped = false;
    }

    bindClock(clock) {
        this._clockPtr = clock;
    }

    _draw() {
        if (!this._stopped) {
            this._currDate = this._clockPtr.currentDate;
            var cam = this.renderer.activeCamera;
            if (cam.getHeight() < 4650000 || !this._active) {
                this._lightOn = true;
                this._f = 1;
                var n = cam.eye.normal();
                var tu = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"].proj_b_to_plane(cam._v, n, cam._v).normalize().scale(this.offsetVertical);
                var tr = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"].proj_b_to_plane(cam._u, n, cam._u).normalize().scale(this.offsetHorizontal);
                var d = tu.add(tr);
                var pos = cam.eye.add(d);
                if (this._k > 0) {
                    this._k -= 0.01;
                    var rot = _math_Quat_js__WEBPACK_IMPORTED_MODULE_4__["Quat"].getRotationBetweenVectors(this.sunlight._position.normal(), pos.normal());
                    var r = rot.slerp(_math_Quat_js__WEBPACK_IMPORTED_MODULE_4__["Quat"].IDENTITY, this._k).normalize();
                    this.sunlight.setPosition(r.mulVec3(this.sunlight._position));
                } else {
                    this.sunlight.setPosition(pos);
                }
            } else {
                this._k = 1;
                if (this._f > 0) {
                    this._f -= 0.01;
                    var rot = _math_Quat_js__WEBPACK_IMPORTED_MODULE_4__["Quat"].getRotationBetweenVectors(this.sunlight._position.normal(), Object(_astro_earth_js__WEBPACK_IMPORTED_MODULE_1__["getSunPosition"])(this._currDate).normal());
                    var r = rot.slerp(_math_Quat_js__WEBPACK_IMPORTED_MODULE_4__["Quat"].IDENTITY, this._f).normalize();
                    this.sunlight.setPosition(r.mulVec3(this.sunlight._position));
                } else {
                    if (Math.abs(this._currDate - this._prevDate) > 0.00034 && this._active || this._lightOn) {
                        this._lightOn = false;
                        this._prevDate = this._currDate;
                        this.sunlight.setPosition(Object(_astro_earth_js__WEBPACK_IMPORTED_MODULE_1__["getSunPosition"])(this._currDate));
                        this._f = 0;
                    }
                }
            }
        }
    }
};

function sun(options) {
    return Sun(options);
};





/***/ }),

/***/ "./src/og/control/TouchNavigation.js":
/*!*******************************************!*\
  !*** ./src/og/control/TouchNavigation.js ***!
  \*******************************************/
/*! exports provided: TouchNavigation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchNavigation", function() { return TouchNavigation; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _BaseControl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseControl.js */ "./src/og/control/BaseControl.js");
/* harmony import */ var _input_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../input/input.js */ "./src/og/input/input.js");
/* harmony import */ var _Lock_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Lock.js */ "./src/og/Lock.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _math_Mat4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Mat4.js */ "./src/og/math/Mat4.js");
/* harmony import */ var _math_Quat_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Quat.js */ "./src/og/math/Quat.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Ray.js */ "./src/og/math/Ray.js");
/* harmony import */ var _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../bv/Sphere.js */ "./src/og/bv/Sphere.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/control/TouchNavigation
 */















/**
 * Touch pad planet camera dragging control.
 * @class
 * @extends {og.control.BaseControl}
 * @param {Object} [options] - Control options.
 */
class TouchNavigation extends _BaseControl_js__WEBPACK_IMPORTED_MODULE_1__["BaseControl"] {
    constructor(options) {
        super(options);

        this.grabbedPoint = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
        this.inertia = 0.007;
        this.grabbedSpheroid = new _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_8__["Sphere"]();
        this.planet = null;
        this.qRot = new _math_Quat_js__WEBPACK_IMPORTED_MODULE_6__["Quat"]();
        this.scaleRot = 0;
        this.rot = 1;
        this._eye0 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();

        this.stepsCount = 5;
        this.stepsForward = null;
        this.stepIndex = 0;

        var Touch = function () {
            this.x = 0;
            this.y = 0;
            this.prev_x = 0;
            this.prev_y = 0;
            this.grabbedPoint = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
            this.grabbedSpheroid = new _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_8__["Sphere"]();
            this.dX = function () { return this.x - this.prev_x; };
            this.dY = function () { return this.y - this.prev_y; };
        };

        this.pointOnEarth = null;
        this.earthUp = null;

        this.touches = [new Touch(), new Touch()];

        this._keyLock = new _Lock_js__WEBPACK_IMPORTED_MODULE_3__["Key"]();
    }

    oninit() {
        this.renderer.events.on("touchstart", this.onTouchStart, this);
        this.renderer.events.on("touchend", this.onTouchEnd, this);
        this.renderer.events.on("doubletouch", this.onDoubleTouch, this);
        this.renderer.events.on("touchcancel", this.onTouchCancel, this);
        this.renderer.events.on("touchmove", this.onTouchMove, this);
        this.renderer.events.on("draw", this.onDraw, this);
    }

    onTouchStart(e) {

        this._touching = true;

        if (e.sys.touches.length === 2) {

            var t0 = this.touches[0],
                t1 = this.touches[1];

            t0.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
            t0.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;
            t0.prev_x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
            t0.prev_y = e.sys.touches.item(0).clientY - e.sys.offsetTop;
            t0.grabbedPoint = this.planet.getCartesianFromPixelTerrain(t0, true);

            t1.x = e.sys.touches.item(1).clientX - e.sys.offsetLeft;
            t1.y = e.sys.touches.item(1).clientY - e.sys.offsetTop;
            t1.prev_x = e.sys.touches.item(1).clientX - e.sys.offsetLeft;
            t1.prev_y = e.sys.touches.item(1).clientY - e.sys.offsetTop;
            t1.grabbedPoint = this.planet.getCartesianFromPixelTerrain(t1, true);

            //this.planet._viewChanged = true;
            this.pointOnEarth = this.planet.getCartesianFromPixelTerrain(this.renderer.handler.getCenter(), true);

            if (this.pointOnEarth) {
                this.earthUp = this.pointOnEarth.normal();
            }

            if (t0.grabbedPoint && t1.grabbedPoint) {
                t0.grabbedSpheroid.radius = t0.grabbedPoint.length();
                t1.grabbedSpheroid.radius = t1.grabbedPoint.length();
                this.stopRotation();
            }

        } else if (e.sys.touches.length === 1) {
            this._startTouchOne(e);
        }
    }

    _startTouchOne(e) {
        var t = this.touches[0];

        t.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
        t.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;
        t.prev_x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
        t.prev_y = e.sys.touches.item(0).clientY - e.sys.offsetTop;

        t.grabbedPoint = this.planet.getCartesianFromPixelTerrain(t, true);
        this._eye0.copy(this.renderer.activeCamera.eye);

        if (t.grabbedPoint) {
            t.grabbedSpheroid.radius = t.grabbedPoint.length();
            this.stopRotation();
        }
    }

    stopRotation() {
        this.qRot.clear();
        this.planet.layerLock.free(this._keyLock);
        this.planet.terrainLock.free(this._keyLock);
        this.planet._normalMapCreator.free(this._keyLock);
    }

    onDoubleTouch(e) {
        if (this.stepIndex)
            return;

        this.planet.stopFlying();
        this.stopRotation();
        var p = this.planet.getCartesianFromPixelTerrain(this.touches[0], true),
            g = this.planet.ellipsoid.cartesianToLonLat(p);
        this.planet.flyLonLat(new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](g.lon, g.lat, this.renderer.activeCamera.eye.distance(p) * 0.57));
    }

    onTouchEnd(e) {

        if (e.sys.touches.length === 0)
            this._touching = false;

        if (e.sys.touches.length === 1) {
            this._startTouchOne(e);
        }

        if (Math.abs(this.touches[0].x - this.touches[0].prev_x) < 3 &&
            Math.abs(this.touches[0].y - this.touches[0].prev_y) < 3)
            this.scaleRot = 0;
    }

    onTouchCancel(e) {
    }

    onTouchMove(e) {

        var cam = this.renderer.activeCamera;

        if (e.sys.touches.length === 2) {

            this.renderer.controlsBag.scaleRot = 1;

            var t0 = this.touches[0],
                t1 = this.touches[1];

            if (!t0.grabbedPoint || !t1.grabbedPoint)
                return;

            this.planet.stopFlying();

            t0.prev_x = t0.x;
            t0.prev_y = t0.y;
            t0.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
            t0.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;

            t1.prev_x = t1.x;
            t1.prev_y = t1.y;
            t1.x = e.sys.touches.item(1).clientX - e.sys.offsetLeft;
            t1.y = e.sys.touches.item(1).clientY - e.sys.offsetTop;

            //var center_x = Math.round(t0.x + (t1.x - t0.x) * 0.5);
            //var center_y = Math.round(t0.y + (t1.y - t0.y) * 0.5);

            //var dirC = cam.unproject(center_x, center_y);
            //var targetPointC = this.planet.getCartesianFromPixelTerrain(new og.math.Pixel(center_x, center_y));

            //var dir0 = cam.unproject(t0.x, t0.y);
            //var targetPoint0 = new og.math.Ray(cam.eye, dir0).hitSphere(t0.grabbedSpheroid);

            //var dir1 = cam.unproject(t1.x, t1.y);
            //var targetPoint1 = new og.math.Ray(cam.eye, dir1).hitSphere(t1.grabbedSpheroid);

            //print2d("t1", center_x + "," + center_y, 100, 100);
            //print2d("t2", targetPointC.x + "," + targetPointC.y + "," + targetPointC.z, 100, 120);

            if (t0.dY() > 0 && t1.dY() > 0 || t0.dY() < 0 && t1.dY() < 0 ||
                t0.dX() > 0 && t1.dX() > 0 || t0.dX() < 0 && t1.dX() < 0) {
                var l = 0.5 / cam.eye.distance(this.pointOnEarth) * cam._lonLat.height * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
                if (l > 0.007) l = 0.007;
                cam.rotateHorizontal(l * t0.dX(), false, this.pointOnEarth, this.earthUp);
                cam.rotateVertical(l * t0.dY(), this.pointOnEarth);
                cam.update();
            }

            this.scaleRot = 0;

        } else if (e.sys.touches.length === 1) {

            var t = this.touches[0];

            t.prev_x = t.x;
            t.prev_y = t.y;
            t.x = e.sys.touches.item(0).clientX - e.sys.offsetLeft;
            t.y = e.sys.touches.item(0).clientY - e.sys.offsetTop;

            if (!t.grabbedPoint)
                return;

            this.planet.stopFlying();

            var direction = cam.unproject(t.x, t.y);
            var targetPoint = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"](cam.eye, direction).hitSphere(t.grabbedSpheroid);

            if (targetPoint) {
                if (cam._n.dot(cam.eye.normal()) > 0.28) {
                    this.qRot = _math_Quat_js__WEBPACK_IMPORTED_MODULE_6__["Quat"].getRotationBetweenVectors(targetPoint.normal(), t.grabbedPoint.normal());
                    var rot = this.qRot;
                    cam.eye = rot.mulVec3(cam.eye);
                    cam._v = rot.mulVec3(cam._v);
                    cam._u = rot.mulVec3(cam._u);
                    cam._n = rot.mulVec3(cam._n);
                    cam.update();
                    this.scaleRot = 1;
                } else {
                    var p0 = t.grabbedPoint,
                        p1 = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"].add(p0, cam._u),
                        p2 = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"].add(p0, p0.normal());
                    var dir = cam.unproject(t.x, t.y);
                    var px = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"]();
                    if (new _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"](cam.eye, dir).hitPlane(p0, p1, p2, px) === _math_Ray_js__WEBPACK_IMPORTED_MODULE_7__["Ray"].INSIDE) {
                        cam.eye = this._eye0.addA(px.subA(p0).negate());
                        cam.update();
                        this.scaleRot = 0;
                    }
                }
            }
        }
    };

    onDraw(e) {

        this.renderer.controlsBag.scaleRot = this.scaleRot;

        if (this._touching)
            return;

        var r = this.renderer;
        var cam = r.activeCamera;
        var prevEye = cam.eye.clone();

        if (this.stepIndex) {
            r.controlsBag.scaleRot = 1;
            var sf = this.stepsForward[this.stepsCount - this.stepIndex--];
            var cam = this.renderer.activeCamera;
            cam.eye = sf.eye;
            cam._v = sf.v;
            cam._u = sf.u;
            cam._n = sf.n;
            cam.update();
        }

        if (r.events.mouseState.leftButtonDown || !this.scaleRot)
            return;

        this.scaleRot -= this.inertia;
        if (this.scaleRot <= 0)
            this.scaleRot = 0;
        else {
            r.controlsBag.scaleRot = this.scaleRot;
            var cam = r.activeCamera;
            var rot = this.qRot.slerp(_math_Quat_js__WEBPACK_IMPORTED_MODULE_6__["Quat"].IDENTITY, 1 - this.scaleRot * this.scaleRot * this.scaleRot).normalize();
            if (!(rot.x || rot.y || rot.z)) {
                this.scaleRot = 0;
            }
            cam.eye = rot.mulVec3(cam.eye);
            cam._v = rot.mulVec3(cam._v);
            cam._u = rot.mulVec3(cam._u);
            cam._n = rot.mulVec3(cam._n);
            cam.update();
        }

        if (cam.eye.distance(prevEye) / cam._terrainAltitude > 0.01) {
            this.planet.layerLock.lock(this._keyLock);
            this.planet.terrainLock.lock(this._keyLock);
            this.planet._normalMapCreator.lock(this._keyLock);
        } else {
            this.planet.layerLock.free(this._keyLock);
            this.planet.terrainLock.free(this._keyLock);
            this.planet._normalMapCreator.free(this._keyLock);
        }
    }
};



/***/ }),

/***/ "./src/og/control/ZoomControl.js":
/*!***************************************!*\
  !*** ./src/og/control/ZoomControl.js ***!
  \***************************************/
/*! exports provided: zoomControl, ZoomControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomControl", function() { return zoomControl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomControl", function() { return ZoomControl; });
/* harmony import */ var _BaseControl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseControl.js */ "./src/og/control/BaseControl.js");
/* harmony import */ var _Lock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lock.js */ "./src/og/Lock.js");
/* harmony import */ var _MouseNavigation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MouseNavigation.js */ "./src/og/control/MouseNavigation.js");
/**
 * @module og/control/ZoomControl
 */








/**
 * Planet zoom buttons control.
 * @class
 * @extends {og.control.BaseControl}
 * @params {Object} [options] - Control options.
 */
class ZoomControl extends _BaseControl_js__WEBPACK_IMPORTED_MODULE_0__["BaseControl"] {
    constructor(options) {
        super(options);

        options = options || {};

        this.distDiff = 0.33;
        this.stepsCount = 5;
        this.stepsForward = null;
        this.stepIndex = 0;
        this._keyLock = new _Lock_js__WEBPACK_IMPORTED_MODULE_1__["Key"]();

        this.planet = null;
    }

    oninit() {
        var zoomDiv = document.createElement('div'),
            btnZoomIn = document.createElement('button'),
            btnZoomOut = document.createElement('button');

        zoomDiv.className = 'ogZoomControl';
        btnZoomIn.className = 'ogZoomButton ogZoomIn';
        btnZoomOut.className = 'ogZoomButton ogZoomOut';

        zoomDiv.appendChild(btnZoomIn);
        zoomDiv.appendChild(btnZoomOut);

        this.renderer.div.appendChild(zoomDiv);

        var that = this;
        btnZoomIn.onclick = function (e) {
            that.zoomIn();
        };

        btnZoomOut.onclick = function (e) {
            that.zoomOut();
        };

        this.renderer.events.on("draw", this._draw, this);
    }

    /** 
     * Planet zoom in.
     * @public
     */
    zoomIn() {

        this._deactivate = true;

        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);

        this.stepIndex = this.stepsCount;
        this.stepsForward = _MouseNavigation_js__WEBPACK_IMPORTED_MODULE_2__["MouseNavigation"].getMovePointsFromPixelTerrain(this.renderer.activeCamera,
            this.planet, this.stepsCount, this.distDiff * 1.7, this.renderer.getCenter(), true, this.renderer.activeCamera._n.negateTo());
    }

    /** 
     * Planet zoom out.
     * @public
     */
    zoomOut() {

        this._deactivate = true;

        this.planet.layerLock.lock(this._keyLock);
        this.planet.terrainLock.lock(this._keyLock);
        this.planet._normalMapCreator.lock(this._keyLock);

        this.stepIndex = this.stepsCount;
        this.stepsForward = _MouseNavigation_js__WEBPACK_IMPORTED_MODULE_2__["MouseNavigation"].getMovePointsFromPixelTerrain(this.renderer.activeCamera,
            this.planet, this.stepsCount, this.distDiff * 2, this.renderer.getCenter(), false, this.renderer.activeCamera._n.negateTo());
    }

    _draw(e) {

        var cam = this.renderer.activeCamera;

        if (this.stepIndex) {
            var sf = this.stepsForward[this.stepsCount - this.stepIndex--];
            cam.eye = sf.eye;
            cam._v = sf.v;
            cam._u = sf.u;
            cam._n = sf.n;
            cam.update();
        } else if (!cam._flying) {
            if (this._deactivate) {

                this.planet.layerLock.free(this._keyLock);
                this.planet.terrainLock.free(this._keyLock);
                this.planet._normalMapCreator.free(this._keyLock);

                this._deactivate = false;
            }
        }
    }
};


function zoomControl(options) {
    return new ZoomControl(options);
};




/***/ }),

/***/ "./src/og/ellipsoid/Ellipsoid.js":
/*!***************************************!*\
  !*** ./src/og/ellipsoid/Ellipsoid.js ***!
  \***************************************/
/*! exports provided: Ellipsoid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ellipsoid", function() { return Ellipsoid; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/**
 * @module og/ellipsoid/Ellipsoid
 */







/**
 * Class represents a plant ellipsoid.
 * @class
 * @param {number} equatorialSize - Equatorial ellipsoid size.
 * @param {number} polarSize - Polar ellipsoid size.
 */
class Ellipsoid {
    constructor(equatorialSize, polarSize) {
        this._a = equatorialSize;
        this._b = polarSize;
        this._flattening = equatorialSize / polarSize;

        this._a2 = equatorialSize * equatorialSize;
        this._b2 = polarSize * polarSize;

        var qa2b2 = Math.sqrt(this._a2 - this._b2);

        this._e = qa2b2 / equatorialSize;
        this._e2 = this._e * this._e;
        this._e22 = this._e2 * this._e2;

        this._k = qa2b2 / polarSize;
        this._k2 = this._k * this._k;

        this._radii = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](equatorialSize, polarSize, equatorialSize);
        this._radii2 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](this._a2, this._b2, this._a2);
        this._invRadii = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](1 / equatorialSize, 1 / polarSize, 1 / equatorialSize);
        this._invRadii2 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](1 / this._a2, 1 / this._b2, 1 / this._a2);
    }


    /**
     * Gets ellipsoid equatorial size.
     * @public
     * @returns {number} -
     */
    getEquatorialSize() {
        return this._a;
    }

    /**
     * Gets ellipsoid polar size.
     * @public
     * @returns {number} -
     */
    getPolarSize() {
        return this._b;
    }

    /**
     * Gets cartesian ECEF from Wgs84 geodetic coordiantes.
     * @public
     * @param {og.LonLat} lonlat - Degrees geodetic coordiantes.
     * @returns {og.math.Vector3} -
     */
    lonLatToCartesian(lonlat) {
        var latrad = _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * lonlat.lat,
            lonrad = _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] * lonlat.lon;

        var slt = Math.sin(latrad);

        var N = this._a / Math.sqrt(1 - this._e2 * slt * slt);
        var nc = (N + lonlat.height) * Math.cos(latrad);

        return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](
            nc * Math.sin(lonrad),
            (N * (1 - this._e2) + lonlat.height) * slt,
            nc * Math.cos(lonrad));
    }

    /**
     * Gets Wgs84 geodetic coordiantes from cartesian ECEF.
     * @public
     * @param {og.math.Vector3} cartesian - Cartesian coordinates.
     * @returns {og.LonLat} -
     */
    cartesianToLonLat(cartesian) {
        var x = cartesian.z, y = cartesian.x, z = cartesian.y;
        var ecc2 = this._e2;
        var ecc22 = this._e22;
        var r2 = x * x + y * y;
        var r = Math.sqrt(r2);
        var e2 = this._a2 - this._b2;
        var z2 = z * z;
        var f = 54.0 * this._b2 * z2;
        var g = r2 + (1 - ecc2) * z2 + ecc2 * e2;
        var g2 = g * g;
        var c = ecc22 * f * r2 / (g2 * g);
        var s = Math.pow((1 + c + Math.sqrt(c * (c + 2))), 0.33333333333333333);
        var p = f / (3 * Math.pow((1 + s + 1 / s), 2) * g2);
        var q = Math.sqrt(1 + 2 * ecc22 * p);
        var r0 = -(p * ecc2 * r) / 1 + q + Math.sqrt(0.5 * this._a2 * (1 + 1 / q) - p * (1 - ecc2) * z2 / (q * (1 + q)) - 0.5 * p * r2);
        var recc2r0 = r - ecc2 * r0;
        var recc2r02 = recc2r0 * recc2r0;
        var u = Math.sqrt(recc2r02 + z2);
        var v = Math.sqrt(recc2r02 + (1 - ecc2) * z2);
        var z0 = this._b2 * z / (this._a * v);
        var h = u * (1 - this._b2 / (this._a * v));
        var phi = Math.atan((z + this._k2 * z0) / r);
        var lambda = Math.atan2(y, x);
        var lat = phi * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"];
        var lon = lambda * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"];
        return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](lon, lat, h);
    }

    /**
     * Gets ellipsoid surface normal.
     * @public
     * @param {og.math.Vector3} coord - Spatial coordiantes.
     * @returns {og.math.Vector3} -
     */
    getSurfaceNormal3v(coord) {
        var r2 = this._invRadii2;
        var nx = coord.x * r2.x, ny = coord.y * r2.y, nz = coord.z * r2.z;
        var l = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
        return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](nx * l, ny * l, nz * l);
    }

    /**
     * Gets the cartesian point on the height over the ellipsoid surface.
     * @public
     * @param {og.math.Vector3} coord - Spatial ellipsoid coordiantes.
     * @param {number} h - Height this spatial coordinates.
     * @return {og.math.Vector3} -
     */
    getSurfaceHeight3v(coord, h) {
        var r2 = this._invRadii2;
        var nx = coord.x * r2.x, ny = coord.y * r2.y, nz = coord.z * r2.z;
        var l = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
        return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"](coord.x + h * nx * l, coord.y + h * ny * l, coord.z + h * nz * l);
    }

    /**
     * Returns the distance from one point to another(using haversine formula) on the great circle.
     * @param   {og.LonLat} lonLat1 - Longitude/latitude of source point.
     * @param   {og.LonLat} lonLat2 - Longitude/latitude of destination point.
     * @return {number} Distance between points.
     */
    getGreatCircleDistance(lonLat1, lonLat2) {
        var dLat = (lonLat2.lat - lonLat1.lat) * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var dLon = (lonLat2.lon - lonLat1.lon) * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"]) * Math.cos(lonLat2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"]);
        return this._a * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    /**
     * Returns the midpoint between two points on the great circle.
     * @param   {og.LonLat} lonLat1 - Longitude/latitude of first point.
     * @param   {og.LonLat} lonLat2 - Longitude/latitude of second point.
     * @return {og.LonLat} Midpoint between points.
     */
    getMiddlePointOnGreatCircle(lonLat1, lonLat2) {
        var f1 = lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"],
            l1 = lonLat1.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var f2 = lonLat2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var dl = (lonLat2.lon - lonLat1.lon) * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];

        var Bx = Math.cos(f2) * Math.cos(dl);
        var By = Math.cos(f2) * Math.sin(dl);

        var x = Math.sqrt((Math.cos(f1) + Bx) * (Math.cos(f1) + Bx) + By * By);
        var y = Math.sin(f1) + Math.sin(f2);
        var f3 = Math.atan2(y, x);

        var l3 = l1 + Math.atan2(By, Math.cos(f1) + Bx);

        return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"]((l3 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"] + 540) % 360 - 180, f3 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"]);
    }

    /**
     * Returns the point at given fraction between two points on the great circle.
     * @param   {og.LonLat} lonLat1 - Longitude/Latitude of source point.
     * @param   {og.LonLat} lonLat2 - Longitude/Latitude of destination point.
     * @param   {number} fraction - Fraction between the two points (0 = source point, 1 = destination point).
     * @returns {og.LonLat} Intermediate point between points.
     */
    getIntermediatePointOnGreatCircle(lonLat1, lonLat2, fraction) {
        var f1 = lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], l1 = lonLat1.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var f2 = lonLat2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], l2 = lonLat2.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];

        var sinf1 = Math.sin(f1), cosf1 = Math.cos(f1), sinl1 = Math.sin(l1), cosl1 = Math.cos(l1);
        var sinf2 = Math.sin(f2), cosf2 = Math.cos(f2), sinl2 = Math.sin(l2), cosl2 = Math.cos(l2);

        var df = f2 - f1,
            dl = l2 - l1;
        var a = Math.sin(df / 2) * Math.sin(df / 2) + Math.cos(f1) * Math.cos(f2) * Math.sin(dl / 2) * Math.sin(dl / 2);
        var d = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        var A = Math.sin((1 - fraction) * d) / Math.sin(d);
        var B = Math.sin(fraction * d) / Math.sin(d);

        var x = A * cosf1 * cosl1 + B * cosf2 * cosl2;
        var y = A * cosf1 * sinl1 + B * cosf2 * sinl2;
        var z = A * sinf1 + B * sinf2;

        var f3 = Math.atan2(z, Math.sqrt(x * x + y * y));
        var l3 = Math.atan2(y, x);

        return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"]((l3 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"] + 540) % 360 - 180, f3 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"]);
    }

    getRhumbBearing(lonLat1, lonLat2) {
        var dLon = (lonLat2.lon - lonLat1.lon) * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var dPhi = Math.log(Math.tan(lonLat2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] / 2 + Math.PI / 4) / Math.tan(lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] / 2 + Math.PI / 4));
        if (Math.abs(dLon) > Math.PI) {
            if (dLon > 0) {
                dLon = (2 * Math.PI - dLon) * -1;
            }
            else {
                dLon = 2 * Math.PI + dLon;
            }
        }
        return (Math.atan2(dLon, dPhi) * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"] + 360) % 360;
    }

    getBearing(lonLat1, lonLat2) {
        var f1 = lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], l1 = lonLat1.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var f2 = lonLat2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], l2 = lonLat2.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var y = Math.sin(l2 - l1) * Math.cos(f2);
        var x = Math.cos(f1) * Math.sin(f2) - Math.sin(f1) * Math.cos(f2) * Math.cos(l2 - l1);
        return Math.atan2(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"];
    }

    getBearingDestination(lonLat1, bearing, distance) {
        bearing = bearing * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var nlon = (lonLat1.lon + 540) % 360 - 180;
        var f1 = lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"], l1 = nlon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var dR = distance / this._a;
        var f2 = Math.asin(Math.sin(f1) * Math.cos(dR) + Math.cos(f1) * Math.sin(dR) * Math.cos(bearing));
        return new og.LonLat((l1 + Math.atan2(Math.sin(bearing) * Math.sin(dR) * Math.cos(f1), Math.cos(dR) - Math.sin(f1) * Math.sin(f2)))
            * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"], f2 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"]);
    }

    /**
     * Returns the (initial) bearing from source to destination point on the great circle.
     * @param {og.LonLat} lonLat1 - Longitude/latitude of source point.
     * @param {og.LonLat} lonLat2 - Longitude/latitude of destination point.
     * @return {number} Initial bearing in degrees from north.
     */
    getInitialBearing(lonLat1, lonLat2) {
        var f1 = lonLat1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"],
            f2 = lonLat2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var dl = (lonLat2.lon - lonLat1.lon) * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var y = Math.sin(dl) * Math.cos(f2);
        var x = Math.cos(f1) * Math.sin(f2) -
            Math.sin(f1) * Math.cos(f2) * Math.cos(dl);
        var D = Math.atan2(y, x);
        return (D * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"] + 360) % 360;
    }

    /**
     * Returns final bearing arriving at destination destination point from lonLat1 point; the final bearing
     * will differ from the initial bearing by varying degrees according to distance and latitude.
     * @param {og.LonLat} lonLat1 - Longitude/latitude of source point.
     * @param {og.LonLat} lonLat2 - Longitude/latitude of destination point.
     * @return {number} Final bearing in degrees from north.
     */
    getFinalBearing(lonLat1, lonLat2) {
        // get initial bearing from destination lonLat2 to lonLat1 & reverse it by adding 180
        return (this.getInitialBearing(lonLat2, lonLat1) + 180) % 360;
    }

    /**
     * Returns the point of intersection of two paths defined by point and bearing.
     * @param   {og.LonLat} p1 - First point.
     * @param   {number} brng1 - Initial bearing from first point.
     * @param   {og.LonLat} p2 - Second point.
     * @param   {number} brng2 - Initial bearing from second point.
     * @return {og.LonLat|null} Destination point (null if no unique intersection defined).
     */
    intersection(p1, brng1, p2, brng2) {
        var f1 = p1.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"],
            l1 = p1.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var f2 = p2.lat * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"],
            l2 = p2.lon * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var D13 = brng1 * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"],
            D23 = brng2 * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"];
        var df = f2 - f1,
            dl = l2 - l1;

        var d12 = 2 * Math.asin(Math.sqrt(Math.sin(df / 2) * Math.sin(df / 2)
            + Math.cos(f1) * Math.cos(f2) * Math.sin(dl / 2) * Math.sin(dl / 2)));
        if (d12 == 0) return null;

        // initial/final bearings between points
        var Da = Math.acos((Math.sin(f2) - Math.sin(f1) * Math.cos(d12)) / (Math.sin(d12) * Math.cos(f1)));
        if (isNaN(Da)) Da = 0; // protect against rounding
        var Db = Math.acos((Math.sin(f1) - Math.sin(f2) * Math.cos(d12)) / (Math.sin(d12) * Math.cos(f2)));

        var D12 = Math.sin(l2 - l1) > 0 ? Da : 2 * Math.PI - Da;
        var D21 = Math.sin(l2 - l1) > 0 ? 2 * Math.PI - Db : Db;

        var a1 = (D13 - D12 + Math.PI) % (2 * Math.PI) - Math.PI;
        var a2 = (D21 - D23 + Math.PI) % (2 * Math.PI) - Math.PI;

        if (Math.sin(a1) == 0 && Math.sin(a2) == 0) return null; // infinite intersections
        if (Math.sin(a1) * Math.sin(a2) < 0) return null;      // ambiguous intersection

        //a1 = Math.abs(a1);
        //a2 = Math.abs(a2);
        // ... Ed Williams takes abs of a1/a2, but seems to break calculation?

        var a3 = Math.acos(-Math.cos(a1) * Math.cos(a2) + Math.sin(a1) * Math.sin(a2) * Math.cos(d12));
        var d13 = Math.atan2(Math.sin(d12) * Math.sin(a1) * Math.sin(a2), Math.cos(a2) + Math.cos(a1) * Math.cos(a3));
        var f3 = Math.asin(Math.sin(f1) * Math.cos(d13) + Math.cos(f1) * Math.sin(d13) * Math.cos(D13));
        var dl13 = Math.atan2(Math.sin(D13) * Math.sin(d13) * Math.cos(f1), Math.cos(d13) - Math.sin(f1) * Math.sin(f3));
        var l3 = l1 + dl13;

        return new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"]((l3 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"] + 540) % 360 - 180, f3 * _math_js__WEBPACK_IMPORTED_MODULE_0__["DEGREES"]);
    }

    /**
     * Returns ray vector hit ellipsoid coordinates.
     * If the ray doesn't hit ellipsoid returns null.
     * @public
     * @param {og.math.Vector3} origin - Ray origin point.
     * @param {og.math.Vector3} direction - Ray direction.
     * @returns {og.math.Vector3} -
     */
    hitRay(origin, direction) {

        var q = this._invRadii.mul(origin);
        var w = this._invRadii.mul(direction);

        var q2 = q.dot(q);
        var qw = q.dot(w);

        var difference, w2, product, discriminant, temp;

        if (q2 > 1.0) {
            // Outside ellipsoid.
            if (qw >= 0.0) {
                // Looking outward or tangent (0 intersections).
                return null;
            }

            // qw < 0.0.
            var qw2 = qw * qw;
            difference = q2 - 1.0; // Positively valued.
            w2 = w.dot(w);
            product = w2 * difference;

            if (qw2 < product) {
                // Imaginary roots (0 intersections).
                return null;
            } else if (qw2 > product) {
                // Distinct roots (2 intersections).
                discriminant = qw * qw - product;
                temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                var root0 = temp / w2;
                var root1 = difference / temp;
                if (root0 < root1) {
                    return origin.add(direction.scaleTo(root0));
                }
                return origin.add(direction.scaleTo(root1));
            } else {
                // qw2 == product.  Repeated roots (2 intersections).
                var root = Math.sqrt(difference / w2);
                return origin.add(direction.scaleTo(root));
            }
        } else if (q2 < 1.0) {
            // Inside ellipsoid (2 intersections).
            difference = q2 - 1.0; // Negatively valued.
            w2 = w.dot(w);
            product = w2 * difference; // Negatively valued.
            discriminant = qw * qw - product;
            temp = -qw + Math.sqrt(discriminant); // Positively valued.
            return origin.add(direction.scaleTo(temp / w2));
        } else {
            // q2 == 1.0. On ellipsoid.
            if (qw < 0.0) {
                // Looking inward.
                w2 = w.dot(w);
                return origin.add(direction.scaleTo(-qw / w2));
            }
            // qw >= 0.0.  Looking outward or tangent.
            return null;
        }
    }
};



/***/ }),

/***/ "./src/og/ellipsoid/wgs84.js":
/*!***********************************!*\
  !*** ./src/og/ellipsoid/wgs84.js ***!
  \***********************************/
/*! exports provided: wgs84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wgs84", function() { return wgs84; });
/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ellipsoid.js */ "./src/og/ellipsoid/Ellipsoid.js");
/**
 * @module og/ellipsoid/wgs84
 */





/**
 * WGS84 ellipsoid object.
 * @type {og.Ellipsoid}
 */
const wgs84 = new _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_0__["Ellipsoid"](6378137.000, 6356752.3142);

/***/ }),

/***/ "./src/og/entity/BaseBillboard.js":
/*!****************************************!*\
  !*** ./src/og/entity/BaseBillboard.js ***!
  \****************************************/
/*! exports provided: BaseBillboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseBillboard", function() { return BaseBillboard; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/**
 * @module og/entity/BaseBillboard
 */





/**
 * Base prototype for billboard and label classes.
 * @class
 * @param {Object} [options] - Options:
 * @param {og.math.Vector3|Array.<number>} [options.position] - Billboard spatial position.
 * @param {number} [options.rotation] - Screen angle rotaion.
 * @param {og.math.Vector4|string|Array.<number>} [options.color] - Billboard color.
 * @param {og.math.Vector3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
 * @param {og.math.Vector3|Array.<number>} [options.offset] - Billboard center screen offset.
 * @param {boolean} [options.visibility] - Visibility.
 */
class BaseBillboard {
    constructor(options) {
        options = options || {};

        /**
         * Object unic identifier.
         * @public
         * @readonly
         * @type {number}
         */
        this.id = BaseBillboard._staticCounter++;

        /**
         * Billboard center cartesian position.
         * @protected
         * @type {og.math.Vector3}
         */
        this._position = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createVector3"](options.position);

        /**
         * Screen space rotation angle.
         * @protected
         * @type {number}
         */
        this._rotation = options.rotation || 0;

        /**
         * RGBA color.
         * @protected
         * @type {og.math.Vector4}
         */
        this._color = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGBA"](options.color);

        /**
         * Cartesian aligned axis vector.
         * @protected
         * @type {og.math.Vector3}
         */
        this._alignedAxis = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createVector3"](options.alignedAxis);

        /**
         * Billboard center screen space offset. Where x,y - screen space offset and z - depth offset.
         * @protected
         * @type {og.math.Vecto3}
         */
        this._offset = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createVector3"](options.offset);

        /**
         * Billboard visibility.
         * @protected
         * @type {boolean}
         */
        this._visibility = options.visibility != undefined ? options.visibility : true;

        /**
         * Billboard scale.
         * @protected
         * @type {number}
         */
        this._scale = options.scale || 1.0;

        /**
         * Entity instance that holds this billboard.
         * @protected
         * @type {og.Entity}
         */
        this._entity = null;

        /**
         * Handler that stores and renders this billboard object.
         * @protected
         * @type {og.BillboardHandler}
         */
        this._handler = null;

        /**
         * Billboard handler array index.
         * @protected
         * @type {number}
         */
        this._handlerIndex = -1;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    /**
     * Sets billboard position.
     * @public
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} z - Z coordinate.
     */
    setPosition(x, y, z) {
        this._position.x = x;
        this._position.y = y;
        this._position.z = z;
        this._handler && this._handler.setPositionArr(this._handlerIndex, this._position);
    }

    /**
     * Sets billboard position.
     * @public
     * @param {og.math.Vector3} position - Cartesian coordinates.
     */
    setPosition3v(position) {
        this._position.x = position.x;
        this._position.y = position.y;
        this._position.z = position.z;
        this._handler && this._handler.setPositionArr(this._handlerIndex, position);
    }

    /**
     * Returns billboard position.
     * @public
     * @returns {og.math.Vector3}
     */
    getPosition() {
        return this._position;
    }

    /**
     * Sets screen space offset.
     * @public
     * @param {number} x - X offset.
     * @param {number} y - Y offset.
     * @param {number} [z] - Z offset.
     */
    setOffset(x, y, z) {
        this._offset.x = x;
        this._offset.y = y;
        (z != undefined) && (this._offset.z = z);
        this._handler && this._handler.setOffsetArr(this._handlerIndex, this._offset);
    }

    /**
     * Sets billboard scale.
     * @public
     * @param {number} scale - Scale.
     */
    setScale(scale) {
        this._scale = scale;
        this._handler && this._handler.setScaleArr(this._handlerIndex, scale);
    }

    /**
     * Gets billboard scale.
     * @public
     * @returns {number}
     */
    getScale() {
        return this._scale;
    }

    /**
     * Sets screen space offset.
     * @public
     * @param {og.math.Vector2} offset - Offset size.
     */
    setOffset3v(offset) {
        this._offset.x = offset.x;
        this._offset.y = offset.y;
        (offset.z != undefined) && (this._offset.z = offset.z);
        this._handler && this._handler.setOffsetArr(this._handlerIndex, offset);
    }

    /**
     * Returns billboard screen space offset size.
     * @public
     * @returns {og.math.Vector3}
     */
    getOffset() {
        return this._offset;
    }

    /**
     * Sets billboard screen space rotation in radians.
     * @public
     * @param {number} rotation - Screen space rotation in radians.
     */
    setRotation(rotation) {
        this._rotation = rotation;
        this._handler && this._handler.setRotationArr(this._handlerIndex, rotation);
    }

    /**
     * Gets screen space rotation.
     * @public
     * @returns {number}
     */
    getRotation() {
        return this._rotation;
    }

    /**
     * Sets billboard opacity.
     * @public
     * @param {number} a - Billboard opacity.
     */
    setOpacity(a) {
        this._color.w = a;
        this.setColor(this._color.x, this._color.y, this._color.z, a);
    }

    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} a - Alpha.
     */
    setColor(r, g, b, a) {
        this._color.x = r;
        this._color.y = g;
        this._color.z = b;
        (a != undefined) && (this._color.w = a);
        this._handler && this._handler.setRgbaArr(this._handlerIndex, this._color);
    }

    /**
     * Sets RGBA color. Each channel from 0.0 to 1.0.
     * @public
     * @param {og.math.Vector4} color - RGBA vector.
     */
    setColor4v(color) {
        this._color.x = color.x;
        this._color.y = color.y;
        this._color.z = color.z;
        (color.w != undefined) && (this._color.w = color.w);
        this._handler && this._handler.setRgbaArr(this._handlerIndex, color);
    }

    /**
     * Sets billboard color.
     * @public
     * @param {string} color - HTML style color.
     */
    setColorHTML(color) {
        this.setColor4v(og.utils.htmlColorToRgba(color));
    }

    /**
     * Returns RGBA color.
     * @public
     * @returns {og.math.Vector4}
     */
    getColor() {
        return this._color;
    }

    /**
     * Sets billboard visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this._visibility = visibility;
        this._handler && this._handler.setVisibility(this._handlerIndex, visibility);
    }

    /**
     * Returns billboard visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
        return this._visibility;
    }

    /**
     * Sets billboard cartesian aligned vector.
     * @public
     * @param {number} x - Aligned vector X coordinate.
     * @param {number} y - Aligned vector Y coordinate.
     * @param {number} z - Aligned vector Z coordinate.
     */
    setAlignedAxis(x, y, z) {
        this._alignedAxis.x = x;
        this._alignedAxis.y = y;
        this._alignedAxis.z = z;
        this._handler && this._handler.setAlignedAxisArr(this._handlerIndex, this._alignedAxis);
    }

    /**
     * Sets billboard aligned vector.
     * @public
     * @param {og.math.Vecto3} alignedAxis - Vector to align.
     */
    setAlignedAxis3v(alignedAxis) {
        this._alignedAxis.x = alignedAxis.x;
        this._alignedAxis.y = alignedAxis.y;
        this._alignedAxis.z = alignedAxis.z;
        this._handler && this._handler.setAlignedAxisArr(this._handlerIndex, alignedAxis);
    }

    /**
     * Returns aligned vector.
     * @public
     * @returns {og.math.Vector3}
     */
    getAlignedAxis() {
        return this._alignedAxis;
    }

    /**
     * Removes billboard from hander.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }

    /**
     * Sets billboard picking color.
     * @public
     * @param {og.math.Vector3} color - Picking color.
     */
    setPickingColor3v(color) {
        this._handler && this._handler.setPickingColorArr(this._handlerIndex, color);
    }
};



/***/ }),

/***/ "./src/og/entity/Billboard.js":
/*!************************************!*\
  !*** ./src/og/entity/Billboard.js ***!
  \************************************/
/*! exports provided: Billboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Billboard", function() { return Billboard; });
/* harmony import */ var _BaseBillboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseBillboard.js */ "./src/og/entity/BaseBillboard.js");
/**
 * @module og/entity/Billboard
 */






/**
 * Represents basic quad billboard image.
 * @class
 * @extends {og.BaseBillboard}
 * @param {Object} [options] - Options:
 * @param {og.math.Vector3|Array.<number>} [options.position] - Billboard spatial position.
 * @param {number} [options.rotation] - Screen angle rotaion.
 * @param {og.math.Vector4|string|Array.<number>} [options.color] - Billboard color.
 * @param {og.math.Vector3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
 * @param {og.math.Vector3|Array.<number>} [options.offset] - Billboard center screen offset.
 * @param {boolean} [options.visibility] - Visibility.
 * @param {string} [options.src] - Billboard image url source.
 * @param {Image} [options.image] - Billboard image object.
 * @param {number} [options.width] - Screen width.
 * @param {number} [options.height] - Screen height.
 * @param {number} [options.scale] - Billboard scale.
 */
class Billboard extends _BaseBillboard_js__WEBPACK_IMPORTED_MODULE_0__["BaseBillboard"] {
    constructor(options) {
        super(options);

        options = options || {};

        /**
         * Image src.
         * @protected
         * @type {string}
         */
        this._src = options.src || null;

        /**
         * Image object.
         * @protected
         * @type {Object}
         */
        this._image = options.image || null;

        /**
         * Billboard screen width.
         * @protected
         * @type {number}
         */
        this._width = options.width || (options.size ? options.size[0] : 30);

        /**
         * Billboard screen height.
         * @protected
         * @type {number}
         */
        this._height = options.height || (options.size ? options.size[1] : 30);
    }

    /**
     * Sets billboard image url source.
     * @public
     * @param {string} src - Image url.
     */
    setSrc(src) {
        this._src = src;
        var bh = this._handler;
        if (bh && src) {
            var rn = bh._entityCollection.renderNode;
            if (rn) {
                var ta = rn.billboardsTextureAtlas;
                var that = this;
                ta.loadImage(src, function (img) {
                    if (ta.nodes[img.__nodeIndex]) {
                        that._image = img;
                        bh.setTexCoordArr(that._handlerIndex, ta.nodes[that._image.__nodeIndex].texCoords);
                    } else {
                        ta.addImage(img);
                        ta.createTexture();
                        that._image = img;
                        rn.updateBillboardsTexCoords();
                    }
                });
            }
        }
    }

    /**
     * Sets image object.
     * @public
     * @param {Object} image - JavaScript image object.
     */
    setImage(image) {
        this.setSrc(image.src);
    }

    /**
     * Sets billboard screen size in pixels.
     * @public
     * @param {number} width - Billboard width.
     * @param {number} height - Billboard height.
     */
    setSize(width, height) {
        this._width = width;
        this._height = height;
        this._handler && this._handler.setSizeArr(this._handlerIndex, width * this._scale, height * this._scale);
    }

    /**
     * Returns billboard screen size.
     * @public
     * @returns {Object}
     */
    getSize() {
        return {
            "width": this._width,
            "height": this._height
        };
    }

    /**
     * Sets billboard screen width.
     * @public
     * @param {number} width - Width.
     */
    setWidth(width) {
        this.setSize(width, this._height);
    }

    /**
     * Gets billboard screen width.
     * @public
     * @returns {number}
     */
    getWidth() {
        return this._width;
    }

    /**
     * Sets billboard screen heigh.
     * @public
     * @param {number} height - Height.
     */
    setHeight(height) {
        this.setSize(this._width, height);
    }

    /**
     * Gets billboard screen height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this._height;
    }
};



/***/ }),

/***/ "./src/og/entity/BillboardHandler.js":
/*!*******************************************!*\
  !*** ./src/og/entity/BillboardHandler.js ***!
  \*******************************************/
/*! exports provided: BillboardHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BillboardHandler", function() { return BillboardHandler; });
/* harmony import */ var _shaders_billboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/billboard.js */ "./src/og/shaders/billboard.js");
/**
 * @module og/entity/BillboardHandler
 */





const PICKINGCOLOR_BUFFER = 0;
const POSITION_BUFFER = 1;
const SIZE_BUFFER = 2;
const OFFSET_BUFFER = 3;
const RGBA_BUFFER = 4;
const ROTATION_BUFFER = 5;
const TEXCOORD_BUFFER = 6;
const VERTEX_BUFFER = 7;
const ALIGNEDAXIS_BUFFER = 8;

/*
 * og.BillboardHandler
 *
 *
 */
class BillboardHandler {
    constructor(entityCollection) {

        /**
         * Picking rendering option.
         * @public
         * @type {boolean}
         */
        this.pickingEnabled = true;

        this._entityCollection = entityCollection;

        this._renderer = null;

        this._billboards = [];

        this._positionBuffer = null;
        this._sizeBuffer = null;
        this._offsetBuffer = null;
        this._rgbaBuffer = null;
        this._rotationBuffer = null;
        this._texCoordBuffer = null;
        this._vertexBuffer = null;
        this._alignedAxisBuffer = null;

        this._texCoordArr = [];
        this._vertexArr = [];
        this._positionArr = [];
        this._sizeArr = [];
        this._offsetArr = [];
        this._rgbaArr = [];
        this._rotationArr = [];
        this._alignedAxisArr = [];

        this._pickingColorBuffer = null;
        this._pickingColorArr = [];

        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[PICKINGCOLOR_BUFFER] = this.createPickingColorBuffer;
        this._buffersUpdateCallbacks[POSITION_BUFFER] = this.createPositionBuffer;
        this._buffersUpdateCallbacks[SIZE_BUFFER] = this.createSizeBuffer;
        this._buffersUpdateCallbacks[OFFSET_BUFFER] = this.createOffsetBuffer;
        this._buffersUpdateCallbacks[RGBA_BUFFER] = this.createRgbaBuffer;
        this._buffersUpdateCallbacks[ROTATION_BUFFER] = this.createRotationBuffer;
        this._buffersUpdateCallbacks[TEXCOORD_BUFFER] = this.createTexCoordBuffer;
        this._buffersUpdateCallbacks[VERTEX_BUFFER] = this.createVertexBuffer;
        this._buffersUpdateCallbacks[ALIGNEDAXIS_BUFFER] = this.createAlignedAxisBuffer;

        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

        this.__staticId = BillboardHandler.staticCounter++;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    static concArr(dest, curr) {
        for (var i = 0; i < curr.length; i++) {
            dest.push(curr[i]);
        }
    }

    initShaderProgram() {
        if (this._renderer.handler) {
            if (!this._renderer.handler.shaderPrograms.billboard) {
                var isSingleBuffer = !this._renderer.isMultiFramebufferCompatible();
                this._renderer.handler.addShaderProgram(_shaders_billboard_js__WEBPACK_IMPORTED_MODULE_0__["billboard"](isSingleBuffer));
            }
            if (!this._renderer.handler.shaderPrograms.billboardPicking) {
                this._renderer.handler.addShaderProgram(_shaders_billboard_js__WEBPACK_IMPORTED_MODULE_0__["billboardPicking"]());
            }
        }
    }

    setRenderer(renderer) {
        this._renderer = renderer;
        this.initShaderProgram();
    }

    refresh() {
        var i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }

    _removeBillboards() {
        var i = this._billboards.length;
        while (i--) {
            var bi = this._billboards[i];
            bi._handlerIndex = -1;
            bi._handler = null;
        }
        this._billboards.length = 0;
        this._billboards = [];
    }

    clear() {
        this._texCoordArr.length = 0;
        this._vertexArr.length = 0;
        this._positionArr.length = 0;
        this._sizeArr.length = 0;
        this._offsetArr.length = 0;
        this._rgbaArr.length = 0;
        this._rotationArr.length = 0;
        this._alignedAxisArr.length = 0;
        this._pickingColorArr.length = 0;

        this._texCoordArr = [];
        this._vertexArr = [];
        this._positionArr = [];
        this._sizeArr = [];
        this._offsetArr = [];
        this._rgbaArr = [];
        this._rotationArr = [];
        this._alignedAxisArr = [];
        this._pickingColorArr = [];

        this._removeBillboards();
        this._deleteBuffers();
        this.refresh();
    }

    _deleteBuffers() {
        var gl = this._renderer.handler.gl;
        gl.deleteBuffer(this._positionBuffer);
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._offsetBuffer);
        gl.deleteBuffer(this._rgbaBuffer);
        gl.deleteBuffer(this._rotationBuffer);
        gl.deleteBuffer(this._vertexBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
        gl.deleteBuffer(this._alignedAxisBuffer);
        gl.deleteBuffer(this._pickingColorBuffer);

        this._positionBuffer = null;
        this._sizeBuffer = null;
        this._offsetBuffer = null;
        this._rgbaBuffer = null;
        this._rotationBuffer = null;
        this._vertexBuffer = null;
        this._texCoordBuffer = null;
        this._alignedAxisBuffer = null;
        this._pickingColorBuffer = null;
    }

    update() {
        if (this._renderer) {
            var i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }

    add(billboard) {
        if (billboard._handlerIndex == -1) {
            billboard._handler = this;
            billboard._handlerIndex = this._billboards.length;
            this._billboards.push(billboard);
            this._addBillboardToArrays(billboard);
            this.refresh();
            billboard.setSrc(billboard._src || billboard._image && billboard._image.src);
        }
    }

    _addBillboardToArrays(billboard) {
        if (billboard._visibility) {
            BillboardHandler.concArr(this._vertexArr, [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]);
        } else {
            BillboardHandler.concArr(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
        }

        BillboardHandler.concArr(this._texCoordArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);

        var x = billboard._position.x, y = billboard._position.y, z = billboard._position.z, w = billboard._scale;
        BillboardHandler.concArr(this._positionArr, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

        x = billboard._width; y = billboard._height;
        BillboardHandler.concArr(this._sizeArr, [x, y, x, y, x, y, x, y, x, y, x, y]);

        x = billboard._offset.x; y = billboard._offset.y; z = billboard._offset.z;
        BillboardHandler.concArr(this._offsetArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

        x = billboard._color.x; y = billboard._color.y; z = billboard._color.z; w = billboard._color.w;
        BillboardHandler.concArr(this._rgbaArr, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

        x = billboard._rotation;
        BillboardHandler.concArr(this._rotationArr, [x, x, x, x, x, x]);

        x = billboard._alignedAxis.x, y = billboard._alignedAxis.y, z = billboard._alignedAxis.z;
        BillboardHandler.concArr(this._alignedAxisArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

        x = billboard._entity._pickingColor.x / 255, y = billboard._entity._pickingColor.y / 255, z = billboard._entity._pickingColor.z / 255;
        BillboardHandler.concArr(this._pickingColorArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
    }

    _displayPASS() {
        var r = this._renderer;
        var h = r.handler;
        h.shaderPrograms.billboard.activate();
        var sh = h.shaderPrograms.billboard._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var gl = h.gl;

        gl.uniform1i(shu.u_texture._pName, 0);

        gl.uniformMatrix4fv(shu.viewMatrix._pName, false, r.activeCamera._viewMatrix._m);
        gl.uniformMatrix4fv(shu.projectionMatrix._pName, false, r.activeCamera._projectionMatrix._m);

        gl.uniform3fv(shu.uCamPos._pName, r.activeCamera.eye.toVec());

        gl.uniform3fv(shu.uScaleByDistance._pName, this._entityCollection.scaleByDistance);

        gl.uniform1f(shu.uOpacity._pName, this._entityCollection._animatedOpacity);

        gl.uniform2fv(shu.uFloatParams._pName, [this._entityCollection.renderNode._planetRadius2 || 0, r.activeCamera._tanViewAngle_hradOneByHeight]);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
        gl.vertexAttribPointer(sha.a_texCoord._pName, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
        gl.vertexAttribPointer(sha.a_positions._pName, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
        gl.vertexAttribPointer(sha.a_rgba._pName, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size._pName, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset._pName, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation._pName, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._alignedAxisBuffer);
        gl.vertexAttribPointer(sha.a_alignedAxis._pName, this._alignedAxisBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
    }

    _pickingPASS() {
        var r = this._renderer;
        var h = r.handler;
        h.shaderPrograms.billboardPicking.activate();
        var sh = h.shaderPrograms.billboardPicking._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var gl = h.gl;

        gl.uniformMatrix4fv(shu.viewMatrix._pName, false, r.activeCamera._viewMatrix._m);
        gl.uniformMatrix4fv(shu.projectionMatrix._pName, false, r.activeCamera._projectionMatrix._m);

        gl.uniform3fv(shu.uCamPos._pName, r.activeCamera.eye.toVec());

        gl.uniform3fv(shu.uScaleByDistance._pName, this._entityCollection.scaleByDistance);

        gl.uniform1f(shu.uOpacity._pName, this._entityCollection._animatedOpacity);

        gl.uniform2fv(shu.uFloatParams._pName, [this._entityCollection.renderNode._planetRadius2 || 0, r.activeCamera._tanViewAngle_hradOneByHeight]);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
        gl.vertexAttribPointer(sha.a_positions._pName, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
        gl.vertexAttribPointer(sha.a_pickingColor._pName, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size._pName, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset._pName, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation._pName, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._alignedAxisBuffer);
        gl.vertexAttribPointer(sha.a_alignedAxis._pName, this._alignedAxisBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
    };

    draw() {
        if (this._billboards.length) {
            this.update();
            this._displayPASS();
        }
    }

    drawPicking() {
        if (this._billboards.length && this.pickingEnabled) {
            this._pickingPASS();
        }
    }

    reindexBillbordsArray(startIndex) {
        var b = this._billboards;
        for (var i = startIndex; i < b.length; i++) {
            b[i]._handlerIndex = i;
        }
    }

    _removeBillboard(billboard) {
        var bi = billboard._handlerIndex;

        this._billboards.splice(bi, 1);

        var i = bi * 24;
        this._rgbaArr.splice(i, 24);
        this._positionArr.splice(i, 24);

        i = bi * 18;
        this._offsetArr.splice(i, 18);
        this._alignedAxisArr.splice(i, 18);
        this._pickingColorArr.splice(i, 18);

        i = bi * 12;
        this._vertexArr.splice(i, 12);
        this._sizeArr.splice(i, 12);
        this._texCoordArr.splice(i, 12);

        i = bi * 6;
        this._rotationArr.splice(i, 6);

        this.reindexBillbordsArray(bi);
        this.refresh();

        billboard._handlerIndex = -1;
        billboard._handler = null;
    }

    remove(billboard) {
        if (billboard._handler && this.__staticId == billboard._handler.__staticId) {
            this._removeBillboard(billboard);
        }
    }

    setPositionArr(index, position) {

        var i = index * 24;
        var a = this._positionArr, x = position.x, y = position.y, z = position.z;

        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;

        a[i + 4] = x;
        a[i + 5] = y;
        a[i + 6] = z;

        a[i + 8] = x;
        a[i + 9] = y;
        a[i + 10] = z;

        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;

        a[i + 16] = x;
        a[i + 17] = y;
        a[i + 18] = z;

        a[i + 20] = x;
        a[i + 21] = y;
        a[i + 22] = z;

        this._changedBuffers[POSITION_BUFFER] = true;
    }

    setScaleArr(index, scale) {

        var i = index * 24;
        var a = this._positionArr;

        a[i + 3] = scale;
        a[i + 7] = scale;
        a[i + 11] = scale;
        a[i + 15] = scale;
        a[i + 19] = scale;
        a[i + 23] = scale;

        this._changedBuffers[POSITION_BUFFER] = true;
    }

    setPickingColorArr(index, color) {

        var i = index * 18;
        var a = this._pickingColorArr, x = color.x / 255, y = color.y / 255, z = color.z / 255;

        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;

        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;

        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;

        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;

        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;

        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;

        this._changedBuffers[PICKINGCOLOR_BUFFER] = true;
    }

    setSizeArr(index, width, height) {

        var i = index * 12;
        var a = this._sizeArr, x = width, y = height;

        a[i] = x;
        a[i + 1] = y;

        a[i + 2] = x;
        a[i + 3] = y;

        a[i + 4] = x;
        a[i + 5] = y;

        a[i + 6] = x;
        a[i + 7] = y;

        a[i + 8] = x;
        a[i + 9] = y;

        a[i + 10] = x;
        a[i + 11] = y;

        this._changedBuffers[SIZE_BUFFER] = true;
    }

    setOffsetArr(index, offset) {

        var i = index * 18;
        var a = this._offsetArr, x = offset.x, y = offset.y, z = offset.z;

        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;

        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;

        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;

        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;

        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;

        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;

        this._changedBuffers[OFFSET_BUFFER] = true;
    }

    setRgbaArr(index, rgba) {

        var i = index * 24;
        var a = this._rgbaArr, x = rgba.x, y = rgba.y, z = rgba.z, w = rgba.w;

        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;
        a[i + 3] = w;

        a[i + 4] = x;
        a[i + 5] = y;
        a[i + 6] = z;
        a[i + 7] = w;

        a[i + 8] = x;
        a[i + 9] = y;
        a[i + 10] = z;
        a[i + 11] = w;

        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;
        a[i + 15] = w;

        a[i + 16] = x;
        a[i + 17] = y;
        a[i + 18] = z;
        a[i + 19] = w;

        a[i + 20] = x;
        a[i + 21] = y;
        a[i + 22] = z;
        a[i + 23] = w;

        this._changedBuffers[RGBA_BUFFER] = true;
    }

    setRotationArr(index, rotation) {

        var i = index * 6;
        var a = this._rotationArr;

        a[i] = rotation;
        a[i + 1] = rotation;
        a[i + 2] = rotation;
        a[i + 3] = rotation;
        a[i + 4] = rotation;
        a[i + 5] = rotation;

        this._changedBuffers[ROTATION_BUFFER] = true
    }

    setTexCoordArr(index, tcoordArr) {

        var i = index * 12;
        var a = this._texCoordArr;

        a[i] = tcoordArr[0];
        a[i + 1] = tcoordArr[1];

        a[i + 2] = tcoordArr[2];
        a[i + 3] = tcoordArr[3];

        a[i + 4] = tcoordArr[4];
        a[i + 5] = tcoordArr[5];

        a[i + 6] = tcoordArr[6];
        a[i + 7] = tcoordArr[7];

        a[i + 8] = tcoordArr[8];
        a[i + 9] = tcoordArr[9];

        a[i + 10] = tcoordArr[10];
        a[i + 11] = tcoordArr[11];

        this._changedBuffers[TEXCOORD_BUFFER] = true;
    }

    setVisibility(index, visibility) {
        var vArr;
        if (visibility) {
            vArr = [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];
        } else {
            vArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.setVertexArr(index, vArr);
    }

    setVertexArr(index, vertexArr) {

        var i = index * 12;
        var a = this._vertexArr;

        a[i] = vertexArr[0];
        a[i + 1] = vertexArr[1];
        a[i + 2] = vertexArr[2];

        a[i + 3] = vertexArr[3];
        a[i + 4] = vertexArr[4];
        a[i + 5] = vertexArr[5];

        a[i + 6] = vertexArr[6];
        a[i + 7] = vertexArr[7];
        a[i + 8] = vertexArr[8];

        a[i + 9] = vertexArr[9];
        a[i + 10] = vertexArr[10];
        a[i + 11] = vertexArr[11];

        this._changedBuffers[VERTEX_BUFFER] = true;
    }

    setAlignedAxisArr(index, alignedAxis) {

        var i = index * 18;
        var a = this._alignedAxisArr, x = alignedAxis.x, y = alignedAxis.y, z = alignedAxis.z;

        a[i] = x;
        a[i + 1] = y;
        a[i + 2] = z;

        a[i + 3] = x;
        a[i + 4] = y;
        a[i + 5] = z;

        a[i + 6] = x;
        a[i + 7] = y;
        a[i + 8] = z;

        a[i + 9] = x;
        a[i + 10] = y;
        a[i + 11] = z;

        a[i + 12] = x;
        a[i + 13] = y;
        a[i + 14] = z;

        a[i + 15] = x;
        a[i + 16] = y;
        a[i + 17] = z;

        this._changedBuffers[ALIGNEDAXIS_BUFFER] = true;
    }

    createPositionBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._positionBuffer);
        this._positionBuffer = h.createArrayBuffer(new Float32Array(this._positionArr), 4, this._positionArr.length / 4, h.gl.DYNAMIC_DRAW);
    }

    createSizeBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._sizeBuffer);
        this._sizeBuffer = h.createArrayBuffer(new Float32Array(this._sizeArr), 2, this._sizeArr.length / 2);
    }

    createOffsetBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._offsetBuffer);
        this._offsetBuffer = h.createArrayBuffer(new Float32Array(this._offsetArr), 3, this._offsetArr.length / 3);
    }

    createRgbaBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._rgbaBuffer);
        this._rgbaBuffer = h.createArrayBuffer(new Float32Array(this._rgbaArr), 4, this._rgbaArr.length / 4);
    }

    createRotationBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._rotationBuffer);
        this._rotationBuffer = h.createArrayBuffer(new Float32Array(this._rotationArr), 1, this._rotationArr.length, h.gl.DYNAMIC_DRAW);
    }

    createVertexBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._vertexBuffer);
        this._vertexBuffer = h.createArrayBuffer(new Float32Array(this._vertexArr), 2, this._vertexArr.length / 2, h.gl.DYNAMIC_DRAW);
    }

    createTexCoordBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._texCoordBuffer);
        this._texCoordBuffer = h.createArrayBuffer(new Float32Array(this._texCoordArr), 2, this._texCoordArr.length / 2, h.gl.DYNAMIC_DRAW);
    }

    createAlignedAxisBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._alignedAxisBuffer);
        this._alignedAxisBuffer = h.createArrayBuffer(new Float32Array(this._alignedAxisArr), 3, this._alignedAxisArr.length / 3);
    }

    createPickingColorBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._pickingColorBuffer);
        this._pickingColorBuffer = h.createArrayBuffer(new Float32Array(this._pickingColorArr), 3, this._pickingColorArr.length / 3);
    }

    refreshTexCoordsArr() {
        var bc = this._entityCollection;
        if (bc && bc.renderNode) {
            var ta = bc.renderNode.billboardsTextureAtlas;
            for (var i = 0; i < this._billboards.length; i++) {
                var bi = this._billboards[i];
                var img = bi._image;
                if (img) {
                    var imageNode = ta.nodes[bi._image.__nodeIndex];
                    if (imageNode) {
                        this.setTexCoordArr(bi._handlerIndex, imageNode.texCoords);
                    }
                }
            }
        }
    }
};




/***/ }),

/***/ "./src/og/entity/Entity.js":
/*!*********************************!*\
  !*** ./src/og/entity/Entity.js ***!
  \*********************************/
/*! exports provided: Entity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return Entity; });
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/* harmony import */ var _Billboard_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Billboard.js */ "./src/og/entity/Billboard.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Geometry.js */ "./src/og/entity/Geometry.js");
/* harmony import */ var _Label_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Label.js */ "./src/og/entity/Label.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _Polyline_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Polyline.js */ "./src/og/entity/Polyline.js");
/* harmony import */ var _PointCloud_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PointCloud.js */ "./src/og/entity/PointCloud.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/entity/Entity
 */






//import { Box } from '../shapes/Box.js';






//import { Sphere } from '../shapes/Sphere.js';



/**
 * Entity instances aggregate multiple forms of visualization into a single high-level object.
 * They can be created manually and added to entity collection.
 *
 * @class
 * @param {Object} [options] - Entity options:
 * @param {string} [options.name] - A human readable name to display to users. It does not have to be unique.
 * @param {og.math.Vector3|Array.<number>} [options.cartesian] - Spatial entities like billboard, label, sphere etc. cartesian position.
 * @param {og.LonLat} [options.lonlat] - Geodetic coordiantes for an entities like billboard, label, sphere etc.
 * @param {boolean} [options.aground] - True for entities that have to be placed on the relief.
 * @param {boolean} [options.visibility] - Entity visibility.
 * @param {*} [options.billboard] - Billboard options(see {@link og.Billboard}).
 * @param {*} [options.label] - Label options(see {@link og.Label}).
 * @param {*} [options.sphere] - Sphere options(see {@link og.shape.Sphere}).
 * @param {*} [options.box] - Sphere options(see {@link og.shape.Box}).
 * @param {*} [options.Polyline] - Polyline options(see {@link og.Polyline}).
 * @param {*} [options.pointCloud] - Point cloud options(see {@link og.PointCloud}).
 * @param {*} [options.geometry] - Geometry options (see {@link og.Geometry}), available for vector layer only.
 * @param {*} [options.properties] - Entity custom properties.
 */
class Entity {
    constructor(options) {

        options = options || {};

        options.properties = options.properties || {};

        /**
         * Unic identifier.
         * @public
         * @readonly
         */
        this.id = Entity.__staticCounter++;

        /**
         * Entity user defined properties.
         * @public
         * @type {Object}
         */
        this.properties = options.properties || {};

        /**
         * Entity name.
         * @public
         * @type {string}
         */
        this.properties.name = this.properties.name || "noname";

        /**
         * Children entities.
         * @public
         * @type {Array.<og.Entity>}
         */
        this.childrenNodes = [];

        /**
         * Parent entity.
         * @public
         * @type {og.Entity}
         */
        this.parent = null;

        /**
         * Entity cartesian position.
         * @protected
         * @type {og.math.Vector3}
         */
        this._cartesian = _utils_shared_js__WEBPACK_IMPORTED_MODULE_1__["createVector3"](options.cartesian);

        /**
         * Geodetic entity coordiantes.
         * @protected
         * @type {og.LonLat}
         */
        this._lonlat = _utils_shared_js__WEBPACK_IMPORTED_MODULE_1__["createLonLat"](options.lonlat);

        /**
         * World Mercator entity coordinates.
         * @protected
         * @type {og.LonLat}
         */
        this._lonlatMerc = null;

        /**
         * Entity visible terrain altitude.
         * @protected
         * @type {number}
         */
        this._altitude = options.altitude || 0.0;

        /**
         * Visibility flag.
         * @protected
         * @type {boolean}
         */
        this._visibility = options.visibility != undefined ? options.visibility : true;

        /**
         * Entity collection that this entity belongs to.
         * @protected
         * @type {og.EntityCollection}
         */
        this._entityCollection = null;

        /**
         * Entity collection array store index.
         * @protected
         * @type {number}
         */
        this._entityCollectionIndex = -1;

        /**
         * Assigned vector layer pointer.
         * @protected
         * @type {og.layer.Vector}
         */
        this._layer = null;

        /**
         * Assigned vector layer entity array index.
         * @protected
         * @type {number}
         */
        this._layerIndex = -1;

        /**
         * Picking color.
         * @protected
         * @type {og.math.Vector3}
         */
        this._pickingColor = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_9__["Vec3"](0, 0, 0);

        this._featureConstructorArray = {
            "billboard": [_Billboard_js__WEBPACK_IMPORTED_MODULE_2__["Billboard"], this.setBillboard],
            "label": [_Label_js__WEBPACK_IMPORTED_MODULE_5__["Label"], this.setLabel],
            "sphere": [Sphere, this.setShape],
            "box": [Box, this.setShape],
            "polyline": [_Polyline_js__WEBPACK_IMPORTED_MODULE_7__["Polyline"], this.setPolyline],
            "pointCloud": [_PointCloud_js__WEBPACK_IMPORTED_MODULE_8__["PointCloud"], this.setPointCloud],
            "geometry": [_Geometry_js__WEBPACK_IMPORTED_MODULE_4__["Geometry"], this.setGeometry],
        };

        /**
         * Billboard entity.
         * @public
         * @type {og.Billboard}
         */
        this.billboard = this._createOptionFeature('billboard', options.billboard);

        /**
         * Text label entity.
         * @public
         * @type {og.Label}
         */
        this.label = this._createOptionFeature('label', options.label);

        /**
         * Shape entity.
         * @public
         * @type {og.shape.BaseShape}
         */
        this.shape = this._createOptionFeature('sphere', options.sphere || options.box);

        /**
         * Polyline entity.
         * @public
         * @type {og.Polyline}
         */
        this.polyline = this._createOptionFeature('polyline', options.polyline);

        /**
         * PointCloud entity.
         * @public
         * @type {og.PointCloud}
         */
        this.pointCloud = this._createOptionFeature('pointCloud', options.pointCloud);

        /**
         * Geometry entity(available only for vector layer).
         * @public
         * @type {og.Geometry}
         */
        this.geometry = this._createOptionFeature('geometry', options.geometry);


        //this.model = null;
        //...
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    _createOptionFeature(featureName, options) {
        if (options) {
            var c = this._featureConstructorArray[featureName];
            return c[1].call(this, new c[0](options));
        }
        return null;
    }

    /**
     * Adds current entity into the specified entity collection.
     * @public
     * @param {og.EntityCollection|og.layer.Vector} collection - Specified entity collection or vector layer.
     * @param {Boolean} [rightNow=false] - Entity insertion option for vector layer.
     * @returns {og.Entity} - This object.
     */
    addTo(collection, rightNow) {
        collection.add(this, rightNow);
        return this;
    }

    /**
     * Removes current entity from collection and layer.
     * @public
     */
    remove() {
        this._layer && this._layer.removeEntity(this);
        this._entityCollection && this._entityCollection.removeEntity(this);
    }

    /**
     * Sets the entity visibility.
     * @public
     * @param {boolean} visibility - Entity visibility.
     */
    setVisibility(visibility) {
        this._visibility = visibility;

        //billboards
        this.billboard && this.billboard.setVisibility(visibility);

        //labels
        this.label && this.label.setVisibility(visibility);

        //shape
        this.shape && this.shape.setVisibility(visibility);

        //polyline
        this.polyline && this.polyline.setVisibility(visibility);

        //geometry
        this.geometry && this.geometry.setVisibility(visibility);

        for (var i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setVisibility(visibility);
        }
    }

    /**
     * Returns entity visibility.
     * @public
     * @returns {boolean} -
     */
    getVisibility() {
        return this._visibility;
    }

    /**
     * Sets entity cartesian position.
     * @public
     * @param {og.math.Vector3} cartesian - Cartesian position in 3d space.
     */
    setCartesian3v(cartesian) {
        this.setCartesian(cartesian.x, cartesian.y, cartesian.z);
    }

    /**
     * Sets entity cartesian position.
     * @public
     * @param {number} x - 3d space X - position.
     * @param {number} y - 3d space Y - position.
     * @param {number} z - 3d space Z - position.
     */
    setCartesian(x, y, z) {

        var p = this._cartesian;

        p.x = x;
        p.y = y;
        p.z = z;

        //billboards
        this.billboard && this.billboard.setPosition3v(p);

        //labels
        this.label && this.label.setPosition3v(p);

        //shape
        this.shape && this.shape.setPosition3v(p);

        for (var i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setCartesian(x, y, z);
        }

        var ec = this._entityCollection;

        if (ec && ec.renderNode && ec.renderNode.ellipsoid) {

            this._lonlat = ec.renderNode.ellipsoid.cartesianToLonLat(p);

            if (Math.abs(this._lonlat.lat) < _mercator_js__WEBPACK_IMPORTED_MODULE_0__["MAX_LAT"]) {
                this._lonlatMerc = this._lonlat.forwardMercator();
            } else {
                this._lonlatMerc = null;
            }
        }

        ec && ec.events.dispatch(ec.events.entitymove, this);
    }

    /**
     * Sets entity cartesian position without moveentity event dispatching.
     * @protected
     * @param {og.math.Vector3} cartesian - Cartesian position in 3d space.
     */
    _setCartesian3vSilent(cartesian) {

        var p = this._cartesian;

        p.x = cartesian.x;
        p.y = cartesian.y;
        p.z = cartesian.z;

        //billboards
        this.billboard && this.billboard.setPosition3v(p);

        //labels
        this.label && this.label.setPosition3v(p);

        //shape
        this.shape && this.shape.setPosition3v(p);

        for (var i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setCartesian(x, y, z);
        }
    }

    /**
     * Gets entity geodetic coordinates.
     * @public
     * @returns {og.LonLat} -
     */
    getLonLat() {
        return this._lonlat.clone();
    }

    /**
     * Sets geodetic coordinates of the entity point object.
     * @public
     * @param {og.LonLat} lonlat - WGS84 coordinates.
     */
    setLonLat(lonlat) {
        var l = this._lonlat;

        l.lon = lonlat.lon;
        l.lat = lonlat.lat;
        l.height = lonlat.height;

        var ec = this._entityCollection;
        if (ec && ec.renderNode && ec.renderNode.ellipsoid) {

            if (Math.abs(lonlat.lat) < _mercator_js__WEBPACK_IMPORTED_MODULE_0__["MAX_LAT"]) {
                this._lonlatMerc = lonlat.forwardMercator();
            } else {
                this._lonlatMerc = null;
            }

            this._cartesian = ec.renderNode.ellipsoid.lonLatToCartesian(lonlat);
            this.setCartesian3v(this._cartesian);
        }
    }

    /**
     * Sets entity altitude over the planet.
     * @public
     * @param {number} altitude - Altitude.
     */
    setAltitude(altitude) {
        this._altitude = altitude;
    }

    /**
     * Returns carteain position.
     * @public
     * @returns {og.math.Vector3} -
     */
    getCartesian() {
        return this._cartesian;
    }

    /**
     * Sets entity billboard.
     * @public
     * @param {og.Billboard} billboard - Billboard object.
     * @returns {og.Billboard} -
     */
    setBillboard(billboard) {
        if (this.billboard) {
            this.billboard.remove();
        }
        this.billboard = billboard;
        this.billboard._entity = this;
        this.billboard.setPosition3v(this._cartesian);
        this.billboard.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection._billboardHandler.add(billboard);
        return billboard;
    }

    /**
     * Sets entity label.
     * @public
     * @param {og.Label} label - Text label.
     * @returns {og.Label} -
     */
    setLabel(label) {
        if (this.label) {
            this.label.remove();
        }
        this.label = label;
        this.label._entity = this;
        this.label.setPosition3v(this._cartesian);
        this.label.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection._labelHandler.add(label);
        return label;
    }

    /**
     * Sets entity shape.
     * @public
     * @param {og.BaseShape} shape - Shape object.
     * @returns {og.Polyline} -
     */
    setShape(shape) {
        if (this.shape) {
            this.shape.remove();
        }
        this.shape = shape;
        this.shape._entity = this;
        this.shape.setPosition3v(this._cartesian);
        this.shape.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection._shapeHandler.add(shape);
        return shape;
    }

    /**
     * Sets entity polyline.
     * @public
     * @param {og.Polyline} polyline - Polyline object.
     * @returns {og.Polyline} -
     */
    setPolyline(polyline) {
        if (this.polyline) {
            this.polyline.remove();
        }
        this.polyline = polyline;
        this.polyline._entity = this;
        this.polyline.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection._polylineHandler.add(polyline);
        return polyline;
    }

    /**
     * Sets entity pointCloud.
     * @public
     * @param {og.PointCloud} pointCloud - PointCloud object.
     * @returns {og.PointCloud} -
     */
    setPointCloud(pointCloud) {
        if (this.pointCloud) {
            this.pointCloud.remove();
        }
        this.pointCloud = pointCloud;
        this.pointCloud._entity = this;
        this.pointCloud.setVisibility(this._visibility);
        this._entityCollection && this._entityCollection._pointCloudHandler.add(pointCloud);
        return pointCloud;
    }

    /**
     * Sets entity geometry.
     * @public
     * @param {og.Geometry} geometry - Geometry object.
     * @returns {og.Geometry} -
     */
    setGeometry(geometry) {
        if (this.geometry) {
            this.geometry.remove();
        }
        this.geometry = geometry;
        this.geometry._entity = this;
        this.geometry.setVisibility(this._visibility);
        this._layer && this._layer.add(this);
        return geometry;
    }

    /**
     * Append child entity.
     * @public
     * @param {og.Entity} entity - Child entity.
     */
    appendChild(entity) {
        entity._entityCollection = this._entityCollection;
        entity._pickingColor = this._pickingColor;
        entity.parent = this;
        this.childrenNodes.push(entity);
        this._entityCollection && this._entityCollection._addRecursively(entity);
    }

    /**
     * Appends entity items(billboard, label etc.) picking color.
     * @public
     */
    setPickingColor() {

        var c = this._pickingColor;

        //billboard
        this.billboard && this.billboard.setPickingColor3v(c);

        //label
        this.label && this.label.setPickingColor3v(c);

        //shape
        this.shape && this.shape.setPickingColor3v(c);

        //polyline
        this.polyline && this.polyline.setPickingColor3v(c);

        for (var i = 0; i < this.childrenNodes.length; i++) {
            this.childrenNodes[i].setPickingColor();
        }
    }

    /**
     * Return geodethic extent.
     * @returns {og.Extent} -
     */
    getExtent() {
        var res;
        var c = this._lonlat;
        if (this.billboard || this.label) {
            res = new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_6__["LonLat"](c.lon, c.lat), new _LonLat_js__WEBPACK_IMPORTED_MODULE_6__["LonLat"](c.lon, c.lat));
        } else {
            res = new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_6__["LonLat"](180.0, 90.0), new _LonLat_js__WEBPACK_IMPORTED_MODULE_6__["LonLat"](-180.0, -90.0));
        }

        var sw = res.southWest,
            ne = res.northEast;

        if (this.polyline) {
            var e = this.polyline.getExtent();
            if (e.southWest.lon < sw.lon) sw.lon = e.southWest.lon;
            if (e.southWest.lat < sw.lat) sw.lat = e.southWest.lat;
            if (e.northEast.lon > ne.lon) ne.lon = e.northEast.lon;
            if (e.northEast.lat > ne.lat) ne.lat = e.northEast.lat;
        }

        if (this.geometry) {
            var e = this.geometry.getExtent();
            if (e.southWest.lon < sw.lon) sw.lon = e.southWest.lon;
            if (e.southWest.lat < sw.lat) sw.lat = e.southWest.lat;
            if (e.northEast.lon > ne.lon) ne.lon = e.northEast.lon;
            if (e.northEast.lat > ne.lat) ne.lat = e.northEast.lat;
        }

        for (var i = 0; i < this.childrenNodes.length; i++) {
            var e = this.childrenNodes[i].getExtent();
            if (e.southWest.lon < sw.lon) sw.lon = e.southWest.lon;
            if (e.southWest.lat < sw.lat) sw.lat = e.southWest.lat;
            if (e.northEast.lon > ne.lon) ne.lon = e.northEast.lon;
            if (e.northEast.lat > ne.lat) ne.lat = e.northEast.lat;
        }

        return res;
    }
};




/***/ }),

/***/ "./src/og/entity/EntityCollection.js":
/*!*******************************************!*\
  !*** ./src/og/entity/EntityCollection.js ***!
  \*******************************************/
/*! exports provided: EntityCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityCollection", function() { return EntityCollection; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BillboardHandler.js */ "./src/og/entity/BillboardHandler.js");
/* harmony import */ var _Events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Events.js */ "./src/og/Events.js");
/* harmony import */ var _LabelHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LabelHandler.js */ "./src/og/entity/LabelHandler.js");
/* harmony import */ var _PolylineHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PolylineHandler.js */ "./src/og/entity/PolylineHandler.js");
/* harmony import */ var _PointCloudHandler_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PointCloudHandler.js */ "./src/og/entity/PointCloudHandler.js");
/* harmony import */ var _ShapeHandler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShapeHandler.js */ "./src/og/entity/ShapeHandler.js");
/**
 * @module og/entity/EntityCollection
 */











/**
 * An observable collection of og.Entity instances where each entity has a unique id.
 * Entity collection provide handlers for an each type of entity like billboard, label or 3ds object.
 * @constructor
 * @param {Object} [options] - Entity options:
 * @param {Array.<og.Entity>} [options.entities] - Entities array.
 * @param {boolean} [options.visibility=true] - Entity visibility.
 * @param {Array.<number,number,number>} [options.scaleByDistance] - Entity scale by distance parameters.
 * First index - near distance to the entity, after entity becomes full scale.
 * Second index - far distance to the entity, when entity becomes zero scale.
 * Third index - far distance to the entity, when entity becomes invisible.
 * @param {number} [options.opacity] - Entity global opacity.
 * @param {boolean} [options.pickingEnabled=true] - Entity picking enable.
 * @fires og.EntityCollection#entitymove
 * @fires og.EntityCollection#draw
 * @fires og.EntityCollection#drawend
 * @fires og.EntityCollection#add
 * @fires og.EntityCollection#remove
 * @fires og.EntityCollection#entityadd
 * @fires og.EntityCollection#entityremove
 * @fires og.EntityCollection#visibilitychange
 * @fires og.EntityCollection#mousemove
 * @fires og.EntityCollection#mouseenter
 * @fires og.EntityCollection#mouseleave
 * @fires og.EntityCollection#lclick
 * @fires og.EntityCollection#rclick
 * @fires og.EntityCollection#mclick
 * @fires og.EntityCollection#ldblclick
 * @fires og.EntityCollection#rdblclick
 * @fires og.EntityCollection#mdblclick
 * @fires og.EntityCollection#lup
 * @fires og.EntityCollection#rup
 * @fires og.EntityCollection#mup
 * @fires og.EntityCollection#ldown
 * @fires og.EntityCollection#rdown
 * @fires og.EntityCollection#mdown
 * @fires og.EntityCollection#lhold
 * @fires og.EntityCollection#rhold
 * @fires og.EntityCollection#mhold
 * @fires og.EntityCollection#mousewheel
 * @fires og.EntityCollection#touchmove
 * @fires og.EntityCollection#touchstart
 * @fires og.EntityCollection#touchend
 * @fires og.EntityCollection#doubletouch
 * @fires og.EntityCollection#touchleave
 * @fires og.EntityCollection#touchenter
 */
class EntityCollection {
    constructor(options) {

        options = options || {};

        /**
         * Unic identifier.
         * @public
         * @readonly
         */
        this.id = EntityCollection.__staticCounter++;

        /**
         * Render node collections array index.
         * @protected
         * @type {number}
         */
        this._renderNodeIndex = -1;

        /**
         * Render node context.
         * @public
         * @type {og.scene.RenderNode}
         */
        this.renderNode = null;

        /**
         * Visibility option.
         * @protected
         * @type {boolean}
         */
        this._visibility = options.visibility == undefined ? true : options.visibility;

        /**
         * Billboards handler
         * @public
         * @type {og.BillboardHandler}
         */
        this.billboardHandler = new _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_1__["BillboardHandler"](this);

        /**
         * Labels handler
         * @public
         * @type {og.LabelHandler}
         */
        this.labelHandler = new _LabelHandler_js__WEBPACK_IMPORTED_MODULE_3__["LabelHandler"](this);

        /**
         * Shape handler
         * @public
         * @type {og.ShapeHandler}
         */
        this.shapeHandler = new _ShapeHandler_js__WEBPACK_IMPORTED_MODULE_6__["ShapeHandler"](this);

        /**
         * Polyline handler
         * @public
         * @type {og.PolylineHandler}
         */
        this.polylineHandler = new _PolylineHandler_js__WEBPACK_IMPORTED_MODULE_4__["PolylineHandler"](this);

        /**
         * PointCloud handler
         * @public
         * @type {og.PointCloudHandler}
         */
        this.pointCloudHandler = new _PointCloudHandler_js__WEBPACK_IMPORTED_MODULE_5__["PointCloudHandler"](this);
        //
        //...

        if (options.pickingEnabled != undefined) {
            this.setPickingEnabled(options.pickingEnabled);
        }

        /**
         * Entities array.
         * @protected
         * @type {Array.<og.Entity>}
         */
        this._entities = options.entities || [];

        /**
         * First index - near distance to the entity, after entity becomes full scale.
         * Second index - far distance to the entity, when entity becomes zero scale.
         * Third index - far distance to the entity, when entity becomes invisible.
         * @public
         * @type {Array.<number,number,number>}
         */
        this.scaleByDistance = options.scaleByDistance || [_math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"], _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"], _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"]];

        /**
         * Global opacity.
         * @protected
         * @type {number}
         */
        this._opacity = options.opacity == undefined ? 1.0 : options.opacity;

        /**
         * Opacity state during the animated opacity.
         * @protected
         * @type {number}
         */
        this._animatedOpacity = this._opacity;

        /**
         * Entity collection events handler.
         * @public
         * @type {og.Events}
         */
        this.events = new _Events_js__WEBPACK_IMPORTED_MODULE_2__["Events"](EVENT_NAMES);

        //initialize current entities
        this.addEntities(this._entities);
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    /**
     * Sets collection visibility.
     * @public
     * @param {boolean} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this._visibility = visibility;
        this._animatedOpacity = this._opacity * (visibility ? 1 : 0);
        this.events.dispatch(this.events.visibilitychange, this);
    }

    /**
     * Returns collection visibility.
     * @public
     * @returns {boolean}
     */
    getVisibility() {
        return this._visibility;
    }

    /**
     * Sets collection opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    setOpacity(opacity) {
        this._opacity = opacity;
    }

    /**
     * Sets collection picking ability.
     * @public
     * @param {boolean} enable - Picking enable flag.
     */
    setPickingEnabled(enable) {
        this.billboardHandler.pickingEnabled = enable;
        this.labelHandler.pickingEnabled = enable;
        this.polylineHandler.pickingEnabled = enable;
        this.shapeHandler.pickingEnabled = enable;
        this.pointCloudHandler.pickingEnabled = enable;
    }

    /**
     * Gets collection opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    getOpacity() {
        return this._opacity;
    }

    /**
     * Sets scale by distance parameters.
     * @public
     * @param {number} near - Full scale entity distance.
     * @param {number} far - Zerol scale entity distance.
     * @param {number} [farInvisible] - Entity visibility distance.
     */
    setScaleByDistance(near, far, farInvisible) {
        this.scaleByDistance[0] = near;
        this.scaleByDistance[1] = far;
        this.scaleByDistance[2] = farInvisible || _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"];
    }

    _addRecursively(entity) {

        //billboard
        entity.billboard && this.billboardHandler.add(entity.billboard);

        //label
        entity.label && this.labelHandler.add(entity.label);

        //shape
        entity.shape && this.shapeHandler.add(entity.shape);

        //polyline
        entity.polyline && this.polylineHandler.add(entity.polyline);

        //pointCloud
        entity.pointCloud && this.pointCloudHandler.add(entity.pointCloud);

        this.events.dispatch(this.events.entityadd, entity);

        for (var i = 0; i < entity.childrenNodes.length; i++) {
            entity.childrenNodes[i]._entityCollection = this;
            entity.childrenNodes[i]._entityCollectionIndex = entity._entityCollectionIndex;
            entity.childrenNodes[i]._pickingColor = entity._pickingColor;
            this._addRecursively(entity.childrenNodes[i]);
        }
    }

    /**
     * Adds entity to the collection and returns collection.
     * @public
     * @param {og.Entity} entity - Entity.
     * @returns {og.EntityCollection}
     */
    add(entity) {
        if (!entity._entityCollection) {
            entity._entityCollection = this;
            entity._entityCollectionIndex = this._entities.length;
            this._entities.push(entity);
            var rn = this.renderNode;
            if (rn) {
                rn.renderer && rn.renderer.assignPickingColor(entity);
                rn.ellipsoid && entity._lonlat && entity.setCartesian3v(rn.ellipsoid.lonLatToCartesian(entity._lonlat));
            }
            this._addRecursively(entity);
        }
        return this;
    }

    /**
     * Adds entities array to the collection and returns collection.
     * @public
     * @param {Array.<og.Entity>} entities - Entities array.
     * @returns {og.EntityCollection}
     */
    addEntities(entities) {
        var i = entities.length;
        while (i--) {
            this.add(entities[i]);
        }
        return this;
    }

    /**
     * Returns true if the entity belongs this collection, otherwise returns false.
     * @public
     * @param {og.Entity} entity - Entity.
     * @returns {boolean}
     */
    belongs(entity) {
        return (entity._entityCollection && this._renderNodeIndex == entity._entityCollection._renderNodeIndex);
    }

    _removeRecursively(entity) {
        entity._entityCollection = null;
        entity._entityCollectionIndex = -1;

        //billboard
        entity.billboard && this.billboardHandler.remove(entity.billboard);

        //label
        entity.label && this.labelHandler.remove(entity.label);

        //shape
        entity.shape && this.shapeHandler.remove(entity.shape);

        //polyline
        entity.polyline && this.polylineHandler.remove(entity.polyline);

        //pointCloud
        entity.pointCloud && this.pointCloudHandler.remove(entity.pointCloud);

        for (var i = 0; i < entity.childrenNodes.length; i++) {
            this._removeRecursively(entity.childrenNodes[i]);
        }
    }

    /**
     * Removes entity from this collection.
     * @public
     * @param {og.Entity} entity - Entity to remove.
     */
    removeEntity(entity) {
        this._entities.splice(entity._entityCollectionIndex, 1);
        this.reindexEntitiesArray(entity._entityCollectionIndex);

        //clear picking color
        if (this.renderNode && this.renderNode.renderer) {
            this.renderNode.renderer.clearPickingColor(entity);
            entity._pickingColor.clear();
        }

        if (this.belongs(entity)) {
            this._removeRecursively(entity);
        }

        this.events.dispatch(this.events.entityremove, entity);
    }

    _removeEntitySilent(entity) {
        this._entities.splice(entity._entityCollectionIndex, 1);
        this.reindexEntitiesArray(entity._entityCollectionIndex);

        //clear picking color
        if (this.renderNode && this.renderNode.renderer) {
            this.renderNode.renderer.clearPickingColor(entity);
            entity._pickingColor.clear();
        }

        if (this.belongs(entity)) {
            this._removeRecursively(entity);
        }
    }

    /**
     * Creates or refresh collected entities picking color.
     * @public
     */
    createPickingColors() {
        var e = this._entities;
        for (var i = 0; i < e.length; i++) {
            if (!e[i].parent) {
                this.renderNode.renderer.assignPickingColor(e[i]);
                e[i].setPickingColor();
            }
        }
    }

    /**
     * Refresh collected entities indexes from startIndex entitytes collection array position.
     * @public
     * @param {number} startIndex - Entities collection array index.
     */
    reindexEntitiesArray(startIndex) {
        var e = this._entities;
        for (var i = startIndex; i < e.length; i++) {
            e[i]._entityCollectionIndex = i;
        }
    }

    /**
     * Adds this collection to render node.
     * @public
     * @param {og.scene.RenderNode} renderNode - Render node.
     * @param {boolean} [isHidden] - Uses in vector layers that render in planet render specific function.
     * @returns {og.EntityCollection}
     */
    addTo(renderNode, isHidden) {
        if (!this.renderNode) {
            this.renderNode = renderNode;
            if (!isHidden) {
                this._renderNodeIndex = renderNode.entityCollections.length;
                renderNode.entityCollections.push(this);
            }
            renderNode.ellipsoid && this._updateGeodeticCoordinates(renderNode.ellipsoid);
            this.setRenderer(renderNode.renderer);

            this.shapeHandler.setRenderNode(renderNode);
            this.polylineHandler.setRenderNode(renderNode);
            this.pointCloudHandler.setRenderNode(renderNode);

            this.events.dispatch(this.events.add, this);
        }
        return this;
    }

    /**
     * Updates coordiantes all lonLat entities in collection after collecction attached to the planet node.
     * @private
     * @param {og.Ellipsoid} ellipsoid - Globe ellipsoid.
     */
    _updateGeodeticCoordinates(ellipsoid) {
        var e = this._entities;
        var i = e.length;
        while (i--) {
            var ei = e[i];
            ei._lonlat && ei.setCartesian3v(ellipsoid.lonLatToCartesian(ei._lonlat));
        }
    }

    /**
     * Sets renderer. Used in renderer initialization, when entity collection starts before renderer has initialized.
     * @public
     * @param {og.Renderer} renderer - Renderer.
     */
    setRenderer(renderer) {
        //todo: better to replace to setRenderNode function
        if (renderer) {
            this.billboardHandler.setRenderer(renderer);
            this.labelHandler.setRenderer(renderer);
            this.updateBillboardsTextureAtlas();
            this.updateLabelsFontAtlas();
            this.createPickingColors();
        }
    }

    /**
     * Updates billboard texture atlas.
     * @public
     */
    updateBillboardsTextureAtlas() {
        var b = this.billboardHandler._billboards;
        for (var i = 0; i < b.length; i++) {
            b[i].setSrc(b[i]._src);
        }
    }

    /**
     * Updates labels font atlas.
     * @public
     */
    updateLabelsFontAtlas() {
        if (this.renderNode) {
            var l = this.labelHandler._billboards;
            for (var i = 0; i < l.length; i++) {
                l[i].assignFontAtlas(this.renderNode.fontAtlas);
            }
        }
    }

    /**
     * Removes collection from render node.
     * @public
     */
    remove() {
        if (this.renderNode) {
            if (this._renderNodeIndex != -1) {
                this.renderNode.entityCollections.splice(this._renderNodeIndex, 1);
                //reindex in the renderNode
                for (var i = this._renderNodeIndex; i < this.renderNode.entityCollections.length; i++) {
                    this.renderNode.entityCollections._renderNodeIndex = i;
                }
            }
            this.renderNode = null;
            this._renderNodeIndex = -1;
            this.events.dispatch(this.events.remove, this);
        }
    }

    /**
     * Gets entities.
     * @public
     * @returns {Array.<og.Entity>}
     */
    getEntities() {
        return [].concat(this._entities);
    }

    /**
     * Safety entities loop.
     * @public
     * @param {function} callback - Entity callback.
     */
    each(callback) {
        var i = this._entities.length;
        while (i--) {
            var ei = this._entities[i];
            ei && callback(ei);
        }
    }

    /**
     * Removes all entities from colection and clear handlers.
     * @public
     */
    clear() {

        //TODO: Optimize by replace delete
        //code to the clearEntity function.
        this.billboardHandler.clear();
        this.labelHandler.clear();
        this.shapeHandler.clear();
        this.polylineHandler.clear();
        this.pointCloudHandler.clear();

        var i = this._entities.length;
        while (i--) {
            var ei = this._entities[i];
            if (this.renderNode && this.renderNode.renderer) {
                this.renderNode.renderer.clearPickingColor(ei);
                ei._pickingColor.clear();
            }
            this._clearEntity(ei);
        }
        this._entities.length = 0;
        this._entities = [];
    }

    /**
     * Clears entity recursevely.
     * @private
     * @param {og.Entity} entity - Entity to clear.
     */
    _clearEntity(entity) {
        entity._entityCollection = null;
        entity._entityCollectionIndex = -1;
        for (var i = 0; i < entity.childrenNodes.length; i++) {
            this._clearEntity(entity.childrenNodes[i]);
        }
    }
};


const EVENT_NAMES = [
    /**
     * Triggered when entity has moved.
     * @event og.EntityCollection#entitymove
     */
    "entitymove",

    /**
     * Triggered when collection entities begin draw.
     * @event og.EntityCollection#draw
     */
    "draw",

    /**
     * Triggered after collection has drawn.
     * @event og.EntityCollection#drawend
     */
    "drawend",

    /**
     * Triggered when added to the render node.
     * @event og.EntityCollection#add
     */
    "add",

    /**
     * Triggered when removed from the render node.
     * @event og.EntityCollection#remove
     */
    "remove",

    /**
     * Triggered when new entity added to the collection.
     * @event og.EntityCollection#entityadd
     */
    "entityadd",

    /**
     * Triggered when entity removes from the collection.
     * @event og.EntityCollection#entityremove
     */
    "entityremove",

    /**
     * Triggered when visibility changes.
     * @event og.EntityCollection#visibilitychange
     */
    "visibilitychange",

    /**
     * Triggered when mouse moves over the entity.
     * @event og.EntityCollection#mousemove
     */
    "mousemove",

    /**
     * Triggered when mouse has entered over the entity.
     * @event og.EntityCollection#mouseenter
     */
    "mouseenter",

    /**
     * Triggered when mouse leaves the entity.
     * @event og.EntityCollection#mouseleave
     */
    "mouseleave",

    /**
     * Mouse left button clicked.
     * @event og.EntityCollection#lclick
     */
    "lclick",

    /**
     * Mouse right button clicked.
     * @event og.EntityCollection#rclick
     */
    "rclick",

    /**
     * Mouse right button clicked.
     * @event og.EntityCollection#mclick
     */
    "mclick",

    /**
     * Mouse left button double click.
     * @event og.EntityCollection#ldblclick
     */
    "ldblclick",

    /**
     * Mouse right button double click.
     * @event og.EntityCollection#rdblclick
     */
    "rdblclick",

    /**
     * Mouse middle button double click.
     * @event og.EntityCollection#mdblclick
     */
    "mdblclick",

    /**
     * Mouse left button up(stop pressing).
     * @event og.EntityCollection#lup
     */
    "lup",

    /**
     * Mouse right button up(stop pressing).
     * @event og.EntityCollection#rup
     */
    "rup",

    /**
     * Mouse middle button up(stop pressing).
     * @event og.EntityCollection#mup
     */
    "mup",

    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.EntityCollection#ldown
     */
    "ldown",

    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.EntityCollection#rdown
     */
    "rdown",

    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.EntityCollection#mdown
     */
    "mdown",

    /**
     * Mouse left button is pressing.
     * @event og.EntityCollection#lhold
     */
    "lhold",

    /**
     * Mouse right button is pressing.
     * @event og.EntityCollection#rhold
     */
    "rhold",

    /**
     * Mouse middle button is pressing.
     * @event og.EntityCollection#mhold
     */
    "mhold",

    /**
     * Mouse wheel is rotated.
     * @event og.EntityCollection#mousewheel
     */
    "mousewheel",

    /**
     * Triggered when touch moves over the entity.
     * @event og.EntityCollection#touchmove
     */
    "touchmove",

    /**
     * Triggered when entity begins to touch.
     * @event og.EntityCollection#touchstart
     */
    "touchstart",

    /**
     * Triggered when entity ends touching.
     * @event og.EntityCollection#touchend
     */
    "touchend",

    /**
     * Triggered entity double touch.
     * @event og.EntityCollection#doubletouch
     */
    "doubletouch",

    /**
     * Triggered when touching leaves entity.
     * @event og.EntityCollection#touchleave
     */
    "touchleave",

    /**
     * Triggered when touch enters over the entity.
     * @event og.EntityCollection#touchenter
     */
    "touchenter"
];



/***/ }),

/***/ "./src/og/entity/Geometry.js":
/*!***********************************!*\
  !*** ./src/og/entity/Geometry.js ***!
  \***********************************/
/*! exports provided: Geometry, GeometryType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryType", function() { return GeometryType; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/**
 * @module og/entity/Geometry
 */








const GeometryType = {
    POINT: 1,
    LINESTRING: 2,
    POLYGON: 3,
    MULTIPOLYGON: 4,
    MULTILINESTRING: 5
};

class Geometry {
    constructor(options) {
        this._id = Geometry._staticCounter++;

        options = options || {};
        options.style = options.style || {};

        /**
         * Entity instance that holds this geometry.
         * @protected
         * @type {og.Entity}
         */
        this._entity = null;

        this._handler = null;
        this._handlerIndex = -1;

        //Polygon
        this._polyVerticesMerc = [];
        this._polyVerticesLength = -1;
        this._polyIndexesLength = -1;
        this._polyVerticesHandlerIndex = -1;
        this._polyIndexesHandlerIndex = -1;

        //Line(Linestring and polygon's stroke(s)
        this._lineVerticesMerc = [];
        this._lineVerticesLength = -1;
        this._lineOrdersLength = -1;
        this._lineIndexesLength = -1;
        this._lineColorsLength = -1;
        this._lineThicknessLength = -1;
        this._lineVerticesHandlerIndex = -1;
        this._lineOrdersHandlerIndex = -1;
        this._lineIndexesHandlerIndex = -1;
        this._lineThicknessHandlerIndex = -1;
        this._lineColorsHandlerIndex = -1;

        this._type = options.type && Geometry.getType(options.type) || GeometryType.POINT;
        this._coordinates = [];
        this._extent = Geometry.getExtent({
            'type': options.type || "Point",
            'coordinates': options.coordinates || []
        }, this._coordinates);

        this._style = options.style || {};
        this._style.fillColor = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGBA"](options.style.fillColor, new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_2__["Vec4"](0.19, 0.62, 0.85, 0.4));
        this._style.lineColor = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGBA"](options.style.lineColor, new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_2__["Vec4"](0.19, 0.62, 0.85, 1));
        this._style.strokeColor = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGBA"](options.style.strokeColor, new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_2__["Vec4"](1, 1, 1, 0.95));
        this._style.lineWidth = options.style.lineWidth || 3;
        this._style.strokeWidth = options.style.strokeWidth || 0;

        this._visibility = options.visibility || true;

        //optimization flag for picking mask rendering pass
        this._pickingReady = false;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    static getType(typeStr) {
        return GeometryType[typeStr.toUpperCase()];
    }

    /**
     * Returns geometry feature extent.
     @static
     @param {Object} geometryObj - GeoJSON style geometry feature.
     @param {Array} outoordinates - Geometry feature coordinates clone.
     @returns {og.Extent}
     */
    static getExtent(geometryObj, outCoordinates) {
        var res = new _Extent_js__WEBPACK_IMPORTED_MODULE_1__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](180.0, 90.0), new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](-180.0, -90.0));
        var t = Geometry.getType(geometryObj.type);

        if (t === GeometryType.POINT) {

            var lon = res.coordinates[0],
                lat = res.coordinates[1];
            res.southWest.lon = lon;
            res.southWest.lat = lat;
            res.northEast.lon = lon;
            res.northEast.lat = lat;
            outCoordinates && (outCoordinates[0] = lon) && (outCoordinates[1] = lat);

        } else if (t === GeometryType.LINESTRING) {

            var c = geometryObj.coordinates;
            for (var i = 0; i < c.length; i++) {
                var lon = c[i][0],
                    lat = c[i][1];
                if (lon < res.southWest.lon) res.southWest.lon = lon;
                if (lat < res.southWest.lat) res.southWest.lat = lat;
                if (lon > res.northEast.lon) res.northEast.lon = lon;
                if (lat > res.northEast.lat) res.northEast.lat = lat;
                outCoordinates && (outCoordinates[i] = [lon, lat]);
            }

        } else if (t === GeometryType.POLYGON) {

            var c = geometryObj.coordinates;
            for (var i = 0; i < c.length; i++) {
                var ci = c[i];
                outCoordinates && (outCoordinates[i] = []);
                for (var j = 0; j < ci.length; j++) {
                    var cij = ci[j];
                    var lon = cij[0],
                        lat = cij[1];
                    if (lon < res.southWest.lon) res.southWest.lon = lon;
                    if (lat < res.southWest.lat) res.southWest.lat = lat;
                    if (lon > res.northEast.lon) res.northEast.lon = lon;
                    if (lat > res.northEast.lat) res.northEast.lat = lat;
                    outCoordinates && (outCoordinates[i][j] = [lon, lat]);
                }
            }

        } else if (t === GeometryType.MULTIPOLYGON) {

            var p = geometryObj.coordinates;
            for (var i = 0; i < p.length; i++) {
                var pi = p[i];
                outCoordinates && (outCoordinates[i] = []);
                for (var j = 0; j < pi.length; j++) {
                    var pij = pi[j];
                    outCoordinates && (outCoordinates[i][j] = []);
                    for (var k = 0; k < pij.length; k++) {
                        var pijk = pij[k];
                        var lon = pijk[0],
                            lat = pijk[1];
                        if (lon < res.southWest.lon) res.southWest.lon = lon;
                        if (lat < res.southWest.lat) res.southWest.lat = lat;
                        if (lon > res.northEast.lon) res.northEast.lon = lon;
                        if (lat > res.northEast.lat) res.northEast.lat = lat;
                        outCoordinates && (outCoordinates[i][j][k] = [lon, lat]);
                    }
                }
            }

        } else if (t === GeometryType.MULTILINESTRING) {

            var c = geometryObj.coordinates;
            for (var i = 0; i < c.length; i++) {
                var ci = c[i];
                outCoordinates && (outCoordinates[i] = []);
                for (var j = 0; j < ci.length; j++) {
                    var cij = ci[j];
                    var lon = cij[0],
                        lat = cij[1];
                    if (lon < res.southWest.lon) res.southWest.lon = lon;
                    if (lat < res.southWest.lat) res.southWest.lat = lat;
                    if (lon > res.northEast.lon) res.northEast.lon = lon;
                    if (lat > res.northEast.lat) res.northEast.lat = lat;
                    outCoordinates && (outCoordinates[i][j] = [lon, lat]);
                }
            }

        } else {
            res.southWest.lon = res.southWest.lat = res.northEast.lon = res.northEast.lat = 0.0;
            outCoordinates && (outCoordinates[0] = lon) && (outCoordinates[1] = lat);
        }
        return res;
    }

    /**
     */
    setGeometry(geoJson) {
        var h = this._handler;
        this.remove();
        this._type = Geometry.getType(geoJson.type || "Point");
        this._extent = Geometry.getExtent(geoJson, this._coordinates);
        h.add(this);
        return this;
    }

    setFillColor(r, g, b, a) {
        var c = this._style.fillColor;
        if (c.w === 0.0 && a !== 0.0 || c.w !== 0.0 && a === 0.0) {
            this._pickingReady = false;
        }
        c.x = r;
        c.y = g;
        c.z = b;
        c.w = a;
        this._handler && this._handler.setPolyColorArr(this, c);
        return this;
    }

    setFillColor4v(rgba) {
        return this.setFillColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }

    setStrokeColor(r, g, b, a) {
        var c = this._style.strokeColor;
        if (c.w === 0.0 && a !== 0.0 || c.w !== 0.0 && a === 0.0) {
            this._pickingReady = false;
        }
        c.x = r;
        c.y = g;
        c.z = b;
        c.w = a;
        this._handler && this._handler.setStrokeColorArr(this, c);
        return this;
    }

    setLineColor(r, g, b, a) {
        var c = this._style.lineColor;
        if (c.w === 0.0 && a !== 0.0 || c.w !== 0.0 && a === 0.0) {
            this._pickingReady = false;
        }
        c.x = r;
        c.y = g;
        c.z = b;
        c.w = a;
        this._handler && this._handler.setLineColorArr(this, c);
        return this;
    }

    setStrokeColor4v(rgba) {
        return this.setStrokeColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }

    setLineColor4v(rgba) {
        return this.setLineColor(rgba.x, rgba.y, rgba.z, rgba.w);
    }

    setStrokeOpacity(opacity) {
        var c = this._style.strokeColor;
        c.w = opacity;
        return this.setStrokeColor(c.x, c.y, c.z, opacity);
    }

    setLineOpacity(opacity) {
        var c = this._style.lineColor;
        c.w = opacity;
        return this.setLineColor(c.x, c.y, c.z, opacity);
    }

    setStrokeWidth(width) {
        this._style.strokeWidth = width;
        this._pickingReady = false;
        this._handler && this._handler.setLineStrokeArr(this, width);
        return this;
    }

    bringToFront() {
        this._handler && this._handler.bringToFront(this);
        return this;
    }

    setLineWidth(width) {
        this._style.lineWidth = width;
        this._pickingReady = false;
        this._handler && this._handler.setLineThicknessArr(this, width);
        return this;
    }

    setFillOpacity(opacity) {
        var c = this._style.fillColor;
        if (c.w === 0.0 && opacity !== 0.0 || c.w !== 0.0 && opacity === 0.0) {
            this._pickingReady = false;
        }
        c.w = opacity;
        this._handler && this._handler.setPolyColorArr(this, c);
        return this;
    }

    setVisibility(visibility) {
        this._visibility = visibility;
        this._handler && this._handler.setGeometryVisibility(this);
        return this;
    }

    getVisibility() {
        return this._visibility;
    }

    remove() {
        this._handler && this._handler.remove(this);
    }

    etExtent() {
        return this._extent.clone();
    }

    getType() {
        return this._type;
    }
};




/***/ }),

/***/ "./src/og/entity/GeometryHandler.js":
/*!******************************************!*\
  !*** ./src/og/entity/GeometryHandler.js ***!
  \******************************************/
/*! exports provided: GeometryHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryHandler", function() { return GeometryHandler; });
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _utils_earcut_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/earcut.js */ "./src/og/utils/earcut.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Geometry.js */ "./src/og/entity/Geometry.js");
/**
 * @module og/entity/GeometryHandler
 */








const POLYVERTICES_BUFFER = 0;
const POLYINDEXES_BUFFER = 1;
const POLYCOLORS_BUFFER = 2;
const LINEVERTICES_BUFFER = 3;
const LINEINDEXES_BUFFER = 4;
const LINEORDERS_BUFFER = 5;
const LINECOLORS_BUFFER = 6;
const LINETHICKNESS_BUFFER = 7;
const LINESTROKES_BUFFER = 8;
const LINESTROKECOLORS_BUFFER = 9;
const POLYPICKINGCOLORS_BUFFER = 10;
const LINEPICKINGCOLORS_BUFFER = 11;

class GeometryHandler {
    constructor(layer) {
        this.__staticId = GeometryHandler._staticCounter++;

        this._layer = layer;

        this._handler = null;

        this._geometries = [];

        this._updatedGeometryArr = [];
        this._updatedGeometry = {};

        this._removeGeometryExtentArr = [];
        this._removeGeometryExtents = {};

        //Polygon arrays
        this._polyVerticesMerc = [];
        this._polyColors = [];
        this._polyPickingColors = [];
        this._polyIndexes = [];

        //Line arrays
        this._lineVerticesMerc = [];
        this._lineOrders = [];
        this._lineIndexes = [];
        this._lineColors = [];
        this._linePickingColors = [];
        this._lineThickness = [];
        this._lineStrokes = [];
        this._lineStrokeColors = [];

        //Buffers
        this._polyVerticesBufferMerc = null;
        this._polyColorsBuffer = null;
        this._polyPickingColorsBuffer = null;
        this._polyIndexesBuffer = null;

        this._lineVerticesBufferMerc = null;
        this._lineColorsBuffer = null;
        this._linePickingColorsBuffer = null;
        this._lineThicknessBuffer = null;
        this._lineStrokesBuffer = null;
        this._lineStrokeColorsBuffer = null;
        this._lineOrdersBuffer = null;
        this._lineIndexesBuffer = null;

        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[POLYVERTICES_BUFFER] = this.createPolyVerticesBuffer;
        this._buffersUpdateCallbacks[POLYINDEXES_BUFFER] = this.createPolyIndexesBuffer;
        this._buffersUpdateCallbacks[POLYCOLORS_BUFFER] = this.createPolyColorsBuffer;
        this._buffersUpdateCallbacks[LINEVERTICES_BUFFER] = this.createLineVerticesBuffer;
        this._buffersUpdateCallbacks[LINEINDEXES_BUFFER] = this.createLineIndexesBuffer;
        this._buffersUpdateCallbacks[LINEORDERS_BUFFER] = this.createLineOrdersBuffer;
        this._buffersUpdateCallbacks[LINECOLORS_BUFFER] = this.createLineColorsBuffer;
        this._buffersUpdateCallbacks[LINETHICKNESS_BUFFER] = this.createLineThicknessBuffer;
        this._buffersUpdateCallbacks[LINESTROKES_BUFFER] = this.createLineStrokesBuffer;
        this._buffersUpdateCallbacks[LINESTROKECOLORS_BUFFER] = this.createLineStrokeColorsBuffer;
        this._buffersUpdateCallbacks[POLYPICKINGCOLORS_BUFFER] = this.createPolyPickingColorsBuffer;
        this._buffersUpdateCallbacks[LINEPICKINGCOLORS_BUFFER] = this.createLinePickingColorsBuffer;

        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    static appendLineData(pathArr, isClosed, color, pickingColor, thickness, strokeColor, strokeSize,
        outVertices, outOrders, outIndexes, outColors, outPickingColors, outThickness, outStrokeColors, outStrokes,
        outVertices2) {
        var index = 0;

        if (outIndexes.length > 0) {
            index = outIndexes[outIndexes.length - 5] + 9;
            outIndexes.push(index, index);
        } else {
            outIndexes.push(0, 0);
        }

        var t = thickness,
            c = [color.x, color.y, color.z, color.w],
            s = strokeSize,
            sc = [strokeColor.x, strokeColor.y, strokeColor.z, strokeColor.w],
            p = [pickingColor.x, pickingColor.y, pickingColor.z, 1.0];

        for (var j = 0; j < pathArr.length; j++) {
            var path = pathArr[j];
            var startIndex = index;
            var last;
            if (isClosed) {
                last = path[path.length - 1];
            } else {
                var p0 = path[0],
                    p1 = path[1];
                last = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
            }
            outVertices.push(last[0], last[1], last[0], last[1], last[0], last[1], last[0], last[1]);
            outVertices2.push(last[0], last[1], last[0], last[1], last[0], last[1], last[0], last[1]);
            outOrders.push(1, -1, 2, -2);

            outThickness.push(t, t, t, t);
            outStrokes.push(s, s, s, s);
            outColors.push(c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3]);
            outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
            outPickingColors.push(p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3]);

            for (var i = 0; i < path.length; i++) {
                var cur = path[i];
                outVertices.push(cur[0], cur[1], cur[0], cur[1], cur[0], cur[1], cur[0], cur[1]);
                outVertices2.push(cur[0], cur[1], cur[0], cur[1], cur[0], cur[1], cur[0], cur[1]);
                outOrders.push(1, -1, 2, -2);
                outThickness.push(t, t, t, t);
                outStrokes.push(s, s, s, s);
                outColors.push(c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3]);
                outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
                outPickingColors.push(p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3]);
                outIndexes.push(index++, index++, index++, index++);
            }

            var first;
            if (isClosed) {
                first = path[0];
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            } else {
                var p0 = path[path.length - 1],
                    p1 = path[path.length - 2];
                first = [p0[0] + p0[0] - p1[0], p0[1] + p0[1] - p1[1]];
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }
            outVertices.push(first[0], first[1], first[0], first[1], first[0], first[1], first[0], first[1]);
            outVertices2.push(first[0], first[1], first[0], first[1], first[0], first[1], first[0], first[1]);
            outOrders.push(1, -1, 2, -2);
            outThickness.push(t, t, t, t);
            outStrokes.push(s, s, s, s);
            outColors.push(c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3], c[0], c[1], c[2], c[3]);
            outStrokeColors.push(sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3], sc[0], sc[1], sc[2], sc[3]);
            outPickingColors.push(p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3], p[0], p[1], p[2], p[3]);

            if (j < pathArr.length - 1) {
                index += 8;
                outIndexes.push(index, index);
            }
        }
    }

    assignHandler(handler) {
        this._handler = handler;
        this.refresh();
    }

    /**
     * @public
     * @param {og.Geometry} geometry - Geometry object.
     */
    add(geometry) {
        //
        // Triangulates polygon and sets geometry data.
        if (geometry._handlerIndex === -1) {
            geometry._handler = this;
            geometry._handlerIndex = this._geometries.length;
            this._geometries.push(geometry);

            var pickingColor = geometry._entity._pickingColor.scaleTo(1 / 255);

            geometry._polyVerticesMerc = [];
            geometry._lineVerticesMerc = [];

            if (geometry._type === _Geometry_js__WEBPACK_IMPORTED_MODULE_3__["GeometryType"].POLYGON) {

                var coordinates = geometry._coordinates;
                var ci = [];
                for (var j = 0; j < coordinates.length; j++) {
                    ci[j] = [];
                    for (var k = 0; k < coordinates[j].length; k++) {
                        ci[j][k] = [_mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lon"](coordinates[j][k][0]), _mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lat"](coordinates[j][k][1])];
                    }
                }

                var data = _utils_earcut_js__WEBPACK_IMPORTED_MODULE_2__["earcut"].flatten(ci);
                var indexes = Object(_utils_earcut_js__WEBPACK_IMPORTED_MODULE_2__["earcut"])(data.vertices, data.holes, 2);

                geometry._polyVerticesMerc = data.vertices;
                geometry._polyVerticesHandlerIndex = this._polyVerticesMerc.length;
                geometry._polyIndexesHandlerIndex = this._polyIndexes.length;

                this._polyVerticesMerc.push.apply(this._polyVerticesMerc, data.vertices);

                for (var i = 0; i < indexes.length; i++) {
                    this._polyIndexes.push(indexes[i] + geometry._polyVerticesHandlerIndex * 0.5);
                }

                var color = geometry._style.fillColor;
                for (var i = 0; i < data.vertices.length * 0.5; i++) {
                    this._polyColors.push(color.x, color.y, color.z, color.w);
                    this._polyPickingColors.push(pickingColor.x, pickingColor.y, pickingColor.z, 1.0);
                }

                geometry._polyVerticesLength = data.vertices.length;
                geometry._polyIndexesLength = indexes.length;

                //Creates polygon stroke data
                geometry._lineVerticesHandlerIndex = this._lineVerticesMerc.length;
                geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                geometry._lineColorsHandlerIndex = this._lineColors.length;
                geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                GeometryHandler.appendLineData(ci, true,
                    geometry._style.lineColor, pickingColor, geometry._style.lineWidth,
                    geometry._style.strokeColor, geometry._style.strokeWidth,
                    this._lineVerticesMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors,
                    this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesMerc);

                geometry._lineVerticesLength = this._lineVerticesMerc.length - geometry._lineVerticesHandlerIndex;
                geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;

            } else if (geometry._type === _Geometry_js__WEBPACK_IMPORTED_MODULE_3__["GeometryType"].MULTIPOLYGON) {

                var coordinates = geometry._coordinates;
                var vertices = [],
                    indexes = [],
                    colors = [];

                //Creates polygon stroke data
                geometry._lineVerticesHandlerIndex = this._lineVerticesMerc.length;
                geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                geometry._lineColorsHandlerIndex = this._lineColors.length;
                geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                for (var i = 0; i < coordinates.length; i++) {
                    var cci = coordinates[i];
                    var ci = [];
                    for (var j = 0; j < cci.length; j++) {
                        ci[j] = [];
                        for (var k = 0; k < coordinates[i][j].length; k++) {
                            ci[j][k] = [_mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lon"](cci[j][k][0]), _mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lat"](cci[j][k][1])];
                        }
                    }
                    var data = Object(_utils_earcut_js__WEBPACK_IMPORTED_MODULE_2__["flatten"])(ci);
                    var dataIndexes = Object(_utils_earcut_js__WEBPACK_IMPORTED_MODULE_2__["earcut"])(data.vertices, data.holes, 2);

                    for (var j = 0; j < dataIndexes.length; j++) {
                        indexes.push(dataIndexes[j] + vertices.length * 0.5);
                    }

                    vertices.push.apply(vertices, data.vertices);

                    GeometryHandler.appendLineData(ci, true,
                        geometry._style.lineColor, pickingColor, geometry._style.lineWidth,
                        geometry._style.strokeColor, geometry._style.strokeWidth,
                        this._lineVerticesMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors,
                        this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesMerc);
                }

                geometry._polyVerticesMerc = vertices;
                geometry._polyVerticesHandlerIndex = this._polyVerticesMerc.length;
                geometry._polyIndexesHandlerIndex = this._polyIndexes.length;

                this._polyVerticesMerc.push.apply(this._polyVerticesMerc, vertices);

                for (var i = 0; i < indexes.length; i++) {
                    this._polyIndexes.push(indexes[i] + geometry._polyVerticesHandlerIndex * 0.5);
                }

                var color = geometry._style.fillColor;
                for (var i = 0; i < vertices.length * 0.5; i++) {
                    this._polyColors.push(color.x, color.y, color.z, color.w);
                    this._polyPickingColors.push(pickingColor.x, pickingColor.y, pickingColor.z, 1.0);
                }

                geometry._polyVerticesLength = vertices.length;
                geometry._polyIndexesLength = indexes.length;

                geometry._lineVerticesLength = this._lineVerticesMerc.length - geometry._lineVerticesHandlerIndex;
                geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;

            } else if (geometry._type === _Geometry_js__WEBPACK_IMPORTED_MODULE_3__["GeometryType"].LINESTRING) {

                var coordinates = geometry._coordinates;
                var ci = new Array(coordinates.length);
                for (var j = 0; j < coordinates.length; j++) {
                    ci[j] = [_mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lon"](coordinates[j][0]), _mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lat"](coordinates[j][1])];
                }

                //Creates polygon stroke data
                geometry._lineVerticesHandlerIndex = this._lineVerticesMerc.length;
                geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                geometry._lineColorsHandlerIndex = this._lineColors.length;
                geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                GeometryHandler.appendLineData([ci], false,
                    geometry._style.lineColor, pickingColor, geometry._style.lineWidth,
                    geometry._style.strokeColor, geometry._style.strokeWidth,
                    this._lineVerticesMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors,
                    this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesMerc);

                geometry._lineVerticesLength = this._lineVerticesMerc.length - geometry._lineVerticesHandlerIndex;
                geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;

            } else if (geometry._type === _Geometry_js__WEBPACK_IMPORTED_MODULE_3__["GeometryType"].MULTILINESTRING) {
                var coordinates = geometry._coordinates;
                var ci = [];
                for (var j = 0; j < coordinates.length; j++) {
                    ci[j] = [];
                    for (var k = 0; k < coordinates[j].length; k++) {
                        ci[j][k] = [_mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lon"](coordinates[j][k][0]), _mercator_js__WEBPACK_IMPORTED_MODULE_0__["forward_lat"](coordinates[j][k][1])];
                    }
                }

                //Creates polygon stroke data
                geometry._lineVerticesHandlerIndex = this._lineVerticesMerc.length;
                geometry._lineOrdersHandlerIndex = this._lineOrders.length;
                geometry._lineIndexesHandlerIndex = this._lineIndexes.length;
                geometry._lineColorsHandlerIndex = this._lineColors.length;
                geometry._lineThicknessHandlerIndex = this._lineThickness.length;

                GeometryHandler.appendLineData(ci, false,
                    geometry._style.lineColor, pickingColor, geometry._style.lineWidth,
                    geometry._style.strokeColor, geometry._style.strokeWidth,
                    this._lineVerticesMerc, this._lineOrders, this._lineIndexes, this._lineColors, this._linePickingColors,
                    this._lineThickness, this._lineStrokeColors, this._lineStrokes, geometry._lineVerticesMerc);

                geometry._lineVerticesLength = this._lineVerticesMerc.length - geometry._lineVerticesHandlerIndex;
                geometry._lineOrdersLength = this._lineOrders.length - geometry._lineOrdersHandlerIndex;
                geometry._lineIndexesLength = this._lineIndexes.length - geometry._lineIndexesHandlerIndex;
                geometry._lineColorsLength = this._lineColors.length - geometry._lineColorsHandlerIndex;
                geometry._lineThicknessLength = this._lineThickness.length - geometry._lineThicknessHandlerIndex;
            }

            //Refresh visibility
            this.setGeometryVisibility(geometry);

            !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
            this._updatedGeometry[geometry._id] = true;
            this.refresh();
        }
    }

    remove(geometry) {
        var index = geometry._handlerIndex;
        if (index !== -1) {
            this._geometries.splice(index, 1);

            //polygon
            //this._polyVerticesLonLat.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
            this._polyVerticesMerc.splice(geometry._polyVerticesHandlerIndex, geometry._polyVerticesLength);
            this._polyColors.splice(geometry._polyVerticesHandlerIndex * 2, geometry._polyVerticesLength * 2);
            this._polyPickingColors.splice(geometry._polyVerticesHandlerIndex * 2, geometry._polyVerticesLength * 2);
            this._polyIndexes.splice(geometry._polyIndexesHandlerIndex, geometry._polyIndexesLength);
            var di = geometry._polyVerticesLength * 0.5;
            for (var i = geometry._polyIndexesHandlerIndex; i < this._polyIndexes.length; i++) {
                this._polyIndexes[i] -= di;
            }

            //line
            //this._lineVerticesLonLat.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
            this._lineVerticesMerc.splice(geometry._lineVerticesHandlerIndex, geometry._lineVerticesLength);
            this._lineOrders.splice(geometry._lineOrdersHandlerIndex, geometry._lineOrdersLength);
            this._lineColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
            this._linePickingColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
            this._lineStrokeColors.splice(geometry._lineColorsHandlerIndex, geometry._lineColorsLength);
            this._lineThickness.splice(geometry._lineThicknessHandlerIndex, geometry._lineThicknessLength);
            this._lineStrokes.splice(geometry._lineThicknessHandlerIndex, geometry._lineThicknessLength);
            this._lineIndexes.splice(geometry._lineIndexesHandlerIndex, geometry._lineIndexesLength);
            di = geometry._lineVerticesLength * 0.5;
            for (var i = geometry._lineIndexesHandlerIndex; i < this._lineIndexes.length; i++) {
                this._lineIndexes[i] -= di;
            }

            //reindex
            var g = this._geometries;
            for (i = index; i < g.length; i++) {
                var gi = g[i];
                gi._handlerIndex = i;
                gi._polyVerticesHandlerIndex -= geometry._polyVerticesLength;
                gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;

                gi._lineVerticesHandlerIndex -= geometry._lineVerticesLength;
                gi._lineOrdersHandlerIndex -= geometry._lineOrdersLength;
                gi._lineColorsHandlerIndex -= geometry._lineColorsLength;
                gi._lineThicknessHandlerIndex -= geometry._lineThicknessLength;
                gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
            }

            geometry._pickingReady = false;

            geometry._handler = null;
            geometry._handlerIndex = -1;

            geometry._polyVerticesMerc = [];
            geometry._polyVerticesLength = -1;
            geometry._polyIndexesLength = -1;
            geometry._polyVerticesHandlerIndex = -1;
            geometry._polyIndexesHandlerIndex = -1;

            geometry._lineVerticesMerc = [];
            geometry._lineVerticesLength = -1;
            geometry._lineOrdersLength = -1;
            geometry._lineIndexesLength = -1;
            geometry._lineColorsLength = -1;
            geometry._lineThicknessLength = -1;
            geometry._lineVerticesHandlerIndex = -1;
            geometry._lineOrdersHandlerIndex = -1;
            geometry._lineIndexesHandlerIndex = -1;
            geometry._lineThicknessHandlerIndex = -1;
            geometry._lineColorsHandlerIndex = -1;

            !this._removeGeometryExtents[geometry._id] && this._removeGeometryExtentArr.push(geometry.getExtent());
            this._removeGeometryExtents[geometry._id] = true;

            this.refresh();
        }
    }

    _refreshRecursevely(geometry, treeNode) {
        var lid = this._layer._id;
        for (var i = 0; i < treeNode.nodes.length; i++) {
            var ni = treeNode.nodes[i];
            if (geometry._extent.overlaps(ni.segment.getExtentLonLat())) {
                this._refreshRecursevely(geometry, ni);
                var m = ni.segment.materials[lid];
                if (m && m.isReady) {
                    if (m.segment.node.getState() !== _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["RENDERING"]) {
                        m.layer.clearMaterial(m);
                    } else {
                        m.pickingReady = m.pickingReady && geometry._pickingReady;
                        m.isReady = false;
                        m._updateTexture = m.texture;
                        m._updatePickingMask = m.pickingMask;
                    }
                    geometry._pickingReady = true;
                }
            }
        }
    }

    _refreshRecursevelyExt(extent, treeNode) {
        var lid = this._layer._id;
        for (var i = 0; i < treeNode.nodes.length; i++) {
            var ni = treeNode.nodes[i];
            if (extent.overlaps(ni.segment.getExtentLonLat())) {
                this._refreshRecursevelyExt(extent, ni);
                var m = ni.segment.materials[lid];
                if (m && m.isReady) {
                    m.layer.clearMaterial(m);
                    // m.pickingReady = false;
                    // m.isReady = false;
                    // m._updateTexture = m.texture;
                    // m._updatePickingMask = m.pickingMask;
                }
            }
        }
    }

    _refreshPlanetNode(treeNode) {
        var i = 0;

        var e = this._removeGeometryExtentArr;
        for (i = 0; i < e.length; i++) {
            this._refreshRecursevelyExt(e[i], treeNode);
        }

        var g = this._updatedGeometryArr;
        for (i = 0; i < g.length; i++) {
            this._refreshRecursevely(g[i], treeNode);
        }
    }

    _updatePlanet() {
        var p = this._layer._planet;
        if (p) {
            this._refreshPlanetNode(p._quadTree);
            this._refreshPlanetNode(p._quadTreeNorth);
            this._refreshPlanetNode(p._quadTreeSouth);
        }
        this._updatedGeometryArr.length = 0;
        this._updatedGeometryArr = [];
        this._updatedGeometry = {};

        this._removeGeometryExtentArr.length = 0;
        this._removeGeometryExtentArr = [];
        this._removeGeometryExtents = {};
    }

    refresh() {
        var i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }

    update() {
        if (this._handler) {
            var needUpdate = false;
            var i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    needUpdate = true;
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
            needUpdate && this._updatePlanet();
        }
    }

    setGeometryVisibility(geometry) {
        var v = geometry._visibility ? 1.0 : 0.0;

        var a = this._polyVerticesMerc;
        var l = geometry._polyVerticesLength;
        var ind = geometry._polyVerticesHandlerIndex;
        for (var i = 0; i < l; i++) {
            a[ind + i] = geometry._polyVerticesMerc[i] * v;
        }

        a = this._lineVerticesMerc;
        l = geometry._lineVerticesLength;
        ind = geometry._lineVerticesHandlerIndex;
        for (i = 0; i < l; i++) {
            a[ind + i] = geometry._lineVerticesMerc[i] * v;
        }

        this._changedBuffers[POLYVERTICES_BUFFER] = true;
        this._changedBuffers[LINEVERTICES_BUFFER] = true;

        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    setPolyColorArr(geometry, color) {
        var index = geometry._polyVerticesHandlerIndex * 2, // ... / 2 * 4
            size = index + geometry._polyVerticesLength * 2; // ... / 2 * 4
        var a = this._polyColors;
        for (var i = index; i < size; i += 4) {
            a[i] = color.x;
            a[i + 1] = color.y;
            a[i + 2] = color.z;
            a[i + 3] = color.w;
        }
        this._changedBuffers[POLYCOLORS_BUFFER] = true;
        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    setLineStrokeColorArr(geometry, color) {
        var index = geometry._lineColorsHandlerIndex,
            size = index + geometry._lineColorsLength;
        var a = this._lineStrokeColors;
        for (var i = index; i < size; i += 4) {
            a[i] = color.x;
            a[i + 1] = color.y;
            a[i + 2] = color.z;
            a[i + 3] = color.w;
        }
        this._changedBuffers[LINESTROKECOLORS_BUFFER] = true;
        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    setLineColorArr(geometry, color) {
        var index = geometry._lineColorsHandlerIndex,
            size = index + geometry._lineColorsLength;
        var a = this._lineColors;
        for (var i = index; i < size; i += 4) {
            a[i] = color.x;
            a[i + 1] = color.y;
            a[i + 2] = color.z;
            a[i + 3] = color.w;
        }
        this._changedBuffers[LINECOLORS_BUFFER] = true;
        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    setLineStrokeArr(geometry, width) {
        var index = geometry._lineStrokesHandlerIndex,
            size = index + geometry._lineStrokesLength;
        var a = this._lineStrokes;
        for (var i = index; i < size; i++) {
            a[i] = width;
        }
        this._changedBuffers[LINESTROKES_BUFFER] = true;
        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    setLineThicknessArr(geometry, width) {
        var index = geometry._lineThicknessHandlerIndex,
            size = index + geometry._lineThicknessLength;
        var a = this._lineThickness;
        for (var i = index; i < size; i++) {
            a[i] = width;
        }
        this._changedBuffers[LINETHICKNESS_BUFFER] = true;
        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    bringToFront(geometry) {

        var polyIndexes = this._polyIndexes.splice(geometry._polyIndexesHandlerIndex, geometry._polyIndexesLength);
        var lineIndexes = this._lineIndexes.splice(geometry._lineIndexesHandlerIndex, geometry._lineIndexesLength);

        this._geometries.splice(geometry._handlerIndex, 1);

        var g = this._geometries;
        for (var i = geometry._handlerIndex; i < g.length; i++) {
            var gi = g[i];
            gi._handlerIndex = i;
            gi._polyIndexesHandlerIndex -= geometry._polyIndexesLength;
            gi._lineIndexesHandlerIndex -= geometry._lineIndexesLength;
        }

        geometry._polyIndexesHandlerIndex = this._polyIndexes.length;
        geometry._lineIndexesHandlerIndex = this._lineIndexes.length;

        geometry._handlerIndex = this._geometries.length;
        this._geometries.push(geometry);

        this._polyIndexes.push.apply(this._polyIndexes, polyIndexes);
        this._lineIndexes.push.apply(this._lineIndexes, lineIndexes);

        this._changedBuffers[POLYINDEXES_BUFFER] = true;
        this._changedBuffers[LINEINDEXES_BUFFER] = true;

        !this._updatedGeometry[geometry._id] && this._updatedGeometryArr.push(geometry);
        this._updatedGeometry[geometry._id] = true;
    }

    createPolyVerticesBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._polyVerticesBufferMerc);
        this._polyVerticesBufferMerc = h.createArrayBuffer(new Float32Array(this._polyVerticesMerc), 2, this._polyVerticesMerc.length / 2);
    }

    createPolyIndexesBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._polyIndexesBuffer);
        this._polyIndexesBuffer = h.createElementArrayBuffer(new Uint32Array(this._polyIndexes), 1, this._polyIndexes.length);
    }

    createPolyColorsBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._polyColorsBuffer);
        this._polyColorsBuffer = h.createArrayBuffer(new Float32Array(this._polyColors), 4, this._polyColors.length / 4);
    }

    createPolyPickingColorsBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._polyPickingColorsBuffer);
        this._polyPickingColorsBuffer = h.createArrayBuffer(new Float32Array(this._polyPickingColors), 4, this._polyPickingColors.length / 4);
    }

    createLineVerticesBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineVerticesBufferMerc);
        this._lineVerticesBufferMerc = h.createArrayBuffer(new Float32Array(this._lineVerticesMerc), 2, this._lineVerticesMerc.length / 2);
    }

    createLineIndexesBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineIndexesBuffer);
        this._lineIndexesBuffer = h.createElementArrayBuffer(new Uint32Array(this._lineIndexes), 1, this._lineIndexes.length);
    }

    createLineOrdersBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineOrdersBuffer);
        this._lineOrdersBuffer = h.createArrayBuffer(new Float32Array(this._lineOrders), 1, this._lineOrders.length / 2);
    }

    createLineColorsBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineColorsBuffer);
        this._lineColorsBuffer = h.createArrayBuffer(new Float32Array(this._lineColors), 4, this._lineColors.length / 4);
    }

    createLinePickingColorsBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._linePickingColorsBuffer);
        this._linePickingColorsBuffer = h.createArrayBuffer(new Float32Array(this._linePickingColors), 4, this._linePickingColors.length / 4);
    }

    createLineThicknessBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineThicknessBuffer);
        this._lineThicknessBuffer = h.createArrayBuffer(new Float32Array(this._lineThickness), 1, this._lineThickness.length);
    }

    createLineStrokesBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineStrokesBuffer);
        this._lineStrokesBuffer = h.createArrayBuffer(new Float32Array(this._lineStrokes), 1, this._lineStrokes.length);
    }

    createLineStrokeColorsBuffer() {
        var h = this._handler;
        h.gl.deleteBuffer(this._lineStrokeColorsBuffer);
        this._lineStrokeColorsBuffer = h.createArrayBuffer(new Float32Array(this._lineStrokeColors), 4, this._lineStrokeColors.length / 4);
    }
};



/***/ }),

/***/ "./src/og/entity/Label.js":
/*!********************************!*\
  !*** ./src/og/entity/Label.js ***!
  \********************************/
/*! exports provided: Label, ALIGN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALIGN", function() { return ALIGN; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/* harmony import */ var _BaseBillboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseBillboard.js */ "./src/og/entity/BaseBillboard.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/**
 * @module og/entity/Label
 */








const ALIGN = {
    RIGHT: 0,
    LEFT: 1,
    CENTER: 2
};

/**
 * Text align options.
 * @readonly
 * @enum {number}
 */
const STR2ALIGN = {
    "left": ALIGN.LEFT,
    "right": ALIGN.RIGHT,
    "center": ALIGN.CENTER
};

/**
 * Billboard text label.
 * @class
 * @extends {og.BaseBillboard}
 * @param {Object} [options] - Label options:
 * @param {og.math.Vector3|Array.<number>} [options.position] - Billboard spatial position.
 * @param {number} [options.rotation] - Screen angle rotaion.
 * @param {og.math.Vector4|string|Array.<number>} [options.color] - Billboard color.
 * @param {og.math.Vector3|Array.<number>} [options.alignedAxis] - Billboard aligned vector.
 * @param {og.math.Vector3|Array.<number>} [options.offset] - Billboard center screen offset.
 * @param {boolean} [options.visibility] - Visibility.
 * @param {string} [options.text] - Text string.
 * @param {string} [options.face] - HTML5 font face.
 * @param {number} [options.size] - Font size in pixels.
 * @param {string} [options.style] - HTML5 font style. Example 'normal', 'italic'.
 * @param {string} [options.weight] - HTML5 font weight. Example 'normal', 'bold'.
 * @param {number} [options.outline] - Text outline size. 0 - no outline, 1 - maximum outline. Default 0.58.
 * @param {og.math.Vector4|string|Array.<number>} [options.outlineColor] - Outline color.
 * @param {og.Label.ALIGN} [options.align] - Text horizontal align: "left", "right" and "center".
 */
class Label extends _BaseBillboard_js__WEBPACK_IMPORTED_MODULE_1__["BaseBillboard"] {
    constructor(options) {
        super(options);

        options = options || {};

        /**
         * Label text string.
         * @private
         * @type {string}
         */
        this._text = options.text;

        /**
         * HTML5 font face.
         * @private
         * @type {string}
         */
        this._face = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["defaultString"](options.face, null);

        /**
         * Font size in pixels.
         * @private
         * @type {number}
         */
        this._size = options.size || 33;

        /**
         * HTML5 font style. Example 'normal', 'italic'.
         * @private
         * @type {string}
         */
        this._style = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["defaultString"](options.style, null);

        /**
         * HTML5 font weight style. Example 'normal', 'bold'.
         * @private
         * @type {string}
         */
        this._weight = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["defaultString"](options.weight, null);

        /**
         * Label outline.
         * @private
         * @type {number}
         */
        this._outline = options.outline != undefined ? options.outline : 0.5;

        /**
         * Label outline color.
         * @private
         * @type {og.math.Vector4}
         */
        this._outlineColor = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGBA"](options.outlineColor, new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_2__["Vec4"](0.0, 0.0, 0.0, 1.0));

        /**
         * Text horizontal align: "left", "right" and "center".
         * @private
         * @type {og.Label.ALIGN}
         */
        this._align = options.align ? STR2ALIGN[options.align.trim().toLowerCase()] || ALIGN.RIGHT : ALIGN.RIGHT;

        /**
         * Label font atlas index.
         * @private
         * @type {number}
         */
        this._fontIndex = 0;

        /**
         * Font atlas pointer.
         * @private
         * @type {og.utils.FontAtlas}
         */
        this._fontAtlas = null;
    }

    /**
     * Sets lablel text.
     * @public
     * @param {string} text - Text string. 
     * It can't be bigger than maximum labelHandler _maxLetters value.
     */
    setText(text) {
        this._text = text;
        this._handler && this._handler.setText(this._handlerIndex, text, this._fontIndex, this._align);
    }

    /**
     * Gets current text string.
     * @public
     * @returns {string}
     */
    getText() {
        return this._text;
    }

    /**
     * Sets label text align. Could be center, left or right. Left is default.
     * @public
     * @param {og.Label.ALIGN} align - Text align.
     */
    setAlign(align) {
        this._align = STR2ALIGN[align.trim().toLowerCase()];
        this._handler && this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align);
    };

    /**
     * Gets label text current alignment.
     * @public
     * @returns {og.Label.ALIGN}
     */
    getAlign() {
        return this._align;
    }

    /**
     * Sets font face family.
     * @public
     * @param {string} face - Font face family.
     */
    setFace(face) {
        this._face = face.trim().toLowerCase();
        this.update();
    }

    /**
     * Gets current font face.
     * @public
     * @returns {string}
     */
    getFace() {
        return this._face;
    }

    /**
     * Sets label font size in pixels.
     * @public
     * @param {number} size - Label size in pixels.
     */
    setSize(size) {
        this._size = size;
        this._handler && this._handler.setSizeArr(this._handlerIndex, size);
    }

    /**
     * Gets label size in pixels.
     * @public
     * @returns {number}
     */
    getSize() {
        return this._size;
    }

    /**
     * Sets font HTML5 style. It's can be Italic or Normal values.
     * @public
     * @param {string} style - HTML5 font style.
     */
    setStyle(style) {
        this._style = style.trim().toLowerCase();
        this.update();
    }

    /**
     * Gets label font style.
     * @public
     * @returns {string}
     */
    getStyle() {
        return this._style;
    }

    /**
     * Sets label font HTML5 weight style. It's can be bold or normal.
     * @public
     * @param {string} weight - HTML5 font weight style.
     */
    setWeight(weight) {
        this._weight = weight.trim().toLowerCase();
        this.update();
    }

    /**
     * Gets label font weight.
     * @public
     * @returns {string}
     */
    getWeight() {
        return this._wight;
    }

    /**
     * Sets text outline border size. Where 0 - is no outline and 1 - is the maximum outline size.
     * @public
     * @param {number} outline - Text outline size.
     */
    setOutline(outline) {
        this._outline = outline;
        this._handler && this._handler.setOutlineArr(this._handlerIndex, 1.0 - outline);
    }

    /**
     * Gets text current outline size.
     * @public
     * @returns {number}
     */
    getOutline() {
        return this._outline;
    }

    /**
     * Sets label opacity.
     * @public
     * @param {number} a - Label opacity.
     */
    setOpacity(a) {
        this._color.w = a;
        this.setColor4v(this._color);
        this._outlineColor.w = a;
        this.setOutlineColor4v(this._outlineColor);
    }

    /**
     * Sets text outline color.
     * @public
     * @param {number} r - Red.
     * @param {number} g - Green.
     * @param {number} b - Blue.
     * @param {number} a - Alpha.
     */
    setOutlineColor(r, g, b, a) {
        this._outlineColor.x = r;
        this._outlineColor.y = g;
        this._outlineColor.z = b;
        this._outlineColor.w = a;
        this._handler && this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
    }

    /**
     * Sets text outline color.
     * @public
     * @param {og.math.Vector4} rgba - Color vector.
     */
    setOutlineColor4v(rgba) {
        this._outlineColor.x = rgba.x;
        this._outlineColor.y = rgba.y;
        this._outlineColor.z = rgba.z;
        this._outlineColor.w = rgba.w;
        this._handler && this._handler.setOutlineColorArr(this._handlerIndex, rgba);
    }

    /**
     * Sets text outline color HTML string.
     * @public
     * @param {string} color - HTML string color.
     */
    setOutlineColorHTML(color) {
        this.setOutlineColor4v(_utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["htmlColorToRgba"](color));
    };

    /**
     * Gets outline color vector.
     * @public
     * @returns {og.math.Vector4}
     */
    getOutlineColor() {
        return this._outlineColor;
    }

    /**
     * Sets outline opacity. Actually outline color alpha value.
     * @public
     * @param {number} opacity - Outline opacity.
     */
    setOutlineOpacity(opacity) {
        this._outlineColor.w = opacity;
        this._handler && this._handler.setOutlineColorArr(this._handlerIndex, this._outlineColor);
    }

    /**
     * Gets outline opacity value.
     * @public
     * @returns {number}
     */
    getOutlineOpacity() {
        return this._outlineColor.w;
    }

    /**
     * Updates label parameters.
     * @public
     */
    update() {
        if (this._fontAtlas) {
            var fontIndex = this._fontAtlas.getFontIndex(this._face, this._style, this._weight);
            if (fontIndex == undefined) {
                this._fontAtlas.createFontAsync(this._face, this._style, this._weight, this._applyFontIndex.bind(this));
            } else {
                this._applyFontIndex(fontIndex);
            }
        }
    }

    _applyFontIndex(fontIndex) {
        this._fontIndex = fontIndex;
        if (this._handler) {
            this._handler.setFontIndexArr(this._handlerIndex, this._fontIndex);
            this._handler.setText(this._handlerIndex, this._text, this._fontIndex, this._align);
        }
    }

    /**
     * Assigns font atlas and update.
     * @public
     * @param {og.utils.FontAtlas} fontAtlas - Font atlas.
     */
    assignFontAtlas(fontAtlas) {
        !this._fontAtlas && (this._fontAtlas = fontAtlas);
        this.update();
    }
};



/***/ }),

/***/ "./src/og/entity/LabelHandler.js":
/*!***************************************!*\
  !*** ./src/og/entity/LabelHandler.js ***!
  \***************************************/
/*! exports provided: LabelHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelHandler", function() { return LabelHandler; });
/* harmony import */ var _shaders_label_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/label.js */ "./src/og/shaders/label.js");
/* harmony import */ var _Label_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Label.js */ "./src/og/entity/Label.js");
/* harmony import */ var _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BillboardHandler.js */ "./src/og/entity/BillboardHandler.js");
/**
 * @module og/entity/LabelHandler
 */








const FONTINDEX_BUFFER = 9;
const OUTLINE_BUFFER = 10;
const OUTLINECOLOR_BUFFER = 11;

/*
 * og.LabelHandler
 *
 *
 */
class LabelHandler extends _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"] {
    constructor(entityCollection) {

        super(entityCollection);

        this._fontIndexBuffer = null;
        this._noOutlineBuffer = null;
        this._outlineBuffer = null;
        this._outlineColorBuffer = null;

        this._fontIndexArr = [];
        this._noOutlineArr = [];
        this._outlineArr = [];
        this._outlineColorArr = [];

        this._buffersUpdateCallbacks[FONTINDEX_BUFFER] = this.createFontIndexBuffer;
        this._buffersUpdateCallbacks[OUTLINE_BUFFER] = this.createOutlineBuffer;
        this._buffersUpdateCallbacks[OUTLINECOLOR_BUFFER] = this.createOutlineColorBuffer;

        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

        this._maxLetters = 25;
    }


    initShaderProgram() {
        if (this._renderer.handler) {
            if (!this._renderer.handler.shaderPrograms.label) {
                var isSingleBuffer = !this._renderer.isMultiFramebufferCompatible();
                this._renderer.handler.addShaderProgram(_shaders_label_js__WEBPACK_IMPORTED_MODULE_0__["label"](isSingleBuffer));
            }
            if (!this._renderer.handler.shaderPrograms.labelPicking) {
                this._renderer.handler.addShaderProgram(_shaders_label_js__WEBPACK_IMPORTED_MODULE_0__["labelPicking"]());
            }
        }
    }

    add(label) {
        if (label._handlerIndex == -1) {
            label._handler = this;
            label._handlerIndex = this._billboards.length;
            this._billboards.push(label);
            this._addBillboardToArrays(label);
            this.refresh();
            this.assignFontAtlas(label);
        }
    }

    assignFontAtlas(label) {
        if (this._entityCollection && this._entityCollection.renderNode) {
            label.assignFontAtlas(this._entityCollection.renderNode.fontAtlas);
        }
    }

    clear() {

        this._texCoordArr.length = 0;
        this._vertexArr.length = 0;
        this._positionArr.length = 0;
        this._sizeArr.length = 0;
        this._offsetArr.length = 0;
        this._rgbaArr.length = 0;
        this._rotationArr.length = 0;
        this._alignedAxisArr.length = 0;
        this._fontIndexArr.length = 0;
        this._noOutlineArr.length = 0;
        this._outlineArr.length = 0;
        this._outlineColorArr.length = 0;

        this._texCoordArr = [];
        this._vertexArr = [];
        this._positionArr = [];
        this._sizeArr = [];
        this._offsetArr = [];
        this._rgbaArr = [];
        this._rotationArr = [];
        this._alignedAxisArr = [];
        this._fontIndexArr = [];
        this._noOutlineArr = [];
        this._outlineArr = [];
        this._outlineColorArr = [];

        this._removeBillboards();
        this._deleteBuffers();
        this.refresh();
    }

    _deleteBuffers() {
        var gl = this._renderer.handler.gl;
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._fontIndexBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
        gl.deleteBuffer(this._outlineBuffer);
        gl.deleteBuffer(this._noOutlineBuffer);
        gl.deleteBuffer(this._outlineColorBuffer);
        gl.deleteBuffer(this._positionBuffer);
        gl.deleteBuffer(this._sizeBuffer);
        gl.deleteBuffer(this._offsetBuffer);
        gl.deleteBuffer(this._rgbaBuffer);
        gl.deleteBuffer(this._rotationBuffer);
        gl.deleteBuffer(this._vertexBuffer);
        gl.deleteBuffer(this._texCoordBuffer);
        gl.deleteBuffer(this._alignedAxisBuffer);
        gl.deleteBuffer(this._pickingColorBuffer);

        this._sizeBuffer = null;
        this._fontIndexBuffer = null;
        this._texCoordBuffer = null;
        this._outlineBuffer = null;
        this._outlineColorBuffer = null;
        this._positionBuffer = null;
        this._sizeBuffer = null;
        this._offsetBuffer = null;
        this._rgbaBuffer = null;
        this._rotationBuffer = null;
        this._vertexBuffer = null;
        this._texCoordBuffer = null;
        this._alignedAxisBuffer = null;
        this._pickingColorBuffer = null;

    }

    _addBillboardToArrays(label) {
        for (var i = 0; i < this._maxLetters; i++) {
            if (label._visibility) {
                _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._vertexArr, [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5]);
            } else {
                _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._vertexArr, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
            }

            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._texCoordArr, [0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, 0]);

            var x = label._position.x, y = label._position.y, z = label._position.z, w = label._scale;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._positionArr, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = label._size;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._sizeArr, [x, x, x, x, x, x]);

            x = label._offset.x; y = label._offset.y; z = label._offset.z - 0.05;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._offsetArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = label._color.x; y = label._color.y; z = label._color.z; w = label._color.w;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._rgbaArr, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = label._rotation;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._rotationArr, [x, x, x, x, x, x]);

            x = label._alignedAxis.x, y = label._alignedAxis.y, z = label._alignedAxis.z;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._alignedAxisArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);

            x = label._fontIndex;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._fontIndexArr, [0, 0, 0, 0, 0, 0]);

            x = 1.0 - label._outline, y = 0.0;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._outlineArr, [x, y, x, y, x, y, x, y, x, y, x, y]);

            x = 0.75, y = 0.7;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._noOutlineArr, [x, y, x, y, x, y, x, y, x, y, x, y]);

            x = label._outlineColor.x; y = label._outlineColor.y; z = label._outlineColor.z; w = label._outlineColor.w;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._outlineColorArr, [x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w, x, y, z, w]);

            x = label._entity._pickingColor.x / 255, y = label._entity._pickingColor.y / 255, z = label._entity._pickingColor.z / 255;
            _BillboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["BillboardHandler"].concArr(this._pickingColorArr, [x, y, z, x, y, z, x, y, z, x, y, z, x, y, z, x, y, z]);
        }
    };

    _displayPASS() {
        var r = this._renderer;
        var h = r.handler;
        h.shaderPrograms.label.activate();
        var sh = h.shaderPrograms.label._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var gl = h.gl;

        var ec = this._entityCollection;
        var rn = ec.renderNode;

        gl.uniform1iv(shu.u_fontTextureArr._pName, rn.fontAtlas.samplerArr);

        gl.uniformMatrix4fv(shu.viewMatrix._pName, false, r.activeCamera._viewMatrix._m);
        gl.uniformMatrix4fv(shu.projectionMatrix._pName, false, r.activeCamera._projectionMatrix._m);

        gl.uniform3fv(shu.uCamPos._pName, r.activeCamera.eye.toVec());

        gl.uniform3fv(shu.uScaleByDistance._pName, ec.scaleByDistance);

        gl.uniform1f(shu.uOpacity._pName, ec._animatedOpacity);

        gl.uniform2fv(shu.uFloatParams._pName, [rn._planetRadius2 || 0, r.activeCamera._tanViewAngle_hradOneByHeight]);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
        gl.vertexAttribPointer(sha.a_texCoord._pName, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
        gl.vertexAttribPointer(sha.a_positions._pName, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size._pName, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset._pName, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation._pName, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._alignedAxisBuffer);
        gl.vertexAttribPointer(sha.a_alignedAxis._pName, this._alignedAxisBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._fontIndexBuffer);
        gl.vertexAttribPointer(sha.a_fontIndex._pName, this._fontIndexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineColorBuffer);
        gl.vertexAttribPointer(sha.a_rgba._pName, this._outlineColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._outlineBuffer);
        gl.vertexAttribPointer(sha.a_bufferAA._pName, this._outlineBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.uniform1f(shu.uZ._pName, -2.0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);

        //nobuffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this._rgbaBuffer);
        gl.vertexAttribPointer(sha.a_rgba._pName, this._rgbaBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._noOutlineBuffer);
        gl.vertexAttribPointer(sha.a_bufferAA._pName, this._noOutlineBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.uniform1f(shu.uZ._pName, -10.0);
        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);

    }

    _pickingPASS() {
        var r = this._renderer;
        var h = r.handler;
        h.shaderPrograms.labelPicking.activate();
        var sh = h.shaderPrograms.labelPicking._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var gl = h.gl;

        gl.uniformMatrix4fv(shu.viewMatrix._pName, false, r.activeCamera._viewMatrix._m);
        gl.uniformMatrix4fv(shu.projectionMatrix._pName, false, r.activeCamera._projectionMatrix._m);

        gl.uniform3fv(shu.uCamPos._pName, r.activeCamera.eye.toVec());

        gl.uniform3fv(shu.uScaleByDistance._pName, this._entityCollection.scaleByDistance);

        gl.uniform1f(shu.uOpacity._pName, this._entityCollection._animatedOpacity);

        gl.uniform2fv(shu.uFloatParams._pName, [this._entityCollection.renderNode._planetRadius2 || 0, r.activeCamera._tanViewAngle_hradOneByHeight]);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.a_vertices._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordBuffer);
        gl.vertexAttribPointer(sha.a_texCoord._pName, this._texCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
        gl.vertexAttribPointer(sha.a_positions._pName, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);
        gl.vertexAttribPointer(sha.a_size._pName, this._sizeBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._offsetBuffer);
        gl.vertexAttribPointer(sha.a_offset._pName, this._offsetBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._rotationBuffer);
        gl.vertexAttribPointer(sha.a_rotation._pName, this._rotationBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._alignedAxisBuffer);
        gl.vertexAttribPointer(sha.a_alignedAxis._pName, this._alignedAxisBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
        gl.vertexAttribPointer(sha.a_pickingColor._pName, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, this._vertexBuffer.numItems);
    }

    _removeBillboard(label) {
        var li = label._handlerIndex;

        this._billboards.splice(li, 1);

        var ml = 24 * this._maxLetters;
        var i = li * ml;
        this._rgbaArr.splice(i, ml);
        this._outlineColorArr.splice(i, ml);
        this._texCoordArr.splice(i, ml);
        this._positionArr.splice(i, ml);

        ml = 18 * this._maxLetters;
        i = li * ml;
        this._offsetArr.splice(i, ml);
        this._alignedAxisArr.splice(i, ml);
        this._pickingColorArr.splice(i, ml);

        ml = 12 * this._maxLetters;
        i = li * ml;
        this._vertexArr.splice(i, ml);
        this._outlineArr.splice(i, ml);
        this._noOutlineArr.splice(i, ml);

        ml = 6 * this._maxLetters;
        i = li * ml;
        this._sizeArr.splice(i, ml);
        this._rotationArr.splice(i, ml);
        this._fontIndexArr.splice(i, ml);

        this.reindexBillbordsArray(li);
        this.refresh();

        label._handlerIndex = -1;
        label._handler = null;
        //label._fontIndex = 0;
        //label._fontAtlas = null;
    };

    setText(index, text, fontIndex, align) {

        var fa = this._entityCollection.renderNode.fontAtlas.atlasesArr[fontIndex];

        if (!fa) return;

        var i = index * 24 * this._maxLetters;
        var a = this._texCoordArr;

        var c = 0;

        var j = i + c * 24;
        var n = fa.nodes[text[c]];
        var f = n ? n.emptySize : 0.0;
        var offset = f;

        for (c = 0; c < text.length; c++) {
            var j = i + c * 24;
            var n = fa.nodes[text[c]] || fa.nodes[" "];
            var tc = n.texCoords;

            a[j] = tc[0];
            a[j + 1] = tc[1];
            a[j + 2] = offset;
            a[j + 3] = 0.0;

            a[j + 4] = tc[2];
            a[j + 5] = tc[3];
            a[j + 6] = offset;
            a[j + 7] = 0.0;

            a[j + 8] = tc[4];
            a[j + 9] = tc[5];
            a[j + 10] = offset;
            a[j + 11] = 0.0;

            a[j + 12] = tc[6];
            a[j + 13] = tc[7];
            a[j + 14] = offset;
            a[j + 15] = 0.0;

            a[j + 16] = tc[8];
            a[j + 17] = tc[9];
            a[j + 18] = offset;
            a[j + 19] = 0.0;

            a[j + 20] = tc[10];
            a[j + 21] = tc[11];
            a[j + 22] = offset;
            a[j + 23] = 0.0;

            offset += n.emptySize;
        }

        //49/512 - font atlas left border letter offset
        if (align == _Label_js__WEBPACK_IMPORTED_MODULE_1__["ALIGN"].CENTER) {
            offset = (f + 49 / 512 - offset) * 0.5;
            for (c = 0; c < text.length; c++) {
                var j = i + c * 24;
                a[j + 3] = offset;
                a[j + 7] = offset;
                a[j + 11] = offset;
                a[j + 15] = offset;
                a[j + 19] = offset;
                a[j + 23] = offset;
            }
        } else if (align == _Label_js__WEBPACK_IMPORTED_MODULE_1__["ALIGN"].LEFT) {
            offset = (f + 49 / 512 - offset);
            for (c = 0; c < text.length; c++) {
                var j = i + c * 24;
                a[j + 3] = offset;
                a[j + 7] = offset;
                a[j + 11] = offset;
                a[j + 15] = offset;
                a[j + 19] = offset;
                a[j + 23] = offset;
            }
        }

        for (var c = c; c < this._maxLetters; c++) {
            var j = i + c * 24;
            a[j + 2] = -1.0;
            a[j + 6] = -1.0;
            a[j + 10] = -1.0;
            a[j + 14] = -1.0;
            a[j + 18] = -1.0;
            a[j + 17] = -1.0;
        }

        this._changedBuffers[TEXCOORD_BUFFER] = true;
    }

    setPositionArr(index, position) {
        var i = index * 24 * this._maxLetters;
        var a = this._positionArr, x = position.x, y = position.y, z = position.z;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 24;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;

            a[j + 4] = x;
            a[j + 5] = y;
            a[j + 6] = z;

            a[j + 8] = x;
            a[j + 9] = y;
            a[j + 10] = z;

            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;

            a[j + 16] = x;
            a[j + 17] = y;
            a[j + 18] = z;

            a[j + 20] = x;
            a[j + 21] = y;
            a[j + 22] = z;
        }

        this._changedBuffers[POSITION_BUFFER] = true;
    }

    setScaleArr(index, scale) {

        var i = index * 24 * this._maxLetters;
        var a = this._positionArr;
        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 24;
            a[j + 3] = scale;
            a[j + 7] = scale;
            a[j + 11] = scale;
            a[j + 15] = scale;
            a[j + 19] = scale;
            a[j + 23] = scale;
        }

        this._changedBuffers[POSITION_BUFFER] = true;
    }

    setPickingColorArr(index, color) {
        var i = index * 18 * this._maxLetters;
        var a = this._pickingColorArr, x = color.x / 255, y = color.y / 255, z = color.z / 255;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 18;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;

            a[j + 3] = x;
            a[j + 4] = y;
            a[j + 5] = z;

            a[j + 6] = x;
            a[j + 7] = y;
            a[j + 8] = z;

            a[j + 9] = x;
            a[j + 10] = y;
            a[j + 11] = z;

            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;

            a[j + 15] = x;
            a[j + 16] = y;
            a[j + 17] = z;
        }

        this._changedBuffers[PICKINGCOLOR_BUFFER] = true;
    }

    setSizeArr(index, size) {

        var i = index * 6 * this._maxLetters;
        var a = this._sizeArr;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 6;
            a[j] = size;
            a[j + 1] = size;
            a[j + 2] = size;
            a[j + 3] = size;
            a[j + 4] = size;
            a[j + 5] = size;
        }

        this._changedBuffers[SIZE_BUFFER] = true;
    }

    setOffsetArr(index, offset) {

        var i = index * 18 * this._maxLetters;
        var a = this._offsetArr, x = offset.x, y = offset.y, z = offset.z;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 18;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;

            a[j + 3] = x;
            a[j + 4] = y;
            a[j + 5] = z;

            a[j + 6] = x;
            a[j + 7] = y;
            a[j + 8] = z;

            a[j + 9] = x;
            a[j + 10] = y;
            a[j + 11] = z;

            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;

            a[j + 15] = x;
            a[j + 16] = y;
            a[j + 17] = z;
        }

        this._changedBuffers[OFFSET_BUFFER] = true;
    }

    setRgbaArr(index, rgba) {
        var i = index * 24 * this._maxLetters;
        var a = this._rgbaArr, x = rgba.x, y = rgba.y, z = rgba.z, w = rgba.w;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 24;

            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = w;

            a[j + 4] = x;
            a[j + 5] = y;
            a[j + 6] = z;
            a[j + 7] = w;

            a[j + 8] = x;
            a[j + 9] = y;
            a[j + 10] = z;
            a[j + 11] = w;

            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = w;

            a[j + 16] = x;
            a[j + 17] = y;
            a[j + 18] = z;
            a[j + 19] = w;

            a[j + 20] = x;
            a[j + 21] = y;
            a[j + 22] = z;
            a[j + 23] = w;
        }

        this._changedBuffers[RGBA_BUFFER] = true;
    }

    setOutlineColorArr(index, rgba) {
        var i = index * 24 * this._maxLetters;
        var a = this._outlineColorArr, x = rgba.x, y = rgba.y, z = rgba.z, w = rgba.w;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 24;

            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;
            a[j + 3] = w;

            a[j + 4] = x;
            a[j + 5] = y;
            a[j + 6] = z;
            a[j + 7] = w;

            a[j + 8] = x;
            a[j + 9] = y;
            a[j + 10] = z;
            a[j + 11] = w;

            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;
            a[j + 15] = w;

            a[j + 16] = x;
            a[j + 17] = y;
            a[j + 18] = z;
            a[j + 19] = w;

            a[j + 20] = x;
            a[j + 21] = y;
            a[j + 22] = z;
            a[j + 23] = w;
        }

        this._changedBuffers[OUTLINECOLOR_BUFFER] = true;
    }

    setOutlineArr(index, outline) {
        var i = index * 12 * this._maxLetters;
        var a = this._outlineArr;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 12;
            a[j] = outline;
            a[j + 2] = outline;
            a[j + 4] = outline;
            a[j + 6] = outline;
            a[j + 8] = outline;
            a[j + 10] = outline;
        }

        this._changedBuffers[OUTLINE_BUFFER] = true;
    }

    setRotationArr(index, rotation) {

        var i = index * 6 * this._maxLetters;
        var a = this._rotationArr;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 6;
            a[j] = rotation;
            a[j + 1] = rotation;
            a[j + 2] = rotation;
            a[j + 3] = rotation;
            a[j + 4] = rotation;
            a[j + 5] = rotation;
        }

        this._changedBuffers[ROTATION_BUFFER] = true
    }

    setVertexArr(index, vertexArr) {

        var i = index * 12 * this._maxLetters;
        var a = this._vertexArr;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 12;
            a[j] = vertexArr[0];
            a[j + 1] = vertexArr[1];
            a[j + 2] = vertexArr[2];

            a[j + 3] = vertexArr[3];
            a[j + 4] = vertexArr[4];
            a[j + 5] = vertexArr[5];

            a[j + 6] = vertexArr[6];
            a[j + 7] = vertexArr[7];
            a[j + 8] = vertexArr[8];

            a[j + 9] = vertexArr[9];
            a[j + 10] = vertexArr[10];
            a[j + 11] = vertexArr[11];
        }

        this._changedBuffers[VERTEX_BUFFER] = true;
    }

    setAlignedAxisArr(index, alignedAxis) {
        var i = index * 18 * this._maxLetters;
        var a = this._alignedAxisArr, x = alignedAxis.x, y = alignedAxis.y, z = alignedAxis.z;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 18;
            a[j] = x;
            a[j + 1] = y;
            a[j + 2] = z;

            a[j + 3] = x;
            a[j + 4] = y;
            a[j + 5] = z;

            a[j + 6] = x;
            a[j + 7] = y;
            a[j + 8] = z;

            a[j + 9] = x;
            a[j + 10] = y;
            a[j + 11] = z;

            a[j + 12] = x;
            a[j + 13] = y;
            a[j + 14] = z;

            a[j + 15] = x;
            a[j + 16] = y;
            a[j + 17] = z;
        }

        this._changedBuffers[ALIGNEDAXIS_BUFFER] = true;
    }

    setFontIndexArr(index, fontIndex) {

        var i = index * 6 * this._maxLetters;
        var a = this._fontIndexArr;

        for (var q = 0; q < this._maxLetters; q++) {
            var j = i + q * 6;
            a[j] = fontIndex;
            a[j + 1] = fontIndex;
            a[j + 2] = fontIndex;
            a[j + 3] = fontIndex;
            a[j + 4] = fontIndex;
            a[j + 5] = fontIndex;
        }

        this._changedBuffers[FONTINDEX_BUFFER] = true;
    }

    createSizeBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._sizeBuffer);
        this._sizeBuffer = h.createArrayBuffer(new Float32Array(this._sizeArr), 1, this._sizeArr.length);
    }

    createFontIndexBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._fontIndexBuffer);
        this._fontIndexBuffer = h.createArrayBuffer(new Float32Array(this._fontIndexArr), 1, this._fontIndexArr.length);
    }

    createTexCoordBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._texCoordBuffer);
        this._texCoordBuffer = h.createArrayBuffer(new Float32Array(this._texCoordArr), 4, this._texCoordArr.length / 4);
    }

    createOutlineBuffer() {
        var h = this._renderer.handler;

        h.gl.deleteBuffer(this._outlineBuffer);
        this._outlineBuffer = h.createArrayBuffer(new Float32Array(this._outlineArr), 2, this._outlineArr.length / 2);

        h.gl.deleteBuffer(this._noOutlineBuffer);
        this._noOutlineBuffer = h.createArrayBuffer(new Float32Array(this._noOutlineArr), 2, this._noOutlineArr.length / 2);
    }

    createOutlineColorBuffer() {
        var h = this._renderer.handler;
        h.gl.deleteBuffer(this._outlineColorBuffer);
        this._outlineColorBuffer = h.createArrayBuffer(new Float32Array(this._outlineColorArr), 4, this._outlineColorArr.length / 4);
    }

    setMaxLetters(c) {
        this._maxLetters = c;
        //...
    }

    refreshTexCoordsArr() {
        //it is empty
        return null;
    }
};



/***/ }),

/***/ "./src/og/entity/PointCloud.js":
/*!*************************************!*\
  !*** ./src/og/entity/PointCloud.js ***!
  \*************************************/
/*! exports provided: PointCloud */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/**
 * @module og/entity/PointCloud
 */






const COORDINATES_BUFFER = 0;
const COLOR_BUFFER = 1;
const PICKING_COLOR_BUFFER = 2;

/**
 * PointCloud object.
 * @class
 * @param {*} [options] - Point cloud options:
 * @param {Array.<Array.<number,number,number,number,number,number,number,*>>} [options.points] - Points cartesian coordinates array, 
 * where first three is cartesian coordinates, next fourth is a RGBA color, and last is an point properties.
 * @param {number} [options.pointSize] - Point screen size in pixels.
 * @param {number} [options.pickingDistance] - Point border picking size in screen pixels.
 * @parar {boolean} [options.visibility] - Point cloud visibility.
 * @example <caption>Creates point cloud with two ten pixel size points</caption>
 * new og.Entity({
 *     pointCloud: {
 *         pointSize: 10,
 *         points: [
 *             [0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }],
 *             [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]
 *         ]
 *     }
 * });
 */
class PointCloud {
    constructor(options) {

        options = options || {};

        /**
         * Object unic identifier.
         * @public
         * @readonly
         * @type {number}
         */
        this.id = PointCloud._staticCounter++;

        /**
         * Cloud visibility.
         * @public
         * @type {boolean}
         */
        this.visibility = (options.visibility != undefined ? options.visibility : true);

        /**
         * Point screen size in pixels.
         * @public
         * @type {number}
         */
        this.pointSize = options.pointSize || 3;

        /**
         * Point picking border size in pixels.
         * @public
         * @type {number}
         */
        this.pickingDistance = options.pickingDistance || 0;

        /**
         * Parent collection render node.
         * @private
         * @type {og.scene.RenderNode}
         */
        this._renderNode = null;

        /**
         * Entity instance that holds this point cloud.
         * @private
         * @type {og.Entity}
         */
        this._entity = null;

        /**
         * Points properties.
         * @private
         * @type {Array.<*>}
         */
        this._points = [];

        /**
         * Coordinates array.
         * @private
         * @type {Array.<number>}
         */
        this._coordinatesData = [];

        /**
         * Color array.
         * @private
         * @type {Array.<number>}
         */
        this._colorData = [];

        /**
         * Picking color array.
         * @private
         * @type {Array.<number>}
         */
        this._pickingColorData = [];

        this._coordinatesBuffer = null;
        this._colorBuffer = null;
        this._pickingColorBuffer = null;

        /**
         * Handler that stores and renders this object.
         * @private
         * @type {og.PointCloudHandler}
         */
        this._handler = null;
        this._handlerIndex = -1;

        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[COORDINATES_BUFFER] = this._createCoordinatesBuffer;
        this._buffersUpdateCallbacks[COLOR_BUFFER] = this._createColorBuffer;
        this._buffersUpdateCallbacks[PICKING_COLOR_BUFFER] = this._createPickingColorBuffer;

        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

        this.setPoints(options.points);
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    /**
     * Clears point cloud data
     * @public
     */
    clear() {

        this._points.length = 0;
        this._points = [];

        this._coordinatesData.length = 0;
        this._coordinatesData = [];

        this._colorData.length = 0;
        this._colorData = [];

        this._pickingColorData.length = 0;
        this._pickingColorData = [];

        this._deleteBuffers();
    }

    /**
     * Set point cloud opacity.
     * @public
     * @param {number} opacity - Cloud opacity.
     */
    setOpacity(opacity) {
        this.opacity = opacity;
    }

    /**
     * Sets cloud visibility.
     * @public
     * @param {number} visibility - Visibility flag.
     */
    setVisibility(visibility) {
        this.visibility = visibility;
    }

    /**
     * @return {boolean} Point cloud visibily.
     */
    getVisibility() {
        return this.visibility;
    }

    /**
     * Assign rendering scene node.
     * @public
     * @param {og.scene.RenderNode}  renderNode - Assigned render node.
     */
    setRenderNode(renderNode) {
        this._renderNode = renderNode;
        this._setPickingColors();
    }

    /**
     * Removes from entity.
     * @public
     */
    remove() {
        this._entity = null;
        this._handler && this._handler.remove(this);
    }

    /**
     * Adds points to render.
     * @public
     * @param {Array.<Array<number,number,number,number,number,number,number,*>>} points - Point cloud array.
     * @example
     * var points = [[0, 0, 0, 255, 255, 255, 255, { 'name': 'White point' }], [100, 100, 0, 255, 0, 0, 255, { 'name': 'Red point' }]];
     */
    setPoints(points) {
        this.clear();
        for (var i = 0; i < points.length; i++) {
            var pi = points[i];
            var pos = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](pi[0], pi[1], pi[2]),
                col = new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_1__["Vec4"](pi[3], pi[4], pi[5], (pi[6] == undefined ? 255.0 : pi[6]));
            this._coordinatesData.push(pos.x, pos.y, pos.z);
            this._colorData.push(col.x / 255.0, col.y / 255.0, col.z / 255.0, col.w / 255.0);
            var p = {
                '_pickingColor': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](),
                '_entityCollection': this._entity && this._entity._entityCollection,
                'index': i,
                'position': pos,
                'color': col,
                'pointCloud': this,
                'properties': pi[7] || {}
            };
            this._points.push(p);

            if (this._renderNode) {
                this._renderNode.renderer.assignPickingColor(p);
                this._pickingColorData.push(p._pickingColor.x / 255.0, p._pickingColor.y / 255.0, p._pickingColor.z / 255.0, 1.0);
            }
        }

        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }

    /**
     * @todo
     */
    setPointPosition(index, x, y, z) {

        //...

        this._changedBuffers[COORDINATES_BUFFER] = true;
    }

    /**
     * @todo
     */
    setPointColor(index, r, g, b, a) {

        //...

        this._changedBuffers[COLOR_BUFFER] = true;
    }

    /**
     * @todo
     */
    addPoints(points) {

        //...

        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }

    /**
     * @todo
     */
    addPoint(index, point) {

        //...

        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }

    /**
     * Returns specific point by index.
     * @public
     * @param {number} index - Point index.
     * @return {*} Specific point
     */
    getPoint(index) {
        return this._points[index];
    }

    /**
     * @todo
     */
    removePoint(index) {

        //...

        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }

    /**
     * @todo
     */
    insertPoint(index, point) {

        //...

        this._changedBuffers[COORDINATES_BUFFER] = true;
        this._changedBuffers[COLOR_BUFFER] = true;
        this._changedBuffers[PICKING_COLOR_BUFFER] = true;
    }

    /**
     * Each point iterator.
     * @public
     * @param {callback} callback
     */
    each(callback) {
        var i = this._points.length;
        while (i--) {
            callback && callback(this._points[i]);
        }
    }

    draw() {
        if (this.visibility && this._coordinatesData.length) {

            this._update();

            var rn = this._renderNode;
            var r = rn.renderer;
            var sh = r.handler.shaderPrograms.pointCloud;
            var p = sh._program;
            var gl = r.handler.gl,
                sha = p.attributes,
                shu = p.uniforms;

            sh.activate();

            gl.uniformMatrix4fv(shu.projectionViewMatrix._pName, false, r.activeCamera._projectionViewMatrix._m);

            gl.uniform1f(shu.opacity._pName, this._handler._entityCollection._animatedOpacity);

            gl.uniform1f(shu.pointSize._pName, this.pointSize);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
            gl.vertexAttribPointer(sha.coordinates._pName, this._coordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer);
            gl.vertexAttribPointer(sha.colors._pName, this._colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
        }
    }

    drawPicking() {
        if (this.visibility && this._coordinatesData.length) {
            var rn = this._renderNode;
            var r = rn.renderer;
            var sh = r.handler.shaderPrograms.pointCloud;
            var p = sh._program;
            var gl = r.handler.gl,
                sha = p.attributes,
                shu = p.uniforms;

            sh.activate();

            gl.uniformMatrix4fv(shu.projectionViewMatrix._pName, false, r.activeCamera._projectionViewMatrix._m);

            gl.uniform1f(shu.opacity._pName, this._handler._entityCollection._animatedOpacity);

            gl.uniform1f(shu.pointSize._pName, this.pointSize + this.pickingDistance);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._coordinatesBuffer);
            gl.vertexAttribPointer(sha.coordinates._pName, this._coordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._pickingColorBuffer);
            gl.vertexAttribPointer(sha.colors._pName, this._pickingColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, this._coordinatesBuffer.numItems);
        }
    }

    /**
     * Update gl buffers.
     * @private
     */
    _update() {
        if (this._renderNode) {
            var i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }

    /**
     * Delete buffers
     * @private
     */
    _deleteBuffers() {
        if (this._renderNode) {
            var r = this._renderNode.renderer,
                gl = r.handler.gl;

            gl.deleteBuffer(this._coordinatesBuffer);
            gl.deleteBuffer(this._colorBuffer);
            gl.deleteBuffer(this._pickingColorBuffer);
        }

        this._coordinatesBuffer = null;
        this._colorBuffer = null;
        this._pickingColorBuffer = null;
    }

    _createCoordinatesBuffer() {
        var h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._coordinatesBuffer);
        this._coordinatesBuffer = h.createArrayBuffer(new Float32Array(this._coordinatesData), 3, (this._coordinatesData.length) / 3);
    }

    _createColorBuffer() {
        var h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._colorBuffer);
        this._colorBuffer = h.createArrayBuffer(new Float32Array(this._colorData), 4, (this._colorData.length) / 4);
    }

    _createPickingColorBuffer() {
        var h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._pickingColorBuffer);
        this._pickingColorBuffer = h.createArrayBuffer(new Float32Array(this._pickingColorData), 4, (this._pickingColorData.length) / 4);
    }

    _setPickingColors() {
        if (this._renderNode) {
            for (var i = 0; i < this._points.length; i++) {
                var p = this._points[i];
                p._entity = this._entity;
                p._entityCollection = this._entity._entityCollection;
                this._renderNode.renderer.assignPickingColor(p);
                this._pickingColorData.push(p._pickingColor.x / 255.0, p._pickingColor.y / 255.0, p._pickingColor.z / 255.0, 1.0);
            }
            this._changedBuffers[PICKING_COLOR_BUFFER] = true;
        }
    }
};



/***/ }),

/***/ "./src/og/entity/PointCloudHandler.js":
/*!********************************************!*\
  !*** ./src/og/entity/PointCloudHandler.js ***!
  \********************************************/
/*! exports provided: PointCloudHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudHandler", function() { return PointCloudHandler; });
/* harmony import */ var _shaders_pointCloud_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/pointCloud.js */ "./src/og/shaders/pointCloud.js");
/**
 * @module og/entity/PointCloudHandler
 */





class PointCloudHandler {
    constructor(entityCollection) {

        /**
         * Picking rendering option.
         * @public
         * @type {boolean}
         */
        this.pickingEnabled = true;

        /**
         * Parent collection
         * @private
         * @type {og.EntityCollection}
         */
        this._entityCollection = entityCollection;

        /**
         * Renderer
         * @private
         * @type {og.Renderer}
         */
        this._renderer = null;

        /**
         * Point cloud array
         * @private
         * @type {Array.<og.PointCloud>}
         */
        this._pointClouds = [];

        this.__staticId = PointCloudHandler._staticCounter++;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    _initShaderProgram() {
        if (this._renderer.handler) {
            if (!this._renderer.handler.shaderPrograms.pointCloud) {
                this._renderer.handler.addShaderProgram(_shaders_pointCloud_js__WEBPACK_IMPORTED_MODULE_0__["pointCloud"]());
            }
        }
    }

    setRenderNode(renderNode) {
        this._renderer = renderNode.renderer;
        this._initShaderProgram()
        for (var i = 0; i < this._pointClouds.length; i++) {
            this._pointClouds[i].setRenderNode(renderNode);
        }
    }

    add(pointCloud) {
        if (pointCloud._handlerIndex == -1) {
            pointCloud._handler = this;
            pointCloud._handlerIndex = this._pointClouds.length;
            this._pointClouds.push(pointCloud);
            this._entityCollection && this._entityCollection.renderNode &&
                pointCloud.setRenderNode(this._entityCollection.renderNode);
        }
    }

    remove(pointCloud) {
        var index = pointCloud._handlerIndex;
        if (index !== -1) {
            pointCloud._deleteBuffers();
            pointCloud._handlerIndex = -1;
            pointCloud._handler = null;
            this._pointClouds.splice(index, 1);
            this.reindexPointCloudArray(index);
        }
    }

    reindexPointCloudArray(startIndex) {
        var pc = this._pointClouds;
        for (var i = startIndex; i < pc.length; i++) {
            pc[i]._handlerIndex = i;
        }
    }

    draw() {
        var i = this._pointClouds.length;
        while (i--) {
            this._pointClouds[i].draw();
        }
    }

    drawPicking() {
        if (this.pickingEnabled) {
            var i = this._pointClouds.length;
            while (i--) {
                this._pointClouds[i].drawPicking();
            }
        }
    }

    clear() {
        var i = this._pointClouds.length;
        while (i--) {
            this._pointClouds[i]._deleteBuffers();
            this._pointClouds[i]._handler = null;
            this._pointClouds[i]._handlerIndex = -1;
        }
        this._pointClouds.length = 0;
        this._pointClouds = [];
    }
};



/***/ }),

/***/ "./src/og/entity/Polyline.js":
/*!***********************************!*\
  !*** ./src/og/entity/Polyline.js ***!
  \***********************************/
/*! exports provided: Polyline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/**
 * @module og/entity/Polyline
 */









const VERTICES_BUFFER = 0;
const INDEX_BUFFER = 1;

/**
 * Polyline object.
 * @class
 * @param {Object} [options] - Polyline options:
 * @param {number} [options.thickness] - Thickness in screen pixels 1.5 is default.
 * @param {og.math.Vector4} [options.color] - RGBA color.
 * @param {Boolean} [options.visibility] - Polyline visibility. True default.
 * @param {Boolean} [options.isClosed] - Closed geometry type identificator.
 * @param {Array.<Array.<number,number,number>>} [options.pathLonLat] - Polyline geodetic coordinates array.
 * @param {Array.<Array.<number,number,number>>} [options.path3v] - LinesString cartesian coordinates array. Like path:[[0,0,0], [1,1,1],...]
 */
class Polyline {
    constructor(options) {

        options = options || {};

        /**
         * Object unic identifier.
         * @public
         * @readonly
         * @type {number}
         */
        this.id = Polyline._staticCounter++;

        this.altitude = 0.0;

        /**
         * Polyline thickness in screen pixels.
         * @public
         * @type {number}
         */
        this.thickness = options.thickness || 1.5;

        /**
         * Polyline RGBA color.
         * @public
         * @type {og.math.Vector4}
         */
        this.color = og.utils.createColorRGBA(options.color, new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_4__["Vec4"](1.0, 1.0, 1.0, 1.0));

        /**
         * Polyline visibility.
         * @public
         * @type {boolean}
         */
        this.visibility = (options.visibility != undefined ? options.visibility : true);

        /**
         * Polyline geometry ring type identificator.
         * @protected
         * @type {Boolean}
         */
        this._closedLine = options.isClosed || false;

        /**
         * Polyline cartesian coordinates.
         * @private
         * @type {Array.<og.math.Vector3>}
         */
        this._path3v = [];

        /**
         * Polyline geodetic degrees coordiantes.
         * @private
         * @type {Array.<og.LonLat>}
         */
        this._pathLonLat = [];

        /**
         * Polyline geodetic mercator coordinates.
         * @private
         * @type {Array.<og.LonLat>}
         */
        this._pathLonLatMerc = [];

        /**
         * Polyline geodetic extent.
         * @protected
         * @type {og.Extent}
         */
        this._extent = new _Extent_js__WEBPACK_IMPORTED_MODULE_1__["Extent"]();

        this._vertices = [];
        this._orders = [];
        this._indexes = [];

        this._verticesBuffer = null;
        this._ordersBuffer = null;
        this._indexesBuffer = null;

        this._pickingColor = [0, 0, 0];

        this._renderNode = null;

        /**
         * Entity instance that holds this Polyline.
         * @private
         * @type {og.Entity}
         */
        this._entity = null;

        /**
         * Handler that stores and renders this Polyline object.
         * @private
         * @type {og.PolylineHandler}
         */
        this._handler = null;
        this._handlerIndex = -1;

        this._buffersUpdateCallbacks = [];
        this._buffersUpdateCallbacks[VERTICES_BUFFER] = this._createVerticesBuffer;
        this._buffersUpdateCallbacks[INDEX_BUFFER] = this._createIndexBuffer;

        this._changedBuffers = new Array(this._buffersUpdateCallbacks.length);

        //create path
        if (options.pathLonLat) {
            this.setPathLonLat(options.pathLonLat);
        } else if (options.path3v) {
            this.setPath3v(options.path3v);
        }

        this._refresh();
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }


    /**
     * Appends to the line arrays new data from cartesian coordinates.
     * @param {Array.<Array.<number, number, number>>} path3v - Line coordinates path array.
     * @param {Boolean} isClosed - Identificator for the closed line data creation.
     * @param {Number[]} outVertices - Out vertices data array.
     * @param {Number[]} outOrders - Out vertices orders data array.
     * @param {Number[]} outIndexes - Out vertices indexes data array.
     * @param {og.Ellipsoid} [ellipsoid] - Ellipsoid to coordinates transformation.
     * @param {Array.<Array.<og.LonLat>>} [outTransformedPathLonLat] - Geodetic coordinates out array.
     * @param {Array.<Array.<og.LonLat>>} [outTransformedPathMerc] - Mercator coordinates out array.
     * @param {og.Extent} outExtent - Geodetic line extent.
     * @static
     */
    static appendLineData3v(path3v, isClosed, outVertices, outOrders, outIndexes,
        ellipsoid, outTransformedPathLonLat, outPath3v, outTransformedPathMerc, outExtent) {
        var index = 0;
        if (outExtent) {
            outExtent.southWest.set(180, 90);
            outExtent.northEast.set(-180, -90);
        }

        if (outIndexes.length > 0) {
            index = outIndexes[outIndexes.length - 5] + 9;
            outIndexes.push(index, index);
        } else {
            outIndexes.push(0, 0);
        }

        for (var j = 0; j < path3v.length; j++) {
            var path = path3v[j];

            outTransformedPathLonLat[j] = [];
            outTransformedPathMerc[j] = [];
            outPath3v[j] = [];

            var startIndex = index;

            var last;
            if (isClosed) {
                last = path[path.length - 1];
                if (last.constructor === Array) {
                    last = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](last[0], last[1], last[2]);
                }
            } else {
                var p0 = path[0],
                    p1 = path[1];
                if (p0.constructor === Array) {
                    p0 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0[0], p0[1], p0[2]);
                }
                if (p1.constructor === Array) {
                    p1 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p1[0], p1[1], p1[2]);
                }
                last = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }

            outVertices.push(last.x, last.y, last.z, last.x, last.y, last.z, last.x, last.y, last.z, last.x, last.y, last.z);
            outOrders.push(1, -1, 2, -2);

            for (var i = 0; i < path.length; i++) {
                var cur = path[i];
                if (cur.constructor === Array) {
                    cur = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](cur[0], cur[1], cur[2]);
                }
                if (ellipsoid) {
                    var lonLat = ellipsoid.cartesianToLonLat(cur);
                    outTransformedPathLonLat[j].push(lonLat);
                    outPath3v[j].push(cur);
                    outTransformedPathMerc[j].push(lonLat.forwardMercator());

                    if (lonLat.lon < outExtent.southWest.lon)
                        outExtent.southWest.lon = lonLat.lon;
                    if (lonLat.lat < outExtent.southWest.lat)
                        outExtent.southWest.lat = lonLat.lat;
                    if (lonLat.lon > outExtent.northEast.lon)
                        outExtent.northEast.lon = lonLat.lon;
                    if (lonLat.lat > outExtent.northEast.lat)
                        outExtent.northEast.lat = lonLat.lat;
                }
                outVertices.push(cur.x, cur.y, cur.z, cur.x, cur.y, cur.z, cur.x, cur.y, cur.z, cur.x, cur.y, cur.z);
                outOrders.push(1, -1, 2, -2);
                outIndexes.push(index++, index++, index++, index++);
            }

            var first;
            if (isClosed) {
                first = path[0];
                if (first.constructor === Array) {
                    first = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](first[0], first[1], first[2]);
                }
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            } else {
                var p0 = path[path.length - 1],
                    p1 = path[path.length - 2];
                if (p0.constructor === Array) {
                    p0 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0[0], p0[1], p0[2]);
                }
                if (p1.constructor === Array) {
                    p1 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p1[0], p1[1], p1[2]);
                }
                first = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }

            outVertices.push(first.x, first.y, first.z, first.x, first.y, first.z, first.x, first.y, first.z, first.x, first.y, first.z);
            outOrders.push(1, -1, 2, -2);

            if (j < path3v.length - 1) {
                index += 8;
                outIndexes.push(index, index);
            }
        }
    }

    /**
     * Appends to the line arrays new data from geodetic coordinates.
     * @param {Array.<Array.<number, number, number>>} pathLonLat - Line geodetic coordinates path array.
     * @param {Boolean} isClosed - Identificator for the closed line data creation.
     * @param {Number[]} outVertices - Out vertices data array.
     * @param {Number[]} outOrders - Out vertices orders data array.
     * @param {Number[]} outIndexes - Out indexes data array.
     * @param {og.Ellipsoid} ellipsoid - Ellipsoid to coordinates transformation.
     * @param {Array.<Array.<Number, Number, Number>>} outTransformedPathCartesian - Cartesian coordinates out array.
     * @param {Array.<Array.<og.LonLat>>} outTransformedPathMerc - Mercator coordinates out array.
     * @param {og.Extent} outExtent - Geodetic line extent.
     * @static
     */
    static appendLineDataLonLat(pathLonLat, isClosed, outVertices, outOrders, outIndexes,
        ellipsoid, outTransformedPathCartesian, outPathLonLat, outTransformedPathMerc, outExtent) {
        var index = 0;
        if (outExtent) {
            outExtent.southWest.set(180, 90);
            outExtent.northEast.set(-180, -90);
        }

        if (outIndexes.length > 0) {
            index = outIndexes[outIndexes.length - 5] + 9;
            outIndexes.push(index, index);
        } else {
            outIndexes.push(0, 0);
        }

        for (var j = 0; j < pathLonLat.length; j++) {
            var path = pathLonLat[j];
            var startIndex = index;

            outTransformedPathCartesian[j] = [];
            outTransformedPathMerc[j] = [];
            outPathLonLat[j] = [];

            var last;
            if (isClosed) {
                var pp = path[path.length - 1];
                if (pp instanceof Array) {
                    last = ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](pp[0], pp[1], pp[2]));
                } else {
                    last = ellipsoid.lonLatToCartesian(pp);
                }
            } else {
                var p0, p1;
                var pp = path[0];
                if (pp instanceof Array) {
                    p0 = ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](pp[0], pp[1], pp[2]));
                } else {
                    p0 = ellipsoid.lonLatToCartesian(pp);
                }

                pp = path[1];
                if (pp instanceof Array) {
                    p1 = ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](pp[0], pp[1], pp[2]));
                } else {
                    p1 = ellipsoid.lonLatToCartesian(pp);
                }

                last = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }

            outVertices.push(last.x, last.y, last.z, last.x, last.y, last.z, last.x, last.y, last.z, last.x, last.y, last.z);
            outOrders.push(1, -1, 2, -2);

            for (var i = 0; i < path.length; i++) {
                var cur = path[i];
                if (cur instanceof Array) {
                    cur = new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](cur[0], cur[1], cur[2]);
                }

                var cartesian = ellipsoid.lonLatToCartesian(cur);
                outTransformedPathCartesian[j].push(cartesian);
                outPathLonLat[j].push(cur);
                outTransformedPathMerc[j].push(cur.forwardMercator());

                outVertices.push(cartesian.x, cartesian.y, cartesian.z, cartesian.x, cartesian.y, cartesian.z,
                    cartesian.x, cartesian.y, cartesian.z, cartesian.x, cartesian.y, cartesian.z);
                outOrders.push(1, -1, 2, -2);
                outIndexes.push(index++, index++, index++, index++);

                if (cur.lon < outExtent.southWest.lon)
                    outExtent.southWest.lon = cur.lon;
                if (cur.lat < outExtent.southWest.lat)
                    outExtent.southWest.lat = cur.lat;
                if (cur.lon > outExtent.northEast.lon)
                    outExtent.northEast.lon = cur.lon;
                if (cur.lat > outExtent.northEast.lat)
                    outExtent.northEast.lat = cur.lat;
            }

            var first;
            if (isClosed) {
                var pp = path[0];
                if (pp instanceof Array) {
                    first = ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](pp[0], pp[1], pp[2]));
                } else {
                    first = ellipsoid.lonLatToCartesian(pp);
                }
                outIndexes.push(startIndex, startIndex + 1, startIndex + 1, startIndex + 1);
            } else {
                var pp;
                var p0, p1;
                pp = path[path.length - 1];
                if (pp instanceof Array) {
                    p0 = ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](pp[0], pp[1], pp[2]));
                } else {
                    p0 = ellipsoid.lonLatToCartesian(pp);
                }

                pp = path[path.length - 2];
                if (pp instanceof Array) {
                    p1 = ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_2__["LonLat"](pp[0], pp[1], pp[2]));
                } else {
                    p1 = ellipsoid.lonLatToCartesian(pp);
                }
                first = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
                outIndexes.push(index - 1, index - 1, index - 1, index - 1);
            }

            outVertices.push(first.x, first.y, first.z, first.x, first.y, first.z, first.x, first.y, first.z, first.x, first.y, first.z);
            outOrders.push(1, -1, 2, -2);

            if (j < pathLonLat.length - 1) {
                index += 8;
                outIndexes.push(index, index);
            }
        }
    }

    /**
     * Sets polyline path with cartesian coordinates.
     * @protected
     * @param {pg.math.Vector3[]} path3v - Cartesian coordinates.
     */
    _setEqualPath3v(path3v) {

        var extent = this._extent;
        extent.southWest.set(180, 90);
        extent.northEast.set(-180, -90);

        var v = this._vertices,
            l = this._pathLonLat,
            m = this._pathLonLatMerc,
            k = 0;

        var ellipsoid = this._renderNode.ellipsoid;

        for (var j = 0; j < path3v.length; j++) {
            var path = path3v[j];

            var last;
            if (this._closedLine) {
                last = path[path.length - 1]
            } else {
                last = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](path[0].x + path[0].x - path[1].x, path[0].y + path[0].y - path[1].y, path[0].z + path[0].z - path[1].z);
            }

            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;
            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;
            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;
            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;

            for (var i = 0; i < path.length; i++) {
                var cur = path[i];
                if (ellipsoid) {
                    var lonLat = ellipsoid.cartesianToLonLat(cur);
                    l[j][i] = lonLat;
                    m[j][i] = lonLat.forwardMercator();

                    if (lonLat.lon < extent.southWest.lon)
                        extent.southWest.lon = lonLat.lon;
                    if (lonLat.lat < extent.southWest.lat)
                        extent.southWest.lat = lonLat.lat;
                    if (lonLat.lon > extent.northEast.lon)
                        extent.northEast.lon = lonLat.lon;
                    if (lonLat.lat > extent.northEast.lat)
                        extent.northEast.lat = lonLat.lat;
                }
                v[k++] = cur.x;
                v[k++] = cur.y;
                v[k++] = cur.z;
                v[k++] = cur.x;
                v[k++] = cur.y;
                v[k++] = cur.z;
                v[k++] = cur.x;
                v[k++] = cur.y;
                v[k++] = cur.z;
                v[k++] = cur.x;
                v[k++] = cur.y;
                v[k++] = cur.z;
            }

            var first;
            if (this._closedLine) {
                first = path[0];
            } else {
                var l1 = path.length - 1;
                first = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](path[l1].x + path[l1].x - path[l1 - 1].x, path[l1].y + path[l1].y - path[l1 - 1].y,
                    path[l1].z + path[l1].z - path[l1 - 1].z);
            }

            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
        }
    };

    /**
     * Sets polyline with geodetic coordinates. 
     * @protected
     * @param {og.LonLat[]} pathLonLat - Geodetic polyline path coordinates.
     */
    _setEqualPathLonLat(pathLonLat) {

        var extent = this._extent;
        extent.southWest.set(180, 90);
        extent.northEast.set(-180, -90);

        var v = this._vertices,
            l = this._pathLonLat,
            m = this._pathLonLatMerc,
            c = this._path3v,
            k = 0;

        var ellipsoid = this._renderNode.ellipsoid;

        for (var j = 0; j < pathLonLat.length; j++) {
            var path = pathLonLat[j];

            var last;
            if (this._closedLine) {
                last = ellipsoid.lonLatToCartesian(path[path.length - 1]);
            } else {
                var p0 = ellipsoid.lonLatToCartesian(path[0]),
                    p1 = ellipsoid.lonLatToCartesian(path[1]);
                last = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }

            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;
            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;
            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;
            v[k++] = last.x;
            v[k++] = last.y;
            v[k++] = last.z;

            for (var i = 0; i < path.length; i++) {
                var cur = path[i];
                cartesian = ellipsoid.lonLatToCartesian(cur);
                c[j][i] = cartesian;
                m[j][i] = cur.forwardMercator();
                l[j][i] = cur;
                v[k++] = cartesian.x;
                v[k++] = cartesian.y;
                v[k++] = cartesian.z;
                v[k++] = cartesian.x;
                v[k++] = cartesian.y;
                v[k++] = cartesian.z;
                v[k++] = cartesian.x;
                v[k++] = cartesian.y;
                v[k++] = cartesian.z;
                v[k++] = cartesian.x;
                v[k++] = cartesian.y;
                v[k++] = cartesian.z;

                if (cur.lon < extent.southWest.lon)
                    extent.southWest.lon = cur.lon;
                if (cur.lat < extent.southWest.lat)
                    extent.southWest.lat = cur.lat;
                if (cur.lon > extent.northEast.lon)
                    extent.northEast.lon = cur.lon;
                if (cur.lat > extent.northEast.lat)
                    extent.northEast.lat = cur.lat;
            }

            var first;
            if (this._closedLine) {
                first = ellipsoid.lonLatToCartesian(path[0]);
            } else {
                var p0 = ellipsoid.lonLatToCartesian(path[path.length - 1]),
                    p1 = ellipsoid.lonLatToCartesian(path[path.length - 2]);
                first = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](p0.x + p0.x - p1.x, p0.y + p0.y - p1.y, p0.z + p0.z - p1.z);
            }

            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
            v[k++] = first.x;
            v[k++] = first.y;
            v[k++] = first.z;
        }
    };

    setPoint3v(coordinates, index, segmentIndex, forceLonLat) {
        segmentIndex = segmentIndex || 0;
        if (this._renderNode) {
            var v = this._vertices,
                l = this._pathLonLat,
                m = this._pathLonLatMerc,
                k = 0, kk = 0;

            for (var i = 0; i < segmentIndex; i++) {
                kk += this._path3v[i].length * 12 + 24;
            }

            var path = this._path3v[segmentIndex];

            path[index].x = coordinates.x;
            path[index].y = coordinates.y;
            path[index].z = coordinates.z;

            if (index === 0 || index === 1) {
                var last;
                if (this._closedLine) {
                    last = path[path.length - 1]
                } else {
                    last = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](path[0].x + path[0].x - path[1].x, path[0].y + path[0].y - path[1].y, path[0].z + path[0].z - path[1].z);
                }

                k = kk;

                v[k] = last.x;
                v[k + 1] = last.y;
                v[k + 2] = last.z;
                v[k + 3] = last.x;
                v[k + 4] = last.y;
                v[k + 5] = last.z;
                v[k + 6] = last.x;
                v[k + 7] = last.y;
                v[k + 8] = last.z;
                v[k + 9] = last.x;
                v[k + 10] = last.y;
                v[k + 11] = last.z;
            }

            if (!forceLonLat && this._renderNode.ellipsoid) {
                var lonLat = this._renderNode.ellipsoid.cartesianToLonLat(coordinates);
                l[segmentIndex][index] = lonLat;
                m[segmentIndex][index] = lonLat.forwardMercator();

                //
                // Apply new extent(TODO: think about optimization)
                //
                var extent = this._extent;
                extent.southWest.set(180, 90);
                extent.northEast.set(-180, -90);
                for (var i = 0; i < l.length; i++) {
                    var pi = l[i];
                    for (var j = 0; j < pi.length; j++) {
                        var lon = pi[j].lon,
                            lat = pi[j].lat;
                        if (lon > extent.northEast.lon)
                            extent.northEast.lon = lon;
                        if (lat > extent.northEast.lat)
                            extent.northEast.lat = lat;
                        if (lon < extent.southWest.lon)
                            extent.southWest.lon = lon;
                        if (lat < extent.southWest.lat)
                            extent.southWest.lat = lat;
                    }
                }
            }

            k = kk + index * 12 + 12;

            v[k] = coordinates.x;
            v[k + 1] = coordinates.y;
            v[k + 2] = coordinates.z;
            v[k + 3] = coordinates.x;
            v[k + 4] = coordinates.y;
            v[k + 5] = coordinates.z;
            v[k + 6] = coordinates.x;
            v[k + 7] = coordinates.y;
            v[k + 8] = coordinates.z;
            v[k + 9] = coordinates.x;
            v[k + 10] = coordinates.y;
            v[k + 11] = coordinates.z;

            if (index === path.length - 1 || index === path.length - 2) {
                var first;
                if (this._closedLine) {
                    first = path[0];
                } else {
                    var l1 = path.length - 1;
                    first = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_3__["Vec3"](path[l1].x + path[l1].x - path[l1 - 1].x, path[l1].y + path[l1].y - path[l1 - 1].y,
                        path[l1].z + path[l1].z - path[l1 - 1].z);
                }

                k = kk + path.length * 12 + 12;

                v[k] = first.x;
                v[k + 1] = first.y;
                v[k + 2] = first.z;
                v[k + 3] = first.x;
                v[k + 4] = first.y;
                v[k + 5] = first.z;
                v[k + 6] = first.x;
                v[k + 7] = first.y;
                v[k + 8] = first.z;
                v[k + 9] = first.x;
                v[k + 10] = first.y;
                v[k + 11] = first.z;
            }

            this._changedBuffers[VERTICES_BUFFER] = true;
        } else {
            var path = this._path3v[segmentIndex];
            path[index].x = coordinates.x;
            path[index].y = coordinates.y;
            path[index].z = coordinates.z;
        }
    };

    /**
     * Adds a new cartesian point in the end of the path.
     * @public
     * @param {og.math.Vector3} point3v - New coordinate.
     * @param {number} [multiLineIndex=0] - Path part index, first by default.
     */
    addPoint3v(point3v, multiLineIndex) {
        multiLineIndex = multiLineIndex || 0;

    }

    /**
     * Adds a new geodetic point in the end of the path.
     * @public
     * @param {og.LonLat} lonlat - New coordinate.
     * @param {number} [multiLineIndex=0] - Path part index, first by default.
     */
    addPointLonLat(lonLat, multiLineIndex) {
        multiLineIndex = multiLineIndex || 0;
    }

    /**
     * Clear Polyline object data.
     * @public
     */
    clear() {
        this._vertices.length = 0;
        this._orders.length = 0;
        this._indexes.length = 0;
        this._vertices = [];
        this._orders = [];
        this._indexes = [];

        this._deleteBuffers();
    }

    /**
     * Sets Polyline color.
     * @public
     * @param {String} htmlColor - HTML color.
     * @param {number} opacity - Opacity.
     */
    setColorHTML(htmlColor, opacity) {
        this.color = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["htmlColorToRgba"](htmlColor);
        opacity && (this.color.w = opacity);
    }

    /**
     * Sets Polyline RGBA color.
     * @public
     * @param {number} r - Red color.
     * @param {number} g - Green color.
     * @param {number} b - Blue color.
     * @param {number} [a] - Opacity.
     */
    setColor(r, g, b, a) {
        this.color.x = r;
        this.color.y = g;
        this.color.z = b;
        a && (this.color.w = a);
    }

    /**
     * Sets Polyline RGB color.
     * @public
     * @param {og.math.Vector3} color - RGB color.
     */
    setColor3v(color) {
        this.color.x = color.x;
        this.color.y = color.y;
        this.color.z = color.z;
    }

    /**
     * Sets Polyline RGBA color.
     * @public
     * @param {og.math.Vector4} color - RGBA color.
     */
    setColor4v(color) {
        this.color.x = color.x;
        this.color.y = color.y;
        this.color.z = color.z;
        this.color.w = color.w;
    }

    /**
     * Sets Polyline opacity.
     * @public
     * @param {number} opacity - Opacity.
     */
    setOpacity(opacity) {
        this.color.w = opacity;
    }

    /**
     * Sets Polyline thickness in screen pixels.
     * @public
     * @param {number} thickness - Thickness.
     */
    setThickness(thickness) {
        this.thickness = thickness;
    }

    /**
     * Returns thickness.
     * @public
     * @return {number} Thickness in screen pixels.
     */
    getThickness() {
        return this.thickness;
    }

    /**
     * Sets visibility.
     * @public
     * @param {boolean} visibility - Polyline visibility.
     */
    setVisibility(visibility) {
        this.visibility = visibility;
    }

    /**
     * Gets Polyline visibility.
     * @public
     * @return {boolean} Polyline visibility.
     */
    getVisibility() {
        return this.visibility;
    }

    /**
     * Assign with render node.
     * @public
     */
    setRenderNode(renderNode) {
        this._renderNode = renderNode;
        if (this._pathLonLat.length) {
            this._createDataLonLat([].concat(this._pathLonLat));
        } else {
            this._createData3v([].concat(this._path3v));
        }
    }

    /**
     * @protected
     */
    _clearData() {
        this._vertices.length = 0;
        this._orders.length = 0;
        this._indexes.length = 0;

        this._vertices = [];
        this._orders = [];
        this._indexes = [];

        this._path3v.length = 0;
        this._pathLonLat.length = 0;
        this._pathLonLatMerc.length = 0;

        this._path3v = [];
        this._pathLonLat = [];
        this._pathLonLatMerc = [];
    }

    /**
     * @protected
     */
    _createData3v(path3v) {
        this._clearData();
        Polyline.appendLineData3v(path3v, this._closedLine, this._vertices, this._orders, this._indexes,
            this._renderNode.ellipsoid, this._pathLonLat, this._path3v, this._pathLonLatMerc, this._extent);
    }

    /**
     * @protected
     */
    _createDataLonLat(pathLonlat) {
        this._clearData();
        Polyline.appendLineDataLonLat(pathLonlat, this._closedLine, this._vertices, this._orders, this._indexes,
            this._renderNode.ellipsoid, this._path3v, this._pathLonLat, this._pathLonLatMerc, this._extent);
    };


    /**
     * Removes from an entity.
     * @public
     */
    remove() {
        this._entity = null;
        this.clear();
        this._handler && this._handler.remove(this);
    }

    setPickingColor3v(color) {
        this._pickingColor[0] = color.x / 255.0;
        this._pickingColor[1] = color.y / 255.0;
        this._pickingColor[2] = color.z / 255.0;
    }

    /**
     * Returns polyline geodetic extent.
     * @public
     * @returns {og.Extent} - Geodetic extent
     */
    getExtent() {
        return this._extent.clone();
    }

    /**
     * Returns path cartesian coordinates.
     * @return {Array.<og.math.Vector3>} Polyline path.
     */
    getPath3v() {
        return this._path3v;
    }

    /**
     * Returns geodetic path coordinates.
     * @return {Array.<og.LonLat>} Polyline path.
     */
    getPathLonLat() {
        return this._pathLonLat;
    }

    /**
     * Sets geodetic coordinates.
     * @public
     * @param {Array.<Array.<number,number,number>>} path - Polyline path cartesian coordinates.
     */
    setPathLonLat(pathLonLat, forceEqual) {
        if (this._renderNode && this._renderNode.ellipsoid) {
            if (forceEqual) {
                this._setEqualPathLonLat(pathLonLat);
                this._changedBuffers[VERTICES_BUFFER] = true;
            } else {
                this._createDataLonLat(pathLonLat);
                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[INDEX_BUFFER] = true;
            }
        } else {
            this._pathLonLat = [].concat(pathLonLat);
        }
    }

    /**
     * Sets Polyline cartesian coordinates.
     * @public
     * @param {Array.<Array.<number,number,number>>} path - Polyline path cartesian coordinates.
     */
    setPath3v(path3v, forceEqual) {
        if (this._renderNode) {
            if (forceEqual) {
                this._setEqualPath3v(path3v);
                this._changedBuffers[VERTICES_BUFFER] = true;
            } else {
                this._createData3v(path3v);
                this._changedBuffers[VERTICES_BUFFER] = true;
                this._changedBuffers[INDEX_BUFFER] = true;
            }
        } else {
            this._path3v = [].concat(path3v);
        }
    }

    draw() {
        if (this.visibility && this._path3v.length) {

            this._update();

            var rn = this._renderNode;
            var r = rn.renderer;
            var sh = r.handler.shaderPrograms.polyline;
            var p = sh._program;
            var gl = r.handler.gl,
                sha = p.attributes,
                shu = p.uniforms;

            sh.activate();

            gl.enable(gl.BLEND);
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.CULL_FACE);

            gl.uniformMatrix4fv(shu.proj._pName, false, r.activeCamera._projectionMatrix._m);
            gl.uniformMatrix4fv(shu.view._pName, false, r.activeCamera._viewMatrix._m);

            if (r.isMultiFramebufferCompatible()) {
                gl.uniform3fv(shu.pickingColor._pName, [this._pickingColor[0], this._pickingColor[1], this._pickingColor[2]]);
            }

            gl.uniform4fv(shu.color._pName, this.color.toVec());
            gl.uniform3fv(shu.uCamPos._pName, r.activeCamera.eye.toVec());
            gl.uniform2fv(shu.uFloatParams._pName, [rn._planetRadius2 || 0.0, r.activeCamera._tanViewAngle_hradOneByHeight]);
            gl.uniform2fv(shu.viewport._pName, [r.handler.canvas.width, r.handler.canvas.height]);
            gl.uniform1f(shu.thickness._pName, this.thickness * 0.5);

            var v = this._verticesBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            gl.vertexAttribPointer(sha.prev._pName, v.itemSize, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(sha.current._pName, v.itemSize, gl.FLOAT, false, 12, 48);
            gl.vertexAttribPointer(sha.next._pName, v.itemSize, gl.FLOAT, false, 12, 96);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
            gl.vertexAttribPointer(sha.order._pName, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);
        }
    }

    drawPicking() {
        if (this.visibility && this._path3v.length) {

            var rn = this._renderNode;
            var r = rn.renderer;
            var sh = r.handler.shaderPrograms.polyline;
            var p = sh._program;
            var gl = r.handler.gl,
                sha = p.attributes,
                shu = p.uniforms;

            sh.activate();

            gl.disable(gl.BLEND);
            gl.disable(gl.CULL_FACE);

            gl.uniformMatrix4fv(shu.proj._pName, false, r.activeCamera._projectionMatrix._m);
            gl.uniformMatrix4fv(shu.view._pName, false, r.activeCamera._viewMatrix._m);

            gl.uniform4fv(shu.color._pName, [this._pickingColor[0], this._pickingColor[1], this._pickingColor[2], 1.0]);
            gl.uniform3fv(shu.uCamPos._pName, r.activeCamera.eye.toVec());
            gl.uniform2fv(shu.uFloatParams._pName, [rn._planetRadius2 || 0.0, r.activeCamera._tanViewAngle_hradOneByHeight]);
            gl.uniform2fv(shu.viewport._pName, [r.handler.canvas.width, r.handler.canvas.height]);
            gl.uniform1f(shu.thickness._pName, this.thickness * 0.5);

            var v = this._verticesBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, v);
            gl.vertexAttribPointer(sha.prev._pName, v.itemSize, gl.FLOAT, false, 12, 0);
            gl.vertexAttribPointer(sha.current._pName, v.itemSize, gl.FLOAT, false, 12, 48);
            gl.vertexAttribPointer(sha.next._pName, v.itemSize, gl.FLOAT, false, 12, 96);

            gl.bindBuffer(gl.ARRAY_BUFFER, this._ordersBuffer);
            gl.vertexAttribPointer(sha.order._pName, this._ordersBuffer.itemSize, gl.FLOAT, false, 4, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexesBuffer);
            gl.drawElements(gl.TRIANGLE_STRIP, this._indexesBuffer.numItems, gl.UNSIGNED_INT, 0);

            gl.enable(gl.CULL_FACE);
            gl.enable(gl.BLEND);
        }
    }

    /**
     * Refresh buffers.
     * @protected
     */
    _refresh() {
        var i = this._changedBuffers.length;
        while (i--) {
            this._changedBuffers[i] = true;
        }
    }


    /**
     * Updates render buffers.
     * @protected
     */
    _update() {
        if (this._renderNode) {
            var i = this._changedBuffers.length;
            while (i--) {
                if (this._changedBuffers[i]) {
                    this._buffersUpdateCallbacks[i].call(this);
                    this._changedBuffers[i] = false;
                }
            }
        }
    }

    /**
     * Clear GL buffers.
     * @protected
     */
    _deleteBuffers() {
        if (this._renderNode) {
            var r = this._renderNode.renderer,
                gl = r.handler.gl;

            gl.deleteBuffer(this._verticesBuffer);
            gl.deleteBuffer(this._ordersBuffer);
            gl.deleteBuffer(this._indexesBuffer);

            this._verticesBuffer = null;
            this._ordersBuffer = null;
            this._indexesBuffer = null;
        }
    }

    /**
     * Creates gl main data buffer.
     * @protected
     */
    _createVerticesBuffer() {
        var h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = h.createArrayBuffer(new Float32Array(this._vertices), 3, this._vertices.length / 3);
    }

    /**
     * Creates gl index and order buffer.
     * @protected
     */
    _createIndexBuffer() {
        var h = this._renderNode.renderer.handler;
        h.gl.deleteBuffer(this._ordersBuffer);
        h.gl.deleteBuffer(this._indexesBuffer);
        this._ordersBuffer = h.createArrayBuffer(new Float32Array(this._orders), 1, this._orders.length / 2);
        this._indexesBuffer = h.createElementArrayBuffer(new Uint32Array(this._indexes), 1, this._indexes.length);
    }
};



/***/ }),

/***/ "./src/og/entity/PolylineHandler.js":
/*!******************************************!*\
  !*** ./src/og/entity/PolylineHandler.js ***!
  \******************************************/
/*! exports provided: PolylineHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylineHandler", function() { return PolylineHandler; });
/* harmony import */ var _shaders_polyline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/polyline.js */ "./src/og/shaders/polyline.js");
/**
 * @module og/entity/PolylineHandler
 */





class PolylineHandler {
    constructor(entityCollection) {

        this._entityCollection = entityCollection;

        this._renderer = null;

        this._polylines = [];

        this.__staticId = PolylineHandler._staticCounter++;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    _initShaderProgram() {
        if (this._renderer.handler) {
            if (!this._renderer.handler.shaderPrograms.polyline) {
                this._renderer.handler.addShaderProgram(_shaders_polyline_js__WEBPACK_IMPORTED_MODULE_0__["polyline"](this._renderer.isMultiFramebufferCompatible()));
            }
        }
    }

    setRenderNode(renderNode) {
        this._renderer = renderNode.renderer;
        this._initShaderProgram()
        for (var i = 0; i < this._polylines.length; i++) {
            this._polylines[i].setRenderNode(renderNode);
        }
    }

    add(polyline) {
        if (polyline._handlerIndex == -1) {
            polyline._handler = this;
            polyline._handlerIndex = this._polylines.length;
            this._polylines.push(polyline);
            this._entityCollection && this._entityCollection.renderNode &&
                polyline.setRenderNode(this._entityCollection.renderNode);
        }
    }

    remove(polyline) {
        var index = polyline._handlerIndex;
        if (index !== -1) {
            polyline._deleteBuffers();
            polyline._handlerIndex = -1;
            polyline._handler = null;
            this._polylines.splice(index, 1);
            this.reindexPolylineArray(index);
        }
    }

    reindexPolylineArray(startIndex) {
        var ls = this._polylines;
        for (var i = startIndex; i < ls.length; i++) {
            ls[i]._handlerIndex = i;
        }
    }

    draw() {
        var i = this._polylines.length;
        while (i--) {
            this._polylines[i].draw();
        }
    }

    clear() {
        var i = this._polylines.length;
        while (i--) {
            this._polylines[i]._deleteBuffers();
            this._polylines[i]._handler = null;
            this._polylines[i]._handlerIndex = -1;
        }
        this._polylines.length = 0;
        this._polylines = [];
    }
};



/***/ }),

/***/ "./src/og/entity/ShapeHandler.js":
/*!***************************************!*\
  !*** ./src/og/entity/ShapeHandler.js ***!
  \***************************************/
/*! exports provided: ShapeHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeHandler", function() { return ShapeHandler; });
/* harmony import */ var _shaders_shape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shaders/shape.js */ "./src/og/shaders/shape.js");
/**
 * @module og/entity/ShapeHandler
 */





class ShapeHandler {
    constructor(entityCollection) {

        /**
         * Picking rendering option.
         * @public
         * @type {boolean}
         */
        this.pickingEnabled = true;

        this._entityCollection = entityCollection;

        this._renderer = null;

        this._shapes = [];

        this.__staticId = ShapeHandler._staticCounter++;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    _initShaderProgram() {
        if (this._renderer.handler) {
            if (!this._renderer.handler.shaderPrograms.shape_nl) {
                this._renderer.handler.addShaderProgram(_shaders_shape_js__WEBPACK_IMPORTED_MODULE_0__["shape_nl"]());
            }
            if (!this._renderer.handler.shaderPrograms.shape_wl) {
                this._renderer.handler.addShaderProgram(_shaders_shape_js__WEBPACK_IMPORTED_MODULE_0__["shape_wl"]());
            }
            //if (!this._renderer.handler.shaderPrograms.shapePicking) {
            //    this._renderer.handler.addShaderProgram(shaders.shapePicking());
            //}
        }
    }

    setRenderNode(renderNode) {
        this._renderer = renderNode.renderer;
        this._initShaderProgram()
        for (var i = 0; i < this._shapes.length; i++) {
            this._shapes[i].setRenderNode(renderNode);
        }
    }

    add(shape) {
        if (shape._handlerIndex == -1) {
            shape._handler = this;
            shape._handlerIndex = this._shapes.length;
            this._shapes.push(shape);
            this._entityCollection && this._entityCollection.renderNode && shape.setRenderNode(this._entityCollection.renderNode);
        }
    }

    remove(shape) {
        //TODO
    }

    draw() {
        var i = this._shapes.length;
        while (i--) {
            this._shapes[i].draw();
        }
    }

    drawPicking() {
        //TODO
    }

    clear() {
        //TODO
    }
};



/***/ }),

/***/ "./src/og/index.js":
/*!*************************!*\
  !*** ./src/og/index.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Globe_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Globe.js */ "./src/og/Globe.js");




/***/ }),

/***/ "./src/og/inherits.js":
/*!****************************!*\
  !*** ./src/og/inherits.js ***!
  \****************************/
/*! exports provided: inherits */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inherits", function() { return inherits; });
/**
 * @module og/inherits
 */

function inherits(childCtor, parentCtor) {
    childCtor.prototype = Object.create(parentCtor.prototype);
    childCtor.prototype.constructor = childCtor;
};

/***/ }),

/***/ "./src/og/input/KeyboardHandler.js":
/*!*****************************************!*\
  !*** ./src/og/input/KeyboardHandler.js ***!
  \*****************************************/
/*! exports provided: KeyboardHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyboardHandler", function() { return KeyboardHandler; });
/**
 * @module og/input/KeyboardHandler
 */



const KeyboardHandler = function () {
    var _currentlyPressedKeys = {};
    var _pressedKeysCallbacks = {};
    var _charkeysCallbacks = {};
    var _that = this;
    var _anykeyCallback = null;
    var _event = null;

    if (KeyboardHandler.prototype._instance) {
        return KeyboardHandler.prototype._instance;
    } else {
        KeyboardHandler.prototype._instance = this;

        document.onkeydown = function (event) { _event = event; _that.handleKeyDown.call(_that) };
        document.onkeyup = function (event) { _event = event; _that.handleKeyUp.call(_that) };
    }

    var _sortByPriority = function (a, b) {
        return a.priority < b.priority;
    };

    this.addEvent = function (event, sender, callback, keyCode, priority) {
        if (priority === undefined) {
            priority = 1600;
        }
        switch (event) {
            case "keypress": {
                if (keyCode == null) {
                    _anykeyCallback = { "callback": callback, "sender": sender || _that };
                } else {
                    if (!_pressedKeysCallbacks[keyCode]) {
                        _pressedKeysCallbacks[keyCode] = [];
                    }
                    _pressedKeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                    _pressedKeysCallbacks[keyCode].sort(_sortByPriority);
                }
            } break;
            case "charkeypress": {
                if (!_charkeysCallbacks[keyCode]) {
                    _charkeysCallbacks[keyCode] = [];
                }
                _charkeysCallbacks[keyCode].push({ callback: callback, sender: sender, priority: priority });
                _charkeysCallbacks[keyCode].sort(_sortByPriority);
            } break;
        }
    };

    this.isKeyPressed = function (keyCode) {
        return _currentlyPressedKeys[keyCode];
    };

    this.handleKeyDown = function () {
        _anykeyCallback && _anykeyCallback.callback.call(_anykeyCallback.sender, _event);
        _currentlyPressedKeys[_event.keyCode] = true;
        for (var ch in _charkeysCallbacks) {
            if (String.fromCharCode(_event.keyCode) == String.fromCharCode(ch)) {
                var ccl = _charkeysCallbacks[ch];
                for (var i = 0; i < ccl.length; i++) {
                    ccl[i].callback.call(ccl[i].sender, _event);
                }
            }
        }
    };

    this.handleKeyUp = function () {
        _currentlyPressedKeys[_event.keyCode] = false;
    };

    this.handleEvents = function () {
        for (var pk in _pressedKeysCallbacks) {
            if (_currentlyPressedKeys[pk]) {
                var cpk = _pressedKeysCallbacks[pk];
                for (var i = 0; i < cpk.length; i++) {
                    cpk[i].callback.call(cpk[i].sender, _event);
                }
            }
        }
    };
};



/***/ }),

/***/ "./src/og/input/MouseHandler.js":
/*!**************************************!*\
  !*** ./src/og/input/MouseHandler.js ***!
  \**************************************/
/*! exports provided: MouseHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseHandler", function() { return MouseHandler; });
/**
 * @module og/input/MouseHandler
 */



const MouseHandler = function (htmlObject) {
    this._htmlObject = htmlObject;
};

MouseHandler.prototype.setEvent = function (event, sender, callback) {
    switch (event) {
        case "mousewheel": {
            this._htmlObject.addEventListener('mousewheel', function (evt) {
                var delta = evt.deltaY || evt.detail || evt.wheelDelta;
                if (evt.wheelDelta == undefined) {
                    evt.wheelDelta = delta * (-120);
                }
                callback.call(sender, evt);
                evt.preventDefault();
            }, false);

            this._htmlObject.addEventListener('wheel', function (evt) {
                var delta = evt.deltaY || evt.detail || evt.wheelDelta;
                if (evt.wheelDelta == undefined) {
                    evt.wheelDelta = delta * (-120);
                }
                callback.call(sender, evt);
                evt.preventDefault();
            }, false);
        } break;
        case "mousedown": {
            this._htmlObject.addEventListener('mousedown', function (event) {
                callback.call(sender, event);
            });
            this._htmlObject.addEventListener('contextmenu', function (event) {
                event.preventDefault();
                return false;
            });
        } break;
        case "mouseup": {
            this._htmlObject.addEventListener('mouseup', function (event) {
                callback.call(sender, event);
            });
        } break;
        case "mousemove": {
            this._htmlObject.addEventListener('mousemove', function (event) {
                var rect = this.getBoundingClientRect();
                callback.call(sender, {
                    'clientX': event.clientX - rect.left,
                    'clientY': event.clientY - rect.top
                });
            });
        } break;
    }
};



/***/ }),

/***/ "./src/og/input/TouchHandler.js":
/*!**************************************!*\
  !*** ./src/og/input/TouchHandler.js ***!
  \**************************************/
/*! exports provided: TouchHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchHandler", function() { return TouchHandler; });
/**
 * @module og/input/TouchHandler
 */



const TouchHandler = function (htmlObject) {
    this._htmlObject = htmlObject;
};

TouchHandler.prototype.setEvent = function (event, sender, callback) {
    switch (event) {
        case "touchcancel": {
            this._htmlObject.addEventListener('touchcancel', function (event) {
                event.preventDefault();
                var rect = this.getBoundingClientRect();
                event.offsetLeft = rect.left;
                event.offsetTop = rect.top;
                callback.call(sender, event);
                event.preventDefault();
            });
        }
            break;
        case "touchstart": {
            this._htmlObject.addEventListener('touchstart', function (event) {
                event.preventDefault();
                var rect = this.getBoundingClientRect();
                event.offsetLeft = rect.left;
                event.offsetTop = rect.top;
                callback.call(sender, event);
                event.preventDefault();
            });
        } break;
        case "touchend": {
            this._htmlObject.addEventListener('touchend', function (event) {
                event.preventDefault();
                var rect = this.getBoundingClientRect();
                event.offsetLeft = rect.left;
                event.offsetTop = rect.top;
                callback.call(sender, event);
                event.preventDefault();
            });
        } break;
        case "touchmove": {
            this._htmlObject.addEventListener('touchmove', function (event) {
                event.preventDefault();
                var rect = this.getBoundingClientRect();
                event.offsetLeft = rect.left;
                event.offsetTop = rect.top;
                callback.call(sender, event);
                event.preventDefault();
            });
        } break;
    }
};



/***/ }),

/***/ "./src/og/input/input.js":
/*!*******************************!*\
  !*** ./src/og/input/input.js ***!
  \*******************************/
/*! exports provided: input */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "input", function() { return input; });
/**
 * @module og/input/input
 */



const input = {
    KEY_SHIFT: 16,
    KEY_SPACE: 32,
    KEY_LEFT: 37,
    KEY_UP: 38,
    KEY_RIGHT: 39,
    KEY_DOWN: 40,
    KEY_A: 65,
    KEY_C: 67,
    KEY_D: 68,
    KEY_E: 69,
    KEY_F: 70,
    KEY_H: 72,
    KEY_L: 76,
    KEY_Q: 81,
    KEY_S: 83,
    KEY_V: 86,
    KEY_W: 87,
    KEY_X: 88,
    KEY_F1: 112,
    KEY_APOSTROPHE: 192,
    MB_LEFT: 0,
    MB_RIGHT: 2,
    MB_MIDDLE: 1
};

/***/ }),

/***/ "./src/og/layer/Layer.js":
/*!*******************************!*\
  !*** ./src/og/layer/Layer.js ***!
  \*******************************/
/*! exports provided: Layer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return Layer; });
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _Events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Events.js */ "./src/og/Events.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Material.js */ "./src/og/layer/Material.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/layer/Layer
 */

'use sctrict';










/**
 * @classdesc
 * Base class; normally only used for creating subclasses and not instantiated in apps.
 * A visual representation of raster or vector map data well known as a layer.
 * @class
 * @param {String} [name="noname"] - Layer name.
 * @param {Object} [options] - Layer options:
 * @param {number} [options.opacity=1.0] - Layer opacity.
 * @param {Array.<number,number,number>} [options.transparentColor=[-1,-1,-1]] - RGB color that defines transparent color.
 * @param {number} [options.minZoom=0] - Minimal visibility zoom level.
 * @param {number} [options.maxZoom=0] - Maximal visibility zoom level.
 * @param {string} [options.attribution] - Layer attribution that displayed in the attribution area on the screen.
 * @param {boolean} [options.isBaseLayer=false] - This is a base layer.
 * @param {boolean} [options.visibility=true] - Layer visibility.
 * @param {og.Extent} [options.extent=[[-180.0, -90.0], [180.0, 90.0]]] - Visible extent.
 * @param {og.math.Vector3} [options.ambient=[0.1, 0.1, 0.21]] - Ambient RGB color.
 * @param {og.math.Vector3} [options.diffuse=[1.0, 1.0, 1.0]] - Diffuse RGB color.
 * @param {og.math.Vector3} [options.specular=[0.00025, 0.00015, 0.0001]] - Specular RGB color.
 * @param {Number} [options.shininess=100] - Shininess.
 *
 * @fires og.layer.Layer#visibilitychange
 * @fires og.layer.Layer#add
 * @fires og.layer.Layer#remove
 * @fires og.layer.Vector#mousemove
 * @fires og.layer.Vector#mouseenter
 * @fires og.layer.Vector#mouseleave
 * @fires og.layer.Vector#lclick
 * @fires og.layer.Vector#rclick
 * @fires og.layer.Vector#mclick
 * @fires og.layer.Vector#ldblclick
 * @fires og.layer.Vector#rdblclick
 * @fires og.layer.Vector#mdblclick
 * @fires og.layer.Vector#lup
 * @fires og.layer.Vector#rup
 * @fires og.layer.Vector#mup
 * @fires og.layer.Vector#ldown
 * @fires og.layer.Vector#rdown
 * @fires og.layer.Vector#mdown
 * @fires og.layer.Vector#lhold
 * @fires og.layer.Vector#rhold
 * @fires og.layer.Vector#mhold
 * @fires og.layer.Vector#mousewheel
 * @fires og.layer.Vector#touchmove
 * @fires og.layer.Vector#touchstart
 * @fires og.layer.Vector#touchend
 * @fires og.layer.Vector#doubletouch
 */
class Layer {
    constructor(name, options) {

        options = options || {};

        /**
         * Layer user name.
         * @public
         * @type {string}
         */
        this.name = name || "noname";

        this.displayInLayerSwitcher = options.displayInLayerSwitcher !== undefined ? options.displayInLayerSwitcher : true;

        /**
         * Layer global opacity.
         * @public
         * @type {number}
         */
        this.opacity = options.opacity || 1.0;

        /**
         * Transparent RGB color mask.
         * @public
         * @type {Array.<number,number,number>}
         */
        this.transparentColor = options.transparentColor || [-1, -1, -1];

        /**
         * Minimal zoom level when layer is visibile.
         * @public
         * @type {number}
         */
        this.minZoom = options.minZoom || 0;

        /**
         * Maximal zoom level when layer is visibile.
         * @public
         * @type {number}
         */
        this.maxZoom = options.maxZoom || 50;

        /**
         * Layer light material parameters.
         * @public
         * @type {Object}
         */
        this.ambient = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGB"](options.ambient, new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](0.1, 0.1, 0.21));
        this.diffuse = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGB"](options.diffuse, new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](1.0, 1.0, 1.0));
        this.specular = _utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createColorRGB"](options.specular, new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](0.00025, 0.00015, 0.0001));
        this.shininess = options.shininess || 100.0;

        /**
         * Planet node.
         * @protected
         * @type {og.scene.Planet}
         */
        this._planet = null;

        /**
         * Unic identifier.
         * @protected
         * @type {number}
         */
        this._id = Layer.__layersCounter++;

        /**
         * Layer attribution.
         * @protected
         * @type {string}
         */
        this._attribution = options.attribution || "";

        /**
         * Layer z-index.
         * @protected
         * @type {number}
         */
        this._zIndex = options.zIndex || 0;

        /**
         * Base layer type flag.
         * @protected
         * @type {boolean}
         */
        this._isBaseLayer = options.isBaseLayer || false;

        /**
         * Layer visibility.
         * @protected
         * @type {boolean}
         */
        this._visibility = options.visibility !== undefined ? options.visibility : true;

        /**
         * Height over the ground.
         * @protected
         * @type {number}
         */
        this._height = options.height || 0;

        /**
         * Visible degrees extent.
         * @protected
         * @type {og.Extent}
         */
        this._extent = null;

        /**
         * Visible mercator extent.
         * @protected
         * @type {og.Extent}
         */
        this._extentMerc = null;

        //Setting the extent up
        this.setExtent(_utils_shared_js__WEBPACK_IMPORTED_MODULE_0__["createExtent"](options.extent, new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](-180, -90), new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](180, 90))));

        /**
         * Layer picking color. Assign when added to the planet.
         * @protected
         * @type {og.math.Vector3}
         */
        this._pickingColor = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"]();

        /**
         * Events handler.
         * @public
         * @type {og.Events}
         */
        this.events = new _Events_js__WEBPACK_IMPORTED_MODULE_2__["Events"]();
        this.events.registerNames(EVENT_NAMES);
    }

    static getTileIndex(...arr) {
        return arr.join("_");
    }

    static get __layersCounter() {
        if (!this.__lcounter && this.__lcounter !== 0) {
            this.__lcounter = 0;
        }
        return this.__lcounter;
    }

    static set __layersCounter(n) {
        this.__lcounter = n;
    }

    /**
     * Returns true if a layer has imagery tiles.
     * @public
     * @virtual
     * @returns {boolean} - Imagery tiles flag.
     */
    hasImageryTiles() {
        return true;
    }

    /**
     * Gets layer identifier.
     * @public
     * @returns {string} - Layer object id.
     */
    getID() {
        return this._id;
    }

    /**
     * Compares layers instances.
     * @public
     * @param {og.layer.Layer} layer - Layer instance to compare.
     * @returns {boolean} - Returns true if the layers is the same instance of the input.
     */
    isEqual(layer) {
        return layer._id === this._id;
    }

    /**
     * Assign the planet.
     * @protected
     * @virtual
     * @param {og.scene.Planet} planet - Planet render node.
     */
    _assignPlanet(planet) {
        planet.layers.push(this);
        this._planet = planet;
        this.events.on("visibilitychange", planet._onLayerVisibilityChanged, planet);
        if (this._isBaseLayer && this._visibility) {
            planet.setBaseLayer(this);
        }
        planet.events.dispatch(planet.events.layeradd, this);
        this.events.dispatch(this.events.add, planet);
        planet.updateVisibleLayers();
        this._bindPicking();
    }

    /**
     * Assign picking color to the layer.
     * @protected
     * @virtual
     */
    _bindPicking() {
        this._planet && this._planet.renderer.assignPickingColor(this);
    }

    /**
     * Adds layer to the planet.
     * @public
     * @param {og.scene.Planet} planet - Adds layer to the planet.
     */
    addTo(planet) {
        this._assignPlanet(planet);
    }

    /**
     * Removes from planet.
     * @public
     * @returns {og.layer.Layer} -This layer.
     */
    remove() {
        var p = this._planet;
        if (p) {
            var lid = this._id;
            for (var i = 0; i < p.layers.length; i++) {
                if (p.layers[i]._id === lid) {
                    p.renderer.clearPickingColor(this);
                    p.layers.splice(i, 1);
                    p.updateVisibleLayers();
                    this.clear();
                    p.events.dispatch(p.events.layerremove, this);
                    this.events.dispatch(this.events.remove, p);
                    this._planet = null;
                    return this;
                }
            }
        }
        return this;
    }

    /**
     * Clears layer material.
     * @virtual
     */
    clear() {
        this._planet && this._planet._clearLayerMaterial(this);
    }

    /**
     * Sets layer attribution text.
     * @public
     * @param {string} html - HTML code that represents layer attribution, it could be just a text.
     */
    setAttribution(html) {
        this._attribution = html;
        this._planet.updateAttributionsList();
    }

    /**
     * Sets height over the ground.
     * @public
     * @param {number} height - Layer height.
     */
    setHeight(height) {
        this._height = height;
        this._planet.updateVisibleLayers();
    }

    /**
     * Gets layer height.
     * @public
     * @returns {number} -
     */
    getHeight() {
        return this._height;
    }

    /**
     * Sets z-index.
     * @public
     * @param {number} zIndex - Layer z-index.
     */
    setZIndex(zIndex) {
        this._zIndex = zIndex;
        this._planet.updateVisibleLayers();
    }

    /**
     * Gets z-index.
     * @public
     * @returns {number} -
     */
    getZIndex() {
        return this._zIndex;
    }

    /**
     * Set zIndex to the maximal value depend on other layers on the planet.
     * @public
     */
    bringToFront() {
        if (this._planet) {
            var vl = this._planet.visibleTileLayers;
            var l = vl[vl.length - 1];
            if (!l.isEqual(this)) {
                this.setZIndex(l.getZIndex() + 1);
            }
        }
    }

    /**
     * Returns true if the layer is a base.
     * @public
     * @returns {boolean} - Base layer flag.
     */
    isBaseLayer() {
        return this._isBaseLayer;
    }

    /**
     * Sets base layer type true.
     * @public
     * @param {boolean} flag - Base layer flag.
     */
    setBaseLayer(flag) {
        this._isBaseLayer = flag;

        if (this._planet && !flag && this.isEqual(this._planet.baseLayer)) {
            this._planet.baseLayer = null;
        }

        this._planet.updateVisibleLayers();
    }

    /**
     * Sets layer visibility.
     * @public
     * @virtual
     * @param {boolean} visibility - Layer visibility.
     */
    setVisibility(visibility) {
        if (visibility !== this._visibility) {
            this._visibility = visibility;
            if (this._isBaseLayer && visibility) {
                this._planet.setBaseLayer(this);
            }
            this._planet.updateVisibleLayers();
            this.events.dispatch(this.events.visibilitychange, this);
        }
    }

    /**
     * Gets layer visibility.
     * @public
     * @returns {boolean} - Layer visibility.
     */
    getVisibility() {
        return this._visibility;
    }

    /**
     * Sets visible geographical extent.
     * @public
     * @param {og.Extent} extent - Layer visible geographical extent.
     */
    setExtent(extent) {
        var sw = extent.southWest.clone(),
            ne = extent.northEast.clone();
        if (sw.lat < _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MIN_LAT"]) {
            sw.lat = _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MIN_LAT"];
        }
        if (ne.lat > _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MAX_LAT"]) {
            ne.lat = _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MAX_LAT"];
        }
        this._extent = extent.clone();
        this._extentMerc = new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](sw.forwardMercator(), ne.forwardMercator());
        this._correctFullExtent();
    }

    /**
     * Gets layer extent.
     * @public
     * @return {og.Extent} - Layer geodetic extent.
     */
    getExtent() {
        return this._extent;
    }

    /**
     * Special correction of the whole globe extent.
     * @protected
     */
    _correctFullExtent() {
        //var e = this._extent,
        //    em = this._extentMerc;
        //var ENLARGE_MERCATOR_LON = og.mercator.POLE + 50000;
        //var ENLARGE_MERCATOR_LAT = og.mercator.POLE + 50000;
        //if (e.northEast.lat === 90.0) {
        //    em.northEast.lat = ENLARGE_MERCATOR_LAT;
        //}
        //if (e.northEast.lon === 180.0) {
        //    em.northEast.lon = ENLARGE_MERCATOR_LON;
        //}
        //if (e.southWest.lat === -90.0) {
        //    em.southWest.lat = -ENLARGE_MERCATOR_LAT;
        //}
        //if (e.southWest.lon === -180.0) {
        //    em.southWest.lon = -ENLARGE_MERCATOR_LON;
        //}
    }

    createMaterial(segment) {
        return new _Material_js__WEBPACK_IMPORTED_MODULE_5__["Material"](segment, this);
    }
};

const EVENT_NAMES = [
    /**
     * Triggered when layer visibilty chanched.
     * @event og.layer.Layer#visibilitychange
     */
    "visibilitychange",

    /**
     * Triggered when layer has added to the planet.
     * @event og.layer.Layer#add
     */
    "add",

    /**
     * Triggered when layer has removed from the planet.
     * @event og.layer.Layer#remove
     */
    "remove",

    /**
     * Triggered when mouse moves over the layer.
     * @event og.layer.Layer#mousemove
     */
    "mousemove",

    /**
     * Triggered when mouse has entered over the layer.
     * @event og.layer.Layer#mouseenter
     */
    "mouseenter",

    /**
     * Triggered when mouse leaves the layer.
     * @event og.layer.Layer#mouseenter
     */
    "mouseleave",

    /**
     * Mouse left button clicked.
     * @event og.layer.Layer#lclick
     */
    "lclick",

    /**
     * Mouse right button clicked.
     * @event og.layer.Layer#rclick
     */
    "rclick",

    /**
     * Mouse right button clicked.
     * @event og.layer.Layer#mclick
     */
    "mclick",

    /**
     * Mouse left button double click.
     * @event og.layer.Layer#ldblclick
     */
    "ldblclick",

    /**
     * Mouse right button double click.
     * @event og.layer.Layer#rdblclick
     */
    "rdblclick",

    /**
     * Mouse middle button double click.
     * @event og.layer.Layer#mdblclick
     */
    "mdblclick",

    /**
     * Mouse left button up(stop pressing).
     * @event og.layer.Layer#lup
     */
    "lup",

    /**
     * Mouse right button up(stop pressing).
     * @event og.layer.Layer#rup
     */
    "rup",

    /**
     * Mouse middle button up(stop pressing).
     * @event og.layer.Layer#mup
     */
    "mup",

    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.layer.Layer#ldown
     */
    "ldown",

    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.layer.Layer#rdown
     */
    "rdown",

    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.layer.Layer#mdown
     */
    "mdown",

    /**
     * Mouse left button is pressing.
     * @event og.layer.Layer#lhold
     */
    "lhold",

    /**
     * Mouse right button is pressing.
     * @event og.layer.Layer#rhold
     */
    "rhold",

    /**
     * Mouse middle button is pressing.
     * @event og.layer.Layer#mhold
     */
    "mhold",

    /**
     * Mouse wheel is rotated.
     * @event og.layer.Layer#mousewheel
     */
    "mousewheel",

    /**
     * Triggered when touching moves over the layer.
     * @event og.layer.Layer#touchmove
     */
    "touchmove",

    /**
     * Triggered when layer begins to touch.
     * @event og.layer.Layer#touchstart
     */
    "touchstart",

    /**
     * Triggered when layer has finished touching.
     * @event og.layer.Layer#touchend
     */
    "touchend",

    /**
     * Triggered layer has double touched.
     * @event og.layer.Layer#doubletouch
     */
    "doubletouch",

    /**
     * Triggered when touching leaves layer borders.
     * @event og.layer.Layer#touchleave
     */
    "touchleave",

    /**
     * Triggered when touch enters over the layer.
     * @event og.layer.Layer#touchenter
     */
    "touchenter"
];



/***/ }),

/***/ "./src/og/layer/Material.js":
/*!**********************************!*\
  !*** ./src/og/layer/Material.js ***!
  \**********************************/
/*! exports provided: Material */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
/**
 * @module og/layer/Material
 */



const Material = function (segment, layer) {
    this.segment = segment;
    this.layer = layer;
    this.isReady = false;
    this.isLoading = false;
    this.texture = null;
    this.pickingMask = null;
    this.image = null;
    this.textureExists = false;
    this.appliedNodeId = 0;

    //vector data
    this._updateTexture = null;
    this._updatePickingMask = null;
    this.pickingReady = false;
};

Material.prototype.assignLayer = function (layer) {
    this.layer = layer;
};

Material.prototype.abortLoading = function () {
    this.layer.abortMaterialLoading(this);
};

Material.prototype.applyImage = function (img) {
    if (this.segment.ready) {
        this._updateTexture = null;

        this.image = img;
        this.texture = this.segment.handler.createTexture(img);
        this.appliedNodeId = this.segment.node.nodeId;
        this.isReady = true;
        this.pickingReady = true;
        this.textureExists = true;
        this.isLoading = false;
    }
};

Material.prototype.applyTexture = function (texture, pickingMask) {

    this.texture = texture;
    this._updateTexture = null;

    this.pickingMask = pickingMask || null;
    this._updatePickingMask = null;

    this.isReady = true;
    this.pickingReady = true;
    this.textureExists = true;
    this.isLoading = false;
    this.appliedNodeId = this.segment.node.nodeId;
};

Material.prototype.textureNotExists = function () {
    this.isLoading = true;
    this.textureExists = false;
};

Material.prototype.clear = function () {
    this.layer.clearMaterial(this);
};



/***/ }),

/***/ "./src/og/layer/Vector.js":
/*!********************************!*\
  !*** ./src/og/layer/Vector.js ***!
  \********************************/
/*! exports provided: Vector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _entity_Entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../entity/Entity.js */ "./src/og/entity/Entity.js");
/* harmony import */ var _entity_EntityCollection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../entity/EntityCollection.js */ "./src/og/entity/EntityCollection.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _quadTree_EntityCollectionNode_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../quadTree/EntityCollectionNode.js */ "./src/og/quadTree/EntityCollectionNode.js");
/* harmony import */ var _entity_GeometryHandler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../entity/GeometryHandler.js */ "./src/og/entity/GeometryHandler.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Layer.js */ "./src/og/layer/Layer.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _QueueArray_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../QueueArray.js */ "./src/og/QueueArray.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/layer/Vector
 */
















/**
 * Creates entity instance array.
 * @static
 * @param {og.Entities[] || Object[]} entities - Entity array.
 * @returns {og.Entity[]} - Entity object array.
 */
function _entitiesConstructor(entities) {
    var res = [];
    for (var i = 0; i < entities.length; i++) {
        var ei = entities[i];
        if (ei instanceof _entity_Entity_js__WEBPACK_IMPORTED_MODULE_3__["Entity"]) {
            res.push(ei);
        } else {
            res.push(new _entity_Entity_js__WEBPACK_IMPORTED_MODULE_3__["Entity"](ei));
        }
    }
    return res;
};

/**
 * Vector layer represents alternative entities store. Used for geospatial data rendering like
 * points, lines, polygons, geometry objects etc.
 * @class
 * @extends {og.layer.Layer}
 * @param {string} [name="noname"] - Layer name.
 * @param {Object} [options] - Layer options:
 * @param {number} [options.minZoom=0] - Minimal visible zoom. 0 is default
 * @param {number} [options.maxZoom=50] - Maximal visible zoom. 50 is default.
 * @param {string} [options.attribution] - Layer attribution.
 * @param {string} [options.zIndex=0] - Layer Z-order index. 0 is default.
 * @param {boolean} [options.visibility=true] - Layer visibility. True is default.
 * @param {boolean} [options.isBaseLayer=false] - Layer base layer. False is default.
 * @param {Array.<og.Entity>} [options.entities] - Entities array.
 * @param {Array.<number,number,number>} [options.scaleByDistance] - Scale by distance parameters.
 *      First index - near distance to the entity, after entity becomes full scale.
 *      Second index - far distance to the entity, when entity becomes zero scale.
 *      Third index - far distance to the entity, when entity becomes invisible.
 * @param {number} [options.nodeCapacity=30] - Maximum entities quantity in the tree node. Rendering optimization parameter. 30 is default.
 * @param {boolean} [options.async=true] - Asynchronous vector data handling before rendering. True for optimization huge data.
 * @param {boolean} [options.clampToGround = false] - Clamp vector data to the ground.
 * @param {boolean} [options.relativeToGround = false] - Place vector data relative to the ground relief.
 *
 * @fires og.layer.Vector#entitymove
 * @fires og.layer.Vector#draw
 * @fires og.layer.Vector#add
 * @fires og.layer.Vector#remove
 * @fires og.layer.Vector#entityadd
 * @fires og.layer.Vector#entityremove
 * @fires og.layer.Vector#visibilitychange
 */
class Vector extends _Layer_js__WEBPACK_IMPORTED_MODULE_8__["Layer"] {
    constructor(name, options) {
        options = options || {};

        super(name, options);

        this.events.registerNames(EVENT_NAMES);

        this.isVector = true;

        /**
         * First index - near distance to the entity, after that entity becomes full scale.
         * Second index - far distance to the entity, when entity becomes zero scale.
         * Third index - far distance to the entity, when entity becomes invisible.
         * @public
         * @type {Array.<number,number,number>}
         */
        this.scaleByDistance = options.scaleByDistance || [_math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"], _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"], _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"]];

        /**
         * Asynchronous data handling before rendering.
         * @public
         * @type {boolean}
         */
        this.async = options.async !== undefined ? options.async : true;

        /**
         * Vector data clamp to ground flag.
         * @public
         * @type {boolean}
         */
        this.clampToGround = options.clampToGround || false;

        /**
         * Sets vector data relative to the ground relief.
         * @public
         * @type {boolean}
         */
        this.relativeToGround = options.relativeToGround || false;

        /**
         * Maximum entities quantity in the tree node.
         * @private
         */
        this._nodeCapacity = options.nodeCapacity || 30;

        this._pickingEnabled = options.pickingEnabled !== undefined ? options.pickingEnabled : true;

        /**
         * Manimal tree node depth index.
         * @private
         */
        this._minDepth = options.minDepth || 1;

        /**
         * Stored entities.
         * @private
         */
        this._entities = _entitiesConstructor(options.entities || []);

        this._polylineEntityCollection = new _entity_EntityCollection_js__WEBPACK_IMPORTED_MODULE_4__["EntityCollection"]({
            'pickingEnabled': this._pickingEnabled
        });
        this._bindEventsDefault(this._polylineEntityCollection);

        this._geometryHandler = new _entity_GeometryHandler_js__WEBPACK_IMPORTED_MODULE_7__["GeometryHandler"](this);

        this._entityCollectionsTree = null;
        this._entityCollectionsTreeNorth = null;
        this._entityCollectionsTreeSouth = null;

        this._renderingNodes = {};
        this._renderingNodesNorth = {};
        this._renderingNodesSouth = {};

        this._counter = 0;
        this._deferredEntitiesPendingQueue = new _QueueArray_js__WEBPACK_IMPORTED_MODULE_10__["QueueArray"]();

        this._pendingsQueue = [];

        /** Creates collections tree*/
        this.setEntities(this._entities);
    }

    _bindPicking() {
        this._pickingColor.clear();
    }

    /**
     * Adds layer to the planet.
     * @public
     */
    addTo(planet) {
        this._assignPlanet(planet);
        this._geometryHandler.assignHandler(planet.renderer.handler);
        this._polylineEntityCollection.addTo(planet, true);
        this.setEntities(this._entities);
        return this;
    }

    /**
     * Returns true if a layer has rasterized vector data like polygons.
     * @public
     * @virtual
     * @returns {boolean}
     */
    hasImageryTiles() {
        return true;
    }

    /**
     * Returns stored entities.
     * @public
     * @returns {Array.<og.Entity>}
     */
    getEntities() {
        return [].concat(this._entities);
    }

    /**
     * @private
     */
    _fitExtent(entity) {
        var ee = entity.getExtent(),
            e = this._extent;
        if (ee.southWest.lon < e.southWest.lon) {
            e.southWest.lon = ee.southWest.lon;
        }
        if (ee.southWest.lat < e.southWest.lat) {
            e.southWest.lat = ee.southWest.lat;
        }
        if (ee.northEast.lon > e.northEast.lon) {
            e.northEast.lon = ee.northEast.lon;
        }
        if (ee.northEast.lat > e.northEast.lat) {
            e.northEast.lat = ee.northEast.lat;
        }
        this.setExtent(this._extent);
    }

    /**
     * Adds entity to the layer.
     * @public
     * @param {og.Entity} entity - Entity.
     * @param {boolean} [rightNow] - Entity insertion option. False is deafult.
     * @returns {og.layer.Vector} - Returns this layer.
     */
    add(entity, rightNow) {
        if (!(entity._layer || entity._entityCollection)) {
            entity._layer = this;
            entity._layerIndex = this._entities.length;
            this._entities.push(entity);


            this._fitExtent(entity);

            //
            //...pointCloud, shape, model etc.
            //

            if (entity.polyline) {
                this._polylineEntityCollection.add(entity);
            }

            if (entity.geometry) {
                if (this._planet) {
                    this._planet.renderer.assignPickingColor(entity);
                    this._geometryHandler.add(entity.geometry);
                }
            }

            if (entity.billboard || entity.label) {
                if (this._planet) {
                    if (!entity._lonlat) {
                        entity._lonlat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
                    }

                    //poles trees
                    if (entity._lonlat.lat > _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MAX_LAT"]) {
                        this._entityCollectionsTreeNorth.insertEntity(entity, rightNow);
                    } else if (entity._lonlat.lat < _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MIN_LAT"]) {
                        this._entityCollectionsTreeSouth.insertEntity(entity, rightNow);
                    } else {
                        this._entityCollectionsTree.insertEntity(entity, rightNow);
                    }
                }
            }

            this.events.dispatch(this.events.entityadd, entity);
        }
        return this;
    }

    /**
     * Adds entity array to the layer.
     * @public
     * @param {Array.<og.Entity>} entities - Entities array.
     * @param {boolean} [rightNow] - Entity insertion option. False is deafult.
     * @returns {og.layer.Vector} - Returns this layer.
     */
    addEntities(entities, rightNow) {
        var i = entities.length;
        while (i--) {
            this.add(entities[i], rightNow);
        }
        return this;
    }

    /**
     * Remove entity from layer.
     * TODO: memory leaks.
     * @public
     * @param {og.Entity} entity - Entity to remove.
     * @returns {og.layer.Vector} - Returns this layer.
     */
    removeEntity(entity) {
        if (entity._layer && this.isEqual(entity._layer)) {
            this._entities.splice(entity._layerIndex, 1);
            this._reindexEntitiesArray(entity._layerIndex);
            entity._layer = null;
            entity._layerIndex = -1;

            if (entity._entityCollection) {
                entity._entityCollection._removeEntitySilent(entity);
                var node = entity._nodePtr;
                while (node) {
                    node.count--;
                    node = node.parentNode;
                }
                if (entity._nodePtr && entity._nodePtr.count === 0 &&
                    entity._nodePtr.deferredEntities.length === 0) {
                    entity._nodePtr.entityCollection = null;
                    //
                    //...
                    //
                }
            } else if (entity._nodePtr &&
                entity._nodePtr.deferredEntities.length) {
                var defEntities = entity._nodePtr.deferredEntities;
                var j = defEntities.length;
                while (j--) {
                    if (defEntities[j].id === entity.id) {
                        defEntities.splice(j, 1);
                        var node = entity._nodePtr;
                        while (node) {
                            node.count--;
                            node = node.parentNode;
                        }
                        break;
                    }
                }
            }

            if (entity.geometry) {
                if (this._planet) {
                    this._geometryHandler.remove(entity.geometry);
                    this._planet.renderer.clearPickingColor(entity);
                }
            }

            entity._nodePtr && (entity._nodePtr = null);
            this.events.dispatch(this.events.entityremove, entity);
        }
        return this;
    }

    /**
     * Set layer picking events active.
     * @public
     * @param {number} enable
     */
    setPickingEnabled(enable) {
        this._pickingEnabled = enable;

        this._polylineEntityCollection.setPickingEnabled(enable);

        this._entityCollectionsTree.traverseTree(function (ec) {
            ec.setPickingEnabled(enable);
        });
        this._entityCollectionsTreeNorth.traverseTree(function (ec) {
            ec.setPickingEnabled(enable);
        });
        this._entityCollectionsTreeSouth.traverseTree(function (ec) {
            ec.setPickingEnabled(enable);
        });
    }

    /**
     * Refresh collected entities indexes from startIndex entitytes collection array position.
     * @public
     * @param {number} startIndex - Entity array index.
     */
    _reindexEntitiesArray(startIndex) {
        var e = this._entities;
        for (var i = startIndex; i < e.length; i++) {
            e[i]._layerIndex = i;
        }
    }

    /**
     * Removes entities from layer.
     * @public
     * @param {Array.<og.Entity>} entities - Entity array.
     * @returns {og.layer.Vector} - Returns this layer.
     */
    removeEntities(entities) {
        var i = entities.length;
        while (i--) {
            this.removeEntity(entities[i]);
        }
        return this;
    }

    /**
     * Sets scale by distance parameters.
     * @public
     * @param {number} near - Full scale entity distance.
     * @param {number} far - Zerol scale entity distance.
     * @param {number} [farInvisible] - Entity visibility distance.
     */
    setScaleByDistance(near, far, farInisible) {
        this.scaleByDistance[0] = near;
        this.scaleByDistance[1] = far;
        this.scaleByDistance[2] = farInisible || _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX32"];
        return this;
    }

    /**
     * TODO: Clear the layer.
     * @public
     */
    clear() {
        //TODO
    }

    /**
     * Safety entities loop.
     * @public
     * @param {callback} callback - Entity callback.
     */
    each(callback) {
        var e = this._entities;
        var i = e.length;
        while (i--) {
            callback(e[i]);
        }
    }

    /**
     * Removes current entities from layer and adds new entities.
     * @public
     * @param {Array.<og.Entity>} entities - New entity array.
     */
    setEntities(entities) {

        this.clear();

        var e = this._extent = new _Extent_js__WEBPACK_IMPORTED_MODULE_5__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_9__["LonLat"](180, 90), new _LonLat_js__WEBPACK_IMPORTED_MODULE_9__["LonLat"](-180, -90));

        this._entities = new Array(entities.length);

        var entitiesForTree = [];

        for (var i = 0; i < entities.length; i++) {
            var ei = entities[i];

            ei._layer = this;
            ei._layerIndex = i;

            if (ei.polyline) {
                this._polylineEntityCollection.add(ei);
            } else if (ei.billboard || ei.label || ei.shape) {
                entitiesForTree.push(ei);
            }

            if (ei.geometry) {
                if (this._planet) {
                    this._planet.renderer.assignPickingColor(ei);
                    this._geometryHandler.add(ei.geometry);
                }
            }

            this._entities[i] = ei;

            var ext = ei.getExtent();
            if (ext.northEast.lon > e.northEast.lon) e.northEast.lon = ext.northEast.lon;
            if (ext.northEast.lat > e.northEast.lat) e.northEast.lat = ext.northEast.lat;
            if (ext.southWest.lon < e.southWest.lon) e.southWest.lon = ext.southWest.lon;
            if (ext.southWest.lat < e.southWest.lat) e.southWest.lat = ext.southWest.lat;
        }

        this._createEntityCollectionsTree(entitiesForTree);

        return this;
    }

    _createEntityCollectionsTree(entitiesForTree) {
        if (this._planet) {
            this._entityCollectionsTree = new _quadTree_EntityCollectionNode_js__WEBPACK_IMPORTED_MODULE_6__["EntityCollectionNode"](this, _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NW"], null, 0,
                _Extent_js__WEBPACK_IMPORTED_MODULE_5__["Extent"].createFromArray([-20037508.34, -20037508.34, 20037508.34, 20037508.34]), this._planet, 0);
            this._entityCollectionsTreeNorth = new _quadTree_EntityCollectionNode_js__WEBPACK_IMPORTED_MODULE_6__["EntityCollectionNodeWGS84"](this, _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NW"], null, 0,
                _Extent_js__WEBPACK_IMPORTED_MODULE_5__["Extent"].createFromArray([-180, _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MAX_LAT"], 180, 90]), this._planet, 0);
            this._entityCollectionsTreeSouth = new _quadTree_EntityCollectionNode_js__WEBPACK_IMPORTED_MODULE_6__["EntityCollectionNodeWGS84"](this, _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NW"], null, 0,
                _Extent_js__WEBPACK_IMPORTED_MODULE_5__["Extent"].createFromArray([-180, -90, 180, _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MIN_LAT"]]), this._planet, 0);

            this._entityCollectionsTree.buildTree(entitiesForTree);
            this._entityCollectionsTreeNorth.buildTree(entitiesForTree);
            this._entityCollectionsTreeSouth.buildTree(entitiesForTree);
        }
    }

    _bindEventsDefault(entityCollection) {
        var ve = this.events;
        entityCollection.events.on("entitymove", function (e) {
            ve.dispatch(ve.entitymove, e);
        });
        entityCollection.events.on("mousemove", function (e) {
            ve.dispatch(ve.mousemove, e);
        });
        entityCollection.events.on("mouseenter", function (e) {
            ve.dispatch(ve.mouseenter, e);
        });
        entityCollection.events.on("mouseleave", function (e) {
            ve.dispatch(ve.mouseleave, e);
        });
        entityCollection.events.on("lclick", function (e) {
            ve.dispatch(ve.lclick, e);
        });
        entityCollection.events.on("rclick", function (e) {
            ve.dispatch(ve.rclick, e);
        });
        entityCollection.events.on("mclick", function (e) {
            ve.dispatch(ve.mclick, e);
        });
        entityCollection.events.on("ldblclick", function (e) {
            ve.dispatch(ve.ldblclick, e);
        });
        entityCollection.events.on("rdblclick", function (e) {
            ve.dispatch(ve.rdblclick, e);
        });
        entityCollection.events.on("mdblclick", function (e) {
            ve.dispatch(ve.mdblclick, e);
        });
        entityCollection.events.on("lup", function (e) {
            ve.dispatch(ve.lup, e);
        });
        entityCollection.events.on("rup", function (e) {
            ve.dispatch(ve.rup, e);
        });
        entityCollection.events.on("mup", function (e) {
            ve.dispatch(ve.mup, e);
        });
        entityCollection.events.on("ldown", function (e) {
            ve.dispatch(ve.ldown, e);
        });
        entityCollection.events.on("rdown", function (e) {
            ve.dispatch(ve.rdown, e);
        });
        entityCollection.events.on("mdown", function (e) {
            ve.dispatch(ve.mdown, e);
        });
        entityCollection.events.on("lhold", function (e) {
            ve.dispatch(ve.lhold, e);
        });
        entityCollection.events.on("rhold", function (e) {
            ve.dispatch(ve.rhold, e);
        });
        entityCollection.events.on("mhold", function (e) {
            ve.dispatch(ve.mhold, e);
        });
        entityCollection.events.on("mousewheel", function (e) {
            ve.dispatch(ve.mousewheel, e);
        });
        entityCollection.events.on("touchmove", function (e) {
            ve.dispatch(ve.touchmove, e);
        });
        entityCollection.events.on("touchstart", function (e) {
            ve.dispatch(ve.touchstart, e);
        });
        entityCollection.events.on("touchend", function (e) {
            ve.dispatch(ve.touchend, e);
        });
        entityCollection.events.on("doubletouch", function (e) {
            ve.dispatch(ve.doubletouch, e);
        });
        entityCollection.events.on("touchleave", function (e) {
            ve.dispatch(ve.touchleave, e);
        });
        entityCollection.events.on("touchenter", function (e) {
            ve.dispatch(ve.touchenter, e);
        });
    }

    _collectPolylineCollectionPASS(outArr) {
        outArr.push(this._polylineEntityCollection);
        if (this.clampToGround || this.relativeToGround) {
            var rtg = this.relativeToGround;

            var nodes = this._planet._renderedNodes;
            var visibleExtent = this._planet.getViewExtent();
            var e = this._polylineEntityCollection._entities;
            var e_i = e.length;

            while (e_i--) {
                var p = e[e_i].polyline;
                if (visibleExtent.overlaps(p._extent)) {
                    var coords = p._pathLonLatMerc;
                    var c_j = coords.length;
                    while (c_j--) {
                        var c_j_h = coords[c_j].length;
                        while (c_j_h--) {
                            var ll = coords[c_j][c_j_h];
                            var n_k = nodes.length;
                            while (n_k--) {
                                var seg = nodes[n_k].segment;
                                if (seg._extent.isInside(ll)) {
                                    var cart = p._path3v[c_j][c_j_h];
                                    var res = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__["Vec3"]();
                                    seg.getTerrainPoint(res, cart, ll);
                                    p.setPoint3v(res.addA(res.normal().scale(rtg && p.altitude + 1.0)), c_j_h, c_j, true);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    collectVisibleCollections(outArr) {
        var p = this._planet;

        if (this.minZoom <= this._planet.maxCurrZoom && this.maxZoom >= p.maxCurrZoom) {

            this._renderingNodes = {};
            this._renderingNodesNorth = {};
            this._renderingNodesSouth = {};

            //Common collection first
            this._collectPolylineCollectionPASS(outArr);

            //Merc nodes
            this._secondPASS = [];
            this._entityCollectionsTree.collectRenderCollectionsPASS1(p._visibleNodes, outArr);
            var i = this._secondPASS.length;
            while (i--) {
                this._secondPASS[i].collectRenderCollectionsPASS2(p._visibleNodes, outArr, this._secondPASS[i].nodeId);
            }

            //North nodes
            this._secondPASS = [];
            this._entityCollectionsTreeNorth.collectRenderCollectionsPASS1(p._visibleNodesNorth, outArr);
            i = this._secondPASS.length;
            while (i--) {
                this._secondPASS[i].collectRenderCollectionsPASS2(p._visibleNodesNorth, outArr, this._secondPASS[i].nodeId);
            }

            //South nodes
            this._secondPASS = [];
            this._entityCollectionsTreeSouth.collectRenderCollectionsPASS1(p._visibleNodesSouth, outArr);
            i = this._secondPASS.length;
            while (i--) {
                this._secondPASS[i].collectRenderCollectionsPASS2(p._visibleNodesSouth, outArr, this._secondPASS[i].nodeId);
            }
        }
    }

    _queueDeferredNode(node) {
        if (this._visibility) {
            node._inTheQueue = true;
            if (this._counter >= 1) {
                this._deferredEntitiesPendingQueue.push(node);
            } else {
                this._execDeferredNode(node);
            }
        }
    }

    _execDeferredNode(node) {
        this._counter++;
        var that = this;
        setTimeout(function () {
            node.applyCollection();
            that._counter--;
            if (that._deferredEntitiesPendingQueue.length && that._counter < 1) {
                while (that._deferredEntitiesPendingQueue.length) {
                    var n = that._deferredEntitiesPendingQueue.pop();
                    n._inTheQueue = false;
                    if (n.isVisible()) {
                        that._execDeferredNode(node);
                        return;
                    }
                }
            }
        }, 0);
    }

    /**
     * Start to load tile material.
     * @public
     * @virtual
     * @param {og.Segment.Material} material - Current material.
     */
    loadMaterial(material) {

        var seg = material.segment;

        if (this._isBaseLayer) {
            material.texture = seg._isNorth ? seg.planet.solidTextureOne : seg.planet.solidTextureTwo;
        } else {
            material.texture = seg.planet.transparentTexture;
        }

        if (this._planet.layerLock.isFree()) {
            material.isReady = false;
            material.isLoading = true;
            this._planet._vectorTileCreator.add(material);
        }
    }

    /**
     * Abort exact material loading.
     * @public
     * @param {og.planetSegment.Material} material - Segment material.
     */
    abortMaterialLoading(material) {
        material.isLoading = false;
        material.isReady = false;
    }

    applyMaterial(material) {
        if (material.isReady) {
            return [0, 0, 1, 1];
        } else {

            !material.isLoading && this.loadMaterial(material);

            var segment = material.segment;
            var pn = segment.node,
                notEmpty = false;

            var mId = this._id;
            var psegm = material;
            var i = 0;
            while (pn.parentNode && i < 2) {
                if (psegm && psegm.isReady) {
                    notEmpty = true;
                    break;
                }
                pn = pn.parentNode;
                psegm = pn.segment.materials[mId];
            }

            if (notEmpty) {
                material.appliedNodeId = pn.nodeId;
                material.texture = psegm.texture;
                material.pickingMask = psegm.pickingMask;
                var dZ2 = 1.0 / (2 << (segment.tileZoom - pn.segment.tileZoom - 1));
                return [
                    segment.tileX * dZ2 - pn.segment.tileX,
                    segment.tileY * dZ2 - pn.segment.tileY,
                    dZ2,
                    dZ2
                ];
            } else {
                if (material.textureExists && material._updateTexture) {
                    material.texture = material._updateTexture;
                    material.pickingMask = material._updatePickingMask;
                } else {
                    material.texture = segment.planet.transparentTexture;
                    material.pickingMask = segment.planet.transparentTexture;
                }
                return [0, 0, 1, 1];
            }
        }
    }

    clearMaterial(material) {
        if (material.isReady) {
            var gl = material.segment.handler.gl;

            material.isReady = false;
            material.pickingReady = false;

            var t = material.texture;
            material.texture = null;
            t && !t.default && gl.deleteTexture(t);

            t = material.pickingMask;
            material.pickingMask = null;
            t && !t.default && gl.deleteTexture(t);

            t = material._updateTexture;
            material._updateTexture = null;
            t && !t.default && gl.deleteTexture(t);

            t = material._updatePickingMask;
            material._updatePickingMask = null;
            t && !t.default && gl.deleteTexture(t);
        }

        this.abortMaterialLoading(material);

        material.isLoading = false;
        material.textureExists = false;
    }

    update() {
        this._geometryHandler.update();
        this.collectVisibleCollections(this._planet._frustumEntityCollections);
        this.events.dispatch(this.events.draw, this);
    }
};

const EVENT_NAMES = [
    /**
     * Triggered when entity has moved.
     * @event og.layer.Vector#draw
     */
    "entitymove",

    /**
     * Triggered when layer begin draw.
     * @event og.layer.Vector#draw
     */
    "draw",

    /**
     * Triggered when new entity added to the layer.
     * @event og.layer.Vector#entityadd
     */
    "entityadd",

    /**
     * Triggered when entity removes from the collection.
     * @event og.layer.Vector#entityremove
     */
    "entityremove"
];



/***/ }),

/***/ "./src/og/light/LightSource.js":
/*!*************************************!*\
  !*** ./src/og/light/LightSource.js ***!
  \*************************************/
/*! exports provided: LightSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightSource", function() { return LightSource; });
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/light/LightSource
 */





/**
 * Represents basic light source.
 * @class
 * @param {string} [name] - Light source name.
 * @param {Object} [params] - Light parameters:
 * @param {og.math.Vector3} [params.position] - Light source position if it is a point light, otherwise it is a light direction vector.
 * @param {og.math.Vector3} [params.ambient]  - Ambient RGB color.
 * @param {og.math.Vector3} [params.diffuse]  - Diffuse RGB color.
 * @param {og.math.Vector3} [params.specular]  - Specular RGB color.
 * @param {number} [params.shininess]  - Specular shininess.
 */
class LightSource {
    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }

    constructor(name, params) {
        params = params || {};

        /**
         * Light name.
         * @protected
         * @type {string}
         */
        this._name = name || ("light_" + LightSource._staticCounter++);

        /**
         * Render node where light is shines.
         * @protected
         * @type {og.scene.RenderNode}
         */
        this._renderNode = null;

        /**
         * Light position.
         * @protected
         * @type {og.math.Vector3}
         */
        this._position = params.position || new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"]();

        /**
         * True if the light is directional.
         * @public
         * @type {boolean}
         */
        this.directional = params.derectional != undefined ? params.derectional : true;

        /**
         * Ambient color.
         * @protected
         * @type {og.math.Vector3}
         */
        this._ambient = params.ambient || new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"]();

        /**
         * Diffuse color.
         * @protected
         * @type {og.math.Vector3}
         */
        this._diffuse = params.diffuse || new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](0.8, 0.8, 0.8);

        /**
         * Specular color.
         * @protected
         * @type {og.math.Vector3}
         */
        this._specular = params.specular || new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](0.18, 0.18, 0.18);

        /**
         * Shininess.
         * @protected
         * @type {number}
         */
        this._shininess = params.shininess != undefined ? params.shininess : 3.3;

        /**
         * Light activity.
         * @protected
         * @type {boolean}
         */
        this._active = true;

        this._tempAmbient = this._ambient.clone();
        this._tempDiffuse = this._diffuse.clone();
        this._tempSpecular = this._specular.clone();
        this._tempShininess = this._shininess;
    }

    /**
     * Creates clone of the current light object.
     * @todo: TODO
     * @public
     * @returns {og.LightSource}
     */
    clone() {
        //TODO
    }

    /**
     * Set light activity. If activity is false the light doesn't shine.
     * @public
     * @param {boolean} active - Light activity.
     */
    setActive(active) {
        if (active && !this._active) {
            var rn = this._renderNode;
            if (rn) {
                var index = rn._lightsNames.indexOf(this._name);
                this._shininess = rn._lightsParamsf[index] = this._tempShininess;
                if (index != -1) {
                    index *= 9;
                    this._ambient.x = rn._lightsParamsv[index] = this._tempAmbient.x;
                    this._ambient.y = rn._lightsParamsv[index + 1] = this._tempAmbient.y;
                    this._ambient.z = rn._lightsParamsv[index + 2] = this._tempAmbient.z;
                    this._diffuse.x = rn._lightsParamsv[index + 3] = this._tempDiffuse.x;
                    this._diffuse.y = rn._lightsParamsv[index + 4] = this._tempDiffuse.y;
                    this._diffuse.z = rn._lightsParamsv[index + 5] = this._tempDiffuse.z;
                    this._specular.x = rn._lightsParamsv[index + 6] = this._tempSpecular.x;
                    this._specular.y = rn._lightsParamsv[index + 7] = this._tempSpecular.y;
                    this._specular.z = rn._lightsParamsv[index + 8] = this._tempSpecular.z;
                }
            }
            this._active = true;
        } else if (!active && this._active) {
            this._tempAmbient = this._ambient.clone();
            this._tempDiffuse = this._diffuse.clone();
            this._tempSpecular = this._specular.clone();
            this._tempShininess = this._shininess;
            this.setBlack();
            this._active = false;
        }
    }

    /**
     * Gets light activity.
     * @public
     * @returns {boolean}
     */
    isActive() {
        return this._active;
    }

    /**
     * Set light source position, or if it is a directional type sets light direction vector.
     * @public
     * @param {og.math.Vector3} position - Light position or direction vector.
     * @returns {og.LightSource}
     */
    setPosition(position) {
        this._position.x = position.x;
        this._position.y = position.y;
        this._position.z = position.z;
        return this;
    }

    /**
     * Returns light source position, or if it is a directional type sets light direction vector.
     * @public
     * @returns {og.math.Vector3} - Light source position/direction.
     */
    getPosition() {
        return this._position.clone();
    }

    /**
     * Set ambient color.
     * @public
     * @param {og.math.Vector3} rgb - Ambient color.
     * @returns {og.LightSource}
     */
    setAmbient(rgb) {
        this._ambient = rgb;
        var rn = this._renderNode;
        if (rn) {
            var index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index] = rgb.x;
                rn._lightsParamsv[index + 1] = rgb.y;
                rn._lightsParamsv[index + 2] = rgb.z;
            }
        }
        return this;
    }

    /**
     * Set diffuse color.
     * @public
     * @param {og.math.Vector3} rgb - Diffuse color.
     * @returns {og.LightSource}
     */
    setDiffuse(rgb) {
        this._diffuse = rgb;
        var rn = this._renderNode;
        if (rn) {
            var index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index + 3] = rgb.x;
                rn._lightsParamsv[index + 4] = rgb.y;
                rn._lightsParamsv[index + 5] = rgb.z;
            }
        }
        return this;
    }

    /**
     * Set specular color.
     * @public
     * @param {og.math.Vector3} rgb - Specular color.
     * @returns {og.LightSource}
     */
    setSpecular(rgb) {
        this._specular = rgb;
        var rn = this._renderNode;
        if (rn) {
            var index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index + 6] = rgb.x;
                rn._lightsParamsv[index + 7] = rgb.y;
                rn._lightsParamsv[index + 8] = rgb.z;
            }
        }
        return this;
    }

    /**
     * Set material shininess.
     * @public
     * @param {number} shininess - Material shininess.
     * @returns {og.LightSource}
     */
    setShininess(shininess) {
        this._shininess = shininess;
        var rn = this._renderNode;
        if (rn) {
            var index = rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsf[index] = shininess;
            }
        }
        return this;
    }

    /**
     * Sets light to black.
     * @public
     * @returns {og.LightSource}
     */
    setBlack() {
        this._ambient.clear();
        this._diffuse.clear();
        this._specular.clear();
        this._shininess = 0;
        var rn = this._renderNode;
        if (rn) {
            var index = 9 * rn._lightsNames.indexOf(this._name);
            if (index != -1) {
                rn._lightsParamsv[index] = rn._lightsParamsv[index + 1] = rn._lightsParamsv[index + 2] =
                    rn._lightsParamsv[index + 3] = rn._lightsParamsv[index + 4] = rn._lightsParamsv[index + 5] =
                    rn._lightsParamsv[index + 6] = rn._lightsParamsv[index + 7] = rn._lightsParamsv[index + 8] = 0;
            }
        }
        return this;
    }

    /**
     * Adds current light to the render node scene.
     * @public
     * @param {og.scene.RenderNode} renderNode - Render node scene.
     * @returns {og.LightSource}
     */
    addTo(renderNode) {
        this._renderNode = renderNode;
        renderNode._lights.push(this);
        renderNode._lightsNames.push(this._name);
        renderNode._lightsParamsf.push(this._shininess);
        renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._ambient.toVec());
        renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._diffuse.toVec());
        renderNode._lightsParamsv.push.apply(renderNode._lightsParamsv, this._specular.toVec());
        return this;
    }

    /**
     * Removes from render node scene.
     * @public
     */
    remove() {
        var rn = this.renderNode;
        if (rn) {
            var li = rn.getLightById(this._name);
            if (li != -1) {
                rn._lights.splice(li, 1);
                rn._lightsNames.splice(li, 1);
                rn._lightsParamsf.splice(li, 1);
                rn._lightsParamsv.splice(li, 9);
            }
        }
        this._renderNode = null;
    }
};



/***/ }),

/***/ "./src/og/math.js":
/*!************************!*\
  !*** ./src/og/math.js ***!
  \************************/
/*! exports provided: TWO_PI, PI_TWO, X, Y, Z, W, MAX_FLOAT, LOG2, MAX32, MAX, MIN, RADIANS, DEGREES, DEGREES_DOUBLE, RADIANS_HALF, ARCSECONDS_TO_RADIANS, RADIANS_TO_HOURS, HOURS_TO_RADIANS, HOURS_TO_DEGREES, DEGREES_TO_HOURS, SQRT_HALF, EPSILON1, EPSILON2, EPSILON3, EPSILON4, EPSILON5, EPSILON6, EPSILON7, EPSILON8, EPSILON9, EPSILON10, EPSILON11, EPSILON12, EPSILON13, EPSILON14, EPSILON15, EPSILON16, EPSILON17, EPSILON18, EPSILON19, EPSILON20, log, clamp, DEG2RAD, RAD2DEG, isPowerOfTwo, nextHighestPowerOfTwo, randomi, random, degToDec, mod, zeroTwoPI, step, frac, log2, exp2, pow2i, slice, lerp, bezier, rev, norm_lon, negativePItoPI, solve_iteration_fixed, solve_iteration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TWO_PI", function() { return TWO_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PI_TWO", function() { return PI_TWO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Z", function() { return Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return W; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_FLOAT", function() { return MAX_FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOG2", function() { return LOG2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX32", function() { return MAX32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX", function() { return MAX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN", function() { return MIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIANS", function() { return RADIANS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEGREES", function() { return DEGREES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEGREES_DOUBLE", function() { return DEGREES_DOUBLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIANS_HALF", function() { return RADIANS_HALF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARCSECONDS_TO_RADIANS", function() { return ARCSECONDS_TO_RADIANS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIANS_TO_HOURS", function() { return RADIANS_TO_HOURS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOURS_TO_RADIANS", function() { return HOURS_TO_RADIANS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOURS_TO_DEGREES", function() { return HOURS_TO_DEGREES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEGREES_TO_HOURS", function() { return DEGREES_TO_HOURS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SQRT_HALF", function() { return SQRT_HALF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON1", function() { return EPSILON1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON2", function() { return EPSILON2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON3", function() { return EPSILON3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON4", function() { return EPSILON4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON5", function() { return EPSILON5; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON6", function() { return EPSILON6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON7", function() { return EPSILON7; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON8", function() { return EPSILON8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON9", function() { return EPSILON9; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON10", function() { return EPSILON10; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON11", function() { return EPSILON11; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON12", function() { return EPSILON12; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON13", function() { return EPSILON13; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON14", function() { return EPSILON14; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON15", function() { return EPSILON15; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON16", function() { return EPSILON16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON17", function() { return EPSILON17; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON18", function() { return EPSILON18; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON19", function() { return EPSILON19; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON20", function() { return EPSILON20; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEG2RAD", function() { return DEG2RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RAD2DEG", function() { return RAD2DEG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() { return isPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextHighestPowerOfTwo", function() { return nextHighestPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomi", function() { return randomi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degToDec", function() { return degToDec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeroTwoPI", function() { return zeroTwoPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return step; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frac", function() { return frac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log2", function() { return log2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp2", function() { return exp2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow2i", function() { return pow2i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rev", function() { return rev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm_lon", function() { return norm_lon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negativePItoPI", function() { return negativePItoPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve_iteration_fixed", function() { return solve_iteration_fixed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve_iteration", function() { return solve_iteration; });
/**
 * @module og/math
 */



/** @const */
const TWO_PI = 2.0 * Math.PI;

/** @const */
const PI_TWO = Math.PI / 2.0;

const X = 0;
const Y = 1;
const Z = 2;
const W = 3;

const MAX_FLOAT = Number.MAX_VALUE || 1.7976931348623157e+308;

/** @const */
const LOG2 = Math.log(2);
/** @const */
const MAX32 = 2147483647;
/** @const */
const MAX = 549755748352;
/** @const */
const MIN = -MAX;

/** @const */
const RADIANS = Math.PI / 180.0;
/** @const */
const DEGREES = 180.0 / Math.PI;

/** @const */
const DEGREES_DOUBLE = 2.0 * DEGREES;
/** @const */
const RADIANS_HALF = 0.5 * RADIANS;

/** @const */
const ARCSECONDS_TO_RADIANS = 0.00000484813681109536;
/** @const */
const RADIANS_TO_HOURS = 3.8197186342054880584532103209403;
/** @const */
const HOURS_TO_RADIANS = 0.26179938779914943653855361527329;
/** @const */
const HOURS_TO_DEGREES = 15.0;
/** @const */
const DEGREES_TO_HOURS = 1.0 / 15.0;

/** @const */
const SQRT_HALF = Math.sqrt(0.5);

const EPSILON1 = 0.1;
const EPSILON2 = 0.01;
const EPSILON3 = 0.001;
const EPSILON4 = 0.0001;
const EPSILON5 = 0.00001;
const EPSILON6 = 0.000001;
const EPSILON7 = 1e-7;
const EPSILON8 = 1e-8;
const EPSILON9 = 1e-9;
const EPSILON10 = 1e-10;
const EPSILON11 = 1e-11;
const EPSILON12 = 1e-12;
const EPSILON13 = 1e-13;
const EPSILON14 = 1e-14;
const EPSILON15 = 1e-15;
const EPSILON16 = 1e-16;
const EPSILON17 = 1e-17;
const EPSILON18 = 1e-18;
const EPSILON19 = 1e-19;
const EPSILON20 = 1e-20;

/** 
 * The log function returns the power to which the base value has to be raised to produce n.
 * @function
 * @param {number} n - Produce value.
 * @param {number} base - Base value.
 * @returns {number} -
 * @example
 * og.math.log(64, 2)
 * //returns 6
 */
function log(n, base) {
    return Math.log(n) / Math.log(base);
};

/**
 * Clamp the number.
 * @function
 * @param {number} number - Input number.
 * @param {number} min - Minimal edge.
 * @param {number} max - Maximal edge.
 * @returns {number} -
 * @example
 * og.math.clamp(12, 1, 5)
 * //returns 5
 */
function clamp(number, min, max) {
    return Math.max(min, Math.min(number, max));
};

/**
 * Converts degrees value to radians.
 * @function
 * @param {number} degrees - Degree value.
 * @returns {number} -
 */
function DEG2RAD(degrees) {
    return degrees * og.math.RADIANS;
};

/**
 * Converts radians value to degrees.
 * @function
 * @param {number} angle - Degree value.
 * @returns {number} -
 */
function RAD2DEG(angle) {
    return angle * og.math.DEGREES;
};

/**
 * Check the number is a power of two.
 * @function
 * @param {number} x - Input value.
 * @returns {boolean} -
 */
function isPowerOfTwo(x) {
    return (x & (x - 1)) == 0;
};

/**
 * Returns next value that is power of two.
 * @function
 * @param {number} x - Input value.
 * @returns {number} -
 */
function nextHighestPowerOfTwo(x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};

/**
 * Returns random integer number within the bounds.
 * @function
 * @param {number} min - Minimal bound.
 * @param {number} max - Maximal bound.
 * @returns {number} -
 */
function randomi(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
};

/**
 * Returns random number within the bounds.
 * @function
 * @param {number} min - Minimal bound.
 * @param {number} max - Maximal bound.
 * @returns {number} -
 */
function random(min, max) {
    return Math.random() * (max - min) + min;
};

/**
 * Converts degrees value to decimal.
 * @function
 * @param {number} d - Degrees.
 * @param {number} m - Minutes.
 * @param {number} s - Seconds.
 * @param {boolean} [p] - Positive flag. False - default.
 * @returns {number} -
 **/
function degToDec(d, m, s, p) {
    if (p)
        return d + m / 60.0 + s / 3600.0;
    else
        return -d - m / 60.0 - s / 3600.0;
};

/**
 * The modulo operation that also works for negative dividends.
 * @function
 * @param {number} m - The dividend.
 * @param {number} n - The divisor.
 * @returns {number} The remainder.
 */
function mod(m, n) {
    return ((m % n) + n) % n;
};

/**
 * Returns an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
 * @function
 * @param {number} a - Angle in radians
 * @returns {number} -
 */
function zeroTwoPI(a) {
    var mod = og.math.mod(a, og.math.TWO_PI);
    if (Math.abs(mod) < og.math.EPSILON14 && Math.abs(a) > og.math.EPSILON14) {
        return og.math.TWO_PI;
    }
    return mod;
};

/**
 * Returns 0.0 if x is smaller then edge and otherwise 1.0.
 * @function
 * @param {number} edge -
 * @param {number} x - Value to edge.
 * @returns {number} -
 */
function step(edge, x) {
    return x < edge ? 0.0 : 1.0;
};

/** 
 * The fract function returns the fractional part of x, i.e. x minus floor(x).
 * @function
 * @param {number} x - Input value.
 * @returns {number} -
 */
function frac(x) {
    return x - Math.floor(x);
};

/**
 * Returns Math.log(x) / Math.log(2)
 * @function
 * @param {number} x - Input value.
 * @returns {number} -
 */
function log2(x) {
    return Math.log(x) / og.math.LOG2;
};

/**
 * Returns two power of n.
 * @function
 * @param {number} n - Power value.
 * @returns {number} -
 */
function exp2(n) {
    return Math.pow(2, n);
};

/**
 * Returns two power of integer n.
 * @function
 * @param {number} n - Integer power value.
 * @returns {number} -
 */
function pow2i(n) {
    return 2 << (n - 1);
};

/**
 * Returns a slice of linear interpolation t * (h1 - h0)
 * @param {number} t - A value that linearly interpolates between the h0 parameter and the h1 parameter.
 * @param {number} h1 - End value.
 * @param {number} h0 - Start value.
 * @returns {number} -
 */
function slice(t, h1, h0) {
    return t * (h1 - h0);
};

/**
 * Performs a linear interpolation.
 * @function
 * @param {number} t - A value that linearly interpolates between the h0 parameter and the h1 parameter.
 * @param {number} h1 - End value.
 * @param {number} h0 - Start value.
 * @returns {number} -
 */
function lerp(t, h1, h0) {
    return h0 + t * (h1 - h0);
};

/**
 * Performs a 3D bezier interpolation.
 * @function
 * @param {number} t - Interpolation value.
 * @param {og.math.Vector3} p0 - First control point.
 * @param {og.math.Vector3} p1 - Second control point.
 * @param {og.math.Vector3} p2 - Third control point.
 * @param {og.math.Vector3} p3 - Fourth control point.
 * @returns {og.math.Vector3} -
 */
function bezier(t, p0, p1, p2, p3) {
    var u = 1 - t;
    var tt = t * t;
    var uu = u * u;
    var uuu = uu * u;
    var ttt = tt * t;

    return p0.scaleTo(uuu).addA(p1.scaleTo(3 * uu * t))
        .addA(p2.scaleTo(3 * u * tt)).addA(p3.scaleTo(ttt));
};

/**
 * Clamp angle value within 360.
 * @function
 * @param {number} x - Input angle.
 * @returns {number} -
 */
function rev(x) {
    return x - Math.floor(x / 360.0) * 360.0;
};

/**
 * Clamp longitude within: -180 to +180 degrees.
 * @function
 * @param {number} lon - Longitude.
 * @returns {number} -
 */
function norm_lon(lon) {
    return lon > 180 ? ((lon + 180) % 360) - 180 :
        lon < -180 ? ((lon - 180) % 360) + 180 : lon;
};

/**
 * Returns an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
 * @function
 * @param {number} a - Angle in radians.
 * @returns {number} -
 */
function negativePItoPI(a) {
    return og.math.zeroTwoPI(a + Math.PI) - Math.PI;
};

/**
 * Solve using iteration method and a fixed number of steps.
 * @function
 * @param {equationCallback} f - Equation. Used in Euler's equation(see og.orbit) solving.
 * @param {number} x0 - First approximation.
 * @param {number} maxIter - Maximum iterations.
 * @returns {number} -
 */
function solve_iteration_fixed(f, x0, maxIter) {
    var x = 0;
    var x2 = x0;
    for (var i = 0; i < maxIter; i++) {
        x = x2;
        x2 = f(x);
    }
    return x2;
};

/**
 * Solve using iteration; terminate when error is below err or the maximum
 * number of iterations is reached. Used in Euler's equation(see og.orbit) solving.
 * @function
 * @param {equationCallback} f - Equation.
 * @param {number} x0 - First approximation.
 * @param {number} err - Maximal accepted error value.
 * @param {number} maxIter - Maximum iterations.
 * @returns {number} -
 */
function solve_iteration(f, x0, err, maxIter) {
    maxIter = maxIter || 50;
    var x = 0;
    var x2 = x0;
    for (var i = 0; i < maxIter; i++) {
        x = x2;
        x2 = f(x);
        if (Math.abs(x2 - x) < err)
            return x2;
    }
    return x2;
};

/**
 * Equation function.
 * @callback equationCallback
 * @param {number} x - Equation variable.
 */

/***/ }),

/***/ "./src/og/math/Mat3.js":
/*!*****************************!*\
  !*** ./src/og/math/Mat3.js ***!
  \*****************************/
/*! exports provided: mat3, Mat3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return mat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mat3", function() { return Mat3; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _Mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mat4.js */ "./src/og/math/Mat4.js");
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/math/Mat3
 */







/**
 * Class represents a 3x3 matrix.
 * @class
 */
const Mat3 = function () {
    /**
     * A 3x3 matrix, indexable as a column-major order array.
     * @public
     * @type {Array.<number>}
     */
    this._m = new Array(9);
};

/**
 * Mat3 factory.
 * @static
 * @return {og.math.Mat3}
 */

function mat3() {
    return new Mat3();
};

/**
 * Sets column-major order array matrix.
 * @public
 * @param {Array.<number>} m - Matrix array.
 * @returns {og.math.Mat3}
 */
Mat3.prototype.set = function (m) {
    this._m[0] = m[0];
    this._m[1] = m[1];
    this._m[2] = m[2];
    this._m[3] = m[3];
    this._m[4] = m[4];
    this._m[5] = m[5];
    this._m[6] = m[6];
    this._m[7] = m[7];
    this._m[8] = m[8];
    return this;
};

/**
 * Duplicates a Mat3 instance.
 * @public
 * @returns {og.math.Mat3}
 */
Mat3.prototype.clone = function () {
    var res = new Mat3();
    res.set(this);
    return res;
};

/**
 * Copy matrix.
 * @public
 * @param {og.math.Mat3} a - Matrix to copy.
 * @returns {og.math.Mat3}
 */
Mat3.prototype.copy = function (a) {
    return this.set(a._m);
};

/**
 * Creates trasposed matrix from the current.
 * @public
 * @returns {og.math.Mat3}
 */
Mat3.prototype.transposeTo = function () {
    var res = new Mat3();
    var m = this._m;
    res._m[0] = m[0]; res._m[1] = m[3]; res._m[2] = m[6];
    res._m[3] = m[1]; res._m[4] = m[4]; res._m[5] = m[7];
    res._m[6] = m[2]; res._m[7] = m[5]; res._m[8] = m[8];
    return res;
};

/**
 * Sets matrix to identity.
 * @public
 * @returns {og.math.Mat3}
 */
Mat3.prototype.setIdentity = function () {
    this._m[0] = 1; this._m[1] = 0; this._m[2] = 0;
    this._m[3] = 0; this._m[4] = 1; this._m[5] = 0;
    this._m[6] = 0; this._m[7] = 0; this._m[8] = 1;
    return this;
};

/**
 * Multiply to 3d vector.
 * @public
 * @params {og.math.Vector3} p - 3d vector.
 * @returns {og.math.Vector3}
 */
Mat3.prototype.mulVec = function (p) {
    var d = p.x, e = p.y, g = p.z;
    var m = this._m;
    return new _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"](
        m[0] * d + m[3] * e + m[6] * g,
        m[1] * d + m[4] * e + m[7] * g,
        m[2] * d + m[5] * e + m[8] * g
    );
};

/**
 * Converts to 4x4 matrix.
 * @public
 * @returns {og.math.Matrix4}
 */
Mat3.prototype.toMatrix4 = function () {
    var res = new _Mat4_js__WEBPACK_IMPORTED_MODULE_1__["Mat4"]();
    var b = res._m;
    var a = this._m;
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = 0;
    b[4] = a[3];
    b[5] = a[4];
    b[6] = a[5];
    b[7] = 0;
    b[8] = a[6];
    b[9] = a[7];
    b[10] = a[8];
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return res;
};



/***/ }),

/***/ "./src/og/math/Mat4.js":
/*!*****************************!*\
  !*** ./src/og/math/Mat4.js ***!
  \*****************************/
/*! exports provided: mat4, Mat4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return mat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mat4", function() { return Mat4; });
/* harmony import */ var _Mat3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mat3.js */ "./src/og/math/Mat3.js");
/* harmony import */ var _Quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quat.js */ "./src/og/math/Quat.js");
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _Vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vec4.js */ "./src/og/math/Vec4.js");
/**
 * @module og/math/Mat4
 */








/**
 * Class represents a 4x4 matrix.
 * @class
 */
const Mat4 = function () {
    /**
     * A 4x4 matrix, indexable as a column-major order array.
     * @public
     * @type {Array.<number>}
     */
    this._m = new Array(16);

    /**
     * Projection frustum left value.
     * @public
     */
    this.left;
    /**
     * Projection frustum right value.
     * @public
     */
    this.right;
    /**
     * Projection frustum bottom value.
     * @public
     */
    this.bottom;
    /**
     * Projection frustum top value.
     * @public
     */
    this.top;
    /**
     * Projection frustum near value.
     * @public
     */
    this.near;
    /**
     * Projection frustum far value.
     * @public
     */
    this.far;
};

/**
 * Mat4 factory.
 * @static
 * @returns {og.math.Mat4}
 */
function mat4() {
    return new og.math.Mat4();
};

/**
 * Returns identity matrix instance.
 * @static
 * @returns {og.math.Mat4}
 */
Mat4.identity = function () {
    var res = new Mat4();
    res._m[0] = 1; res._m[1] = 0; res._m[2] = 0; res._m[3] = 0;
    res._m[4] = 0; res._m[5] = 1; res._m[6] = 0; res._m[7] = 0;
    res._m[8] = 0; res._m[9] = 0; res._m[10] = 1; res._m[11] = 0;
    res._m[12] = 0; res._m[13] = 0; res._m[14] = 0; res._m[15] = 1;
    return res;
};

/**
 * Sets column-major order array matrix.
 * @public
 * @param {Array.<number>} m - Matrix array.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.set = function (m) {
    this._m[0] = m[0];
    this._m[1] = m[1];
    this._m[2] = m[2];
    this._m[3] = m[3];
    this._m[4] = m[4];
    this._m[5] = m[5];
    this._m[6] = m[6];
    this._m[7] = m[7];
    this._m[8] = m[8];
    this._m[9] = m[9];
    this._m[10] = m[10];
    this._m[11] = m[11];
    this._m[12] = m[12];
    this._m[13] = m[13];
    this._m[14] = m[14];
    this._m[15] = m[15];
    return this;
};

/**
 * Duplicates a Matrix3 instance.
 * @public
 * @returns {og.math.Mat4}
 */
Mat4.prototype.clone = function () {
    var res = new Mat4();
    res.set(this);
    return res;
};

/**
 * Copy matrix.
 * @public
 * @param {og.math.Matrix3} a - Matrix to copy.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.copy = function (a) {
    this.set(a._m);
};

/**
 * Converts to 3x3 matrix.
 * @public
 * @returns {og.math.Matrix3}
 */
Mat4.prototype.toMatrix3 = function () {
    var res = new _Mat3_js__WEBPACK_IMPORTED_MODULE_0__["Mat3"]();
    var a = this._m,
        b = res._m;
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[4];
    b[4] = a[5];
    b[5] = a[6];
    b[6] = a[8];
    b[7] = a[9];
    b[8] = a[10];
    return res;
};

/**
 * Multiply to 3d vector.
 * @public
 * @param {og.math.Vector3} p - 3d vector.
 * @returns {og.math.Vector3}
 */
Mat4.prototype.mulVec3 = function (p) {
    var d = p.x, e = p.y, g = p.z;
    return new _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"](
        this._m[0] * d + this._m[4] * e + this._m[8] * g + this._m[12],
        this._m[1] * d + this._m[5] * e + this._m[9] * g + this._m[13],
        this._m[2] * d + this._m[6] * e + this._m[10] * g + this._m[14]
    );
};

/**
 * Multiply to 4d vector.
 * @public
 * @param {og.math.Vector4} p - 4d vector.
 * @returns {og.math.Vector4}
 */
Mat4.prototype.mulVec4 = function (p) {
    var d = p.x, e = p.y, g = p.z, f = p.w;
    return new _Vec4_js__WEBPACK_IMPORTED_MODULE_3__["Vec4"](
        this._m[0] * d + this._m[4] * e + this._m[8] * g + this._m[12] * f,
        this._m[1] * d + this._m[5] * e + this._m[9] * g + this._m[13] * f,
        this._m[2] * d + this._m[6] * e + this._m[10] * g + this._m[14] * f,
        this._m[3] * d + this._m[7] * e + this._m[11] * g + this._m[15] * f
    );
};

/**
 * Creates an inversed 3x3 matrix of the current.
 * @public
 * @returns {og.math.Matrix3}
 */
Mat4.prototype.toInverseMatrix3 = function () {
    var a = this._m;
    var c = a[0], d = a[1], e = a[2],
        g = a[4], f = a[5], h = a[6],
        i = a[8], j = a[9], k = a[10],
        l = k * f - h * j,
        o = -k * g + h * i,
        m = j * g - f * i,
        n = c * l + d * o + e * m;
    if (!n)
        return null;
    n = 1 / n;

    var res = new _Mat3_js__WEBPACK_IMPORTED_MODULE_0__["Mat3"]();
    res._m[0] = l * n;
    res._m[1] = (-k * d + e * j) * n;
    res._m[2] = (h * d - e * f) * n;
    res._m[3] = o * n;
    res._m[4] = (k * c - e * i) * n;
    res._m[5] = (-h * c + e * g) * n;
    res._m[6] = m * n;
    res._m[7] = (-j * c + d * i) * n;
    res._m[8] = (f * c - d * g) * n;
    return res;
};

/**
 * Creates an inversed matrix of the current.
 * @public
 * @returns {og.math.Mat4}
 */
Mat4.prototype.inverseTo = function () {
    var c = this._m[0], d = this._m[1], e = this._m[2], g = this._m[3],
        f = this._m[4], h = this._m[5], i = this._m[6], j = this._m[7],
        k = this._m[8], l = this._m[9], o = this._m[10], m = this._m[11],
        n = this._m[12], p = this._m[13], r = this._m[14], s = this._m[15],
        A = c * h - d * f,
        B = c * i - e * f,
        t = c * j - g * f,
        u = d * i - e * h,
        v = d * j - g * h,
        w = e * j - g * i,
        x = k * p - l * n,
        y = k * r - o * n,
        z = k * s - m * n,
        C = l * r - o * p,
        D = l * s - m * p,
        E = o * s - m * r,
        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x),
        res = new Mat4();

    res._m[0] = (h * E - i * D + j * C) * q; res._m[1] = (-d * E + e * D - g * C) * q; res._m[2] = (p * w - r * v + s * u) * q; res._m[3] = (-l * w + o * v - m * u) * q;
    res._m[4] = (-f * E + i * z - j * y) * q; res._m[5] = (c * E - e * z + g * y) * q; res._m[6] = (-n * w + r * t - s * B) * q; res._m[7] = (k * w - o * t + m * B) * q;
    res._m[8] = (f * D - h * z + j * x) * q; res._m[9] = (-c * D + d * z - g * x) * q; res._m[10] = (n * v - p * t + s * A) * q; res._m[11] = (-k * v + l * t - m * A) * q;
    res._m[12] = (-f * C + h * y - i * x) * q; res._m[13] = (c * C - d * y + e * x) * q; res._m[14] = (-n * u + p * B - r * A) * q; res._m[15] = (k * u - l * B + o * A) * q;
    return res;
};

/**
 * Creates a trasposed matrix of the current.
 * @public
 * @returns {og.math.Mat4}
 */
Mat4.prototype.transposeTo = function () {
    var res = new Mat4();
    res._m[0] = this._m[0]; res._m[1] = this._m[4]; res._m[2] = this._m[8]; res._m[3] = this._m[12];
    res._m[4] = this._m[1]; res._m[5] = this._m[5]; res._m[6] = this._m[9]; res._m[7] = this._m[13];
    res._m[8] = this._m[2]; res._m[9] = this._m[6]; res._m[10] = this._m[10]; res._m[11] = this._m[14];
    res._m[12] = this._m[3]; res._m[13] = this._m[7]; res._m[14] = this._m[11]; res._m[15] = this._m[15];
    return res;
};

/**
 * Sets matrix to identity.
 * @public
 * @returns {og.math.Mat4}
 */
Mat4.prototype.setIdentity = function () {
    this._m[0] = 1; this._m[1] = 0; this._m[2] = 0; this._m[3] = 0;
    this._m[4] = 0; this._m[5] = 1; this._m[6] = 0; this._m[7] = 0;
    this._m[8] = 0; this._m[9] = 0; this._m[10] = 1; this._m[11] = 0;
    this._m[12] = 0; this._m[13] = 0; this._m[14] = 0; this._m[15] = 1;
    return this;
};

/**
 * Computes the product of two matrices.
 * @public
 * @param {og.math.Mat4} mx - Matrix to multiply.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.mul = function (mx) {
    let d = this._m[0], e = this._m[1], g = this._m[2], f = this._m[3],
        h = this._m[4], i = this._m[5], j = this._m[6], k = this._m[7],
        l = this._m[8], o = this._m[9], m = this._m[10], n = this._m[11],
        p = this._m[12], r = this._m[13], s = this._m[14], a = this._m[15];

    let A = mx._m[0], B = mx._m[1], t = mx._m[2], u = mx._m[3],
        v = mx._m[4], w = mx._m[5], x = mx._m[6], y = mx._m[7],
        z = mx._m[8], C = mx._m[9], D = mx._m[10], E = mx._m[11],
        q = mx._m[12], F = mx._m[13], G = mx._m[14], b = mx._m[15];

    var res = new Mat4();
    res._m[0] = A * d + B * h + t * l + u * p; res._m[1] = A * e + B * i + t * o + u * r; res._m[2] = A * g + B * j + t * m + u * s; res._m[3] = A * f + B * k + t * n + u * a;
    res._m[4] = v * d + w * h + x * l + y * p; res._m[5] = v * e + w * i + x * o + y * r; res._m[6] = v * g + w * j + x * m + y * s; res._m[7] = v * f + w * k + x * n + y * a;
    res._m[8] = z * d + C * h + D * l + E * p; res._m[9] = z * e + C * i + D * o + E * r; res._m[10] = z * g + C * j + D * m + E * s; res._m[11] = z * f + C * k + D * n + E * a;
    res._m[12] = q * d + F * h + G * l + b * p; res._m[13] = q * e + F * i + G * o + b * r; res._m[14] = q * g + F * j + G * m + b * s; res._m[15] = q * f + F * k + G * n + b * a;
    return res;
};

/**
 * Add translation vector to the current matrix.
 * @public
 * @param {og.math.Vector3} v - Translate vector.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.translate = function (v) {
    var d = v.x, e = v.y, b = v.z;
    var a = this._m;
    a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];
    a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];
    a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];
    a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];
    return this;
};

/**
 * Sets translation matrix to the position.
 * @public
 * @param {og.math.Vector3} v - Translate to position.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.translateToPosition = function (v) {
    var a = this._m;
    a[12] = v.x;
    a[13] = v.y;
    a[14] = v.z;
    return this;
};

/**
 * Rotate currrent matrix around the aligned axis and angle.
 * @public
 * @param {og.math.Vector3} u - Aligned axis.
 * @param {number} angle - Aligned axis angle in radians.
 * @returns {og.math.Mat4}
 * @todo: OPTIMIZE: reveal multiplication
 */
Mat4.prototype.rotate = function (u, angle) {
    var c = Math.cos(angle),
        s = Math.sin(angle);
    var rot = new Mat4();
    var mx = rot._m;
    mx[0] = c + (1 - c) * u.x * u.x; mx[1] = (1 - c) * u.y * u.x - s * u.z; mx[2] = (1 - c) * u.z * u.x + s * u.y; mx[3] = 0;
    mx[4] = (1 - c) * u.x * u.y + s * u.z; mx[5] = c + (1 - c) * u.y * u.y; mx[6] = (1 - c) * u.z * u.y - s * u.x; mx[7] = 0;
    mx[8] = (1 - c) * u.x * u.z - s * u.y; mx[9] = (1 - c) * u.y * u.z + s * u.x; mx[10] = c + (1 - c) * u.z * u.z; mx[11] = 0;
    mx[12] = 0; mx[13] = 0; mx[14] = 0; mx[15] = 1;
    return this.mul(rot);
};

/**
 * Sets current rotation matrix around the aligned axis and angle.
 * @public
 * @param {og.math.Vector3} u - Aligned axis.
 * @param {number} angle - Aligned axis angle in radians.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.setRotation = function (u, angle) {
    var c = Math.cos(angle),
        s = Math.sin(angle);
    var mx = this._m;
    mx[0] = c + (1 - c) * u.x * u.x; mx[1] = (1 - c) * u.y * u.x - s * u.z; mx[2] = (1 - c) * u.z * u.x + s * u.y; mx[3] = 0;
    mx[4] = (1 - c) * u.x * u.y + s * u.z; mx[5] = c + (1 - c) * u.y * u.y; mx[6] = (1 - c) * u.z * u.y - s * u.x; mx[7] = 0;
    mx[8] = (1 - c) * u.x * u.z - s * u.y; mx[9] = (1 - c) * u.y * u.z + s * u.x; mx[10] = c + (1 - c) * u.z * u.z; mx[11] = 0;
    mx[12] = 0; mx[13] = 0; mx[14] = 0; mx[15] = 1;
    return this;
};

/**
 * Gets the rotation matrix from one vector to another.
 * @public
 * @param {og.math.Vector3} a - Firtst vector.
 * @param {og.math.Vector3} b - Second vector.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.rotateBetweenVectors = function (a, b) {
    var q = _Quat_js__WEBPACK_IMPORTED_MODULE_1__["Quat"].getRotationBetweenVectors(a, b);
    return q.getMat4();
};

/**
 * Scale current matrix to the vector values.
 * @public
 * @param {og.math.Vector3} v - Scale vector.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.scale = function (v) {
    var mx = this._m;
    mx[0] = mx[0] * v.x; mx[1] = mx[1] * v.x; mx[2] = mx[2] * v.x; mx[3] = mx[3] * v.x;
    mx[4] = mx[4] * v.y; mx[5] = mx[5] * v.y; mx[6] = mx[6] * v.y; mx[7] = mx[7] * v.y;
    mx[8] = mx[8] * v.z; mx[9] = mx[9] * v.z; mx[10] = mx[10] * v.z; mx[11] = mx[11] * v.z;
    mx[12] = mx[12]; mx[13] = mx[13]; mx[14] = mx[14]; mx[15] = mx[15];
    return this;
};

/**
 * Sets perspective projection matrix frustum values.
 * @public
 * @param {number} left
 * @param {number} right
 * @param {number} bottom
 * @param {number} top
 * @param {number} near
 * @param {number} far
 * @returns {og.math.Mat4}
 */
Mat4.prototype.setFrustum = function (left, right, bottom, top, near, far) {

    this.left = left;
    this.right = right;
    this.bottom = bottom;
    this.top = top;
    this.near = near;
    this.far = far;

    var h = right - left, i = top - bottom, j = far - near;
    this._m[0] = near * 2 / h;
    this._m[1] = 0;
    this._m[2] = 0;
    this._m[3] = 0;
    this._m[4] = 0;
    this._m[5] = near * 2 / i;
    this._m[6] = 0;
    this._m[7] = 0;
    this._m[8] = (right + left) / h;
    this._m[9] = (top + bottom) / i;
    this._m[10] = -(far + near) / j;
    this._m[11] = -1;
    this._m[12] = 0;
    this._m[13] = 0;
    this._m[14] = -(far * near * 2) / j;
    this._m[15] = 0;
    return this;
};

/**
 * Creates current percpective projection matrix.
 * @public
 * @param {number} angle - View angle in degrees.
 * @param {number} aspect - Screen aspect ratio.
 * @param {number} near - Near clip plane.
 * @param {number} far - Far clip plane.
 * @retuns {og.math.Mat4}
 */
Mat4.prototype.setPerspective = function (angle, aspect, near, far) {
    angle = near * Math.tan(angle * Math.PI / 360);
    aspect = angle * aspect;
    return this.setFrustum(-aspect, aspect, -angle, angle, near, far)
};

/**
 * Creates current orthographic projection matrix.
 * @public
 * @param {number} left
 * @param {number} right
 * @param {number} bottom
 * @param {number} top
 * @param {number} near
 * @param {number} far
 * @retuns {og.math.Mat4}
 */
Mat4.prototype.setOrtho = function (left, right, bottom, top, near, far) {
    this.left = left;
    this.right = right;
    this.bottom = bottom;
    this.top = top;
    this.near = near;
    this.far = far;

    var lr = 1.0 / (left - right),
        bt = 1.0 / (bottom - top),
        nf = 1.0 / (near - far),
        m = this._m;

    m[0] = -2.0 * lr;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = -2.0 * bt;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 2.0 * nf;
    m[11] = 0;
    m[12] = (left + right) * lr;
    m[13] = (top + bottom) * bt;
    m[14] = (far + near) * nf;
    m[15] = 1.0;
    return this;
};

/**
 * Sets current rotation matrix by euler's angles.
 * @public
 * @param {number} ax - Rotation angle in radians arond X axis.
 * @param {number} ay - Rotation angle in radians arond Y axis.
 * @param {number} az - Rotation angle in radians arond Z axis.
 * @returns {og.math.Mat4}
 */
Mat4.prototype.eulerToMatrix = function (ax, ay, az) {
    var a = Math.cos(ax),
        b = Math.sin(ax),
        c = Math.cos(ay),
        d = Math.sin(ay),
        e = Math.cos(az),
        f = Math.sin(az);

    var ad = a * d,
        bd = b * d;

    var mat = this._m;

    mat[0] = c * e;
    mat[1] = -c * f;
    mat[2] = -d;
    mat[4] = -bd * e + a * f;
    mat[5] = bd * f + a * e;
    mat[6] = -b * c;
    mat[8] = ad * e + b * f;
    mat[9] = -ad * f + b * e;
    mat[10] = a * c;
    mat[3] = mat[7] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
    mat[15] = 1;

    return this;
};

Mat4.prototype.getEulerAngles = function () {
    //TODO
};





/***/ }),

/***/ "./src/og/math/Quat.js":
/*!*****************************!*\
  !*** ./src/og/math/Quat.js ***!
  \*****************************/
/*! exports provided: quat, Quat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return quat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quat", function() { return Quat; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _Mat4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mat4.js */ "./src/og/math/Mat4.js");
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/math/Quat
 */







/**
 * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
 * @constructor
 * @param {Number} [x=0.0] The X component.
 * @param {Number} [y=0.0] The Y component.
 * @param {Number} [z=0.0] The Z component.
 * @param {Number} [w=0.0] The W component.
 */
const Quat = function (x, y, z, w) {

    /**
     * The X component.
     * @public
     * @type {Number}
     * @default 0.0
     */
    this.x = x || 0.0;

    /**
     * The Y component.
     * @public
     * @type {Number}
     * @default 0.0
     */
    this.y = y || 0.0;

    /**
     * The Z component.
     * @public
     * @type {Number}
     * @default 0.0
     */
    this.z = z || 0.0;

    /**
     * The W component.
     * @public
     * @type {Number}
     * @default 0.0
     */
    this.w = w || 0.0;
};

/**
 * Creates Quat instance.
 * @function
 * @param {Number} [x=0.0] The X component.
 * @param {Number} [y=0.0] The Y component.
 * @param {Number} [z=0.0] The Z component.
 * @param {Number} [w=0.0] The W component.
 * @returns {og.math.Quat}
 */
function quat(x, y, z, w) {
    return new Quat(x, y, z, w);
};

/**
 * Identity Quat.
 * @const
 * @type {og.math.Quat}
 */
Quat.IDENTITY = new Quat(0.0, 0.0, 0.0, 1.0);

/**
 * Returns a Quat represents rotation around X axis.
 * @static
 * @param {number} a - The angle in radians to rotate around the axis.
 * @returns {og.math.Quat}
 */
Quat.xRotation = function (a) {
    a *= 0.5;
    return new Quat(Math.sin(a), 0.0, 0.0, Math.cos(a));
};

/**
 * Returns a Quat represents rotation around Y axis.
 * @static
 * @param {number} a - The angle in radians to rotate around the axis.
 * @returns {og.math.Quat}
 */
Quat.yRotation = function (a) {
    a *= 0.5;
    return new Quat(0.0, Math.sin(a), 0.0, Math.cos(a));
};

/**
 * Returns a Quat represents rotation around Z axis.
 * @static
 * @param {number} a - The angle in radians to rotate around the axis.
 * @returns {og.math.Quat}
 */
Quat.zRotation = function (a) {
    a *= 0.5;
    return new Quat(0.0, 0.0, Math.sin(a), Math.cos(a));
};

/**
 * Computes a Quat representing a rotation around an axis.
 * @static
 * @param {og.math.Vector3} axis - The axis of rotation.
 * @param {number} angle The angle in radians to rotate around the axis.
 * @returns {og.math.Quat}
 */
Quat.axisAngleToQuat = function (axis, angle) {
    var res = new Quat();
    var v = axis.normal();
    var half_angle = angle * 0.5;
    var sin_a = Math.sin(half_angle);
    res.set(v.x * sin_a, v.y * sin_a, v.z * sin_a, Math.cos(half_angle));
    return res;
};

/**
 * Computes a rotation from the given heading and up vector.
 * @static
 * @param {og.math.Vector3} target - Heading target coordinates.
 * @param {og.math.Vector3} up - Up vector.
 * @returns {og.math.Quat}
 */
Quat.getLookAtTargetUp = function (target, up) {
    var forward = target.normal();
    forward = _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"].OrthoNormalize(up, forward); // Keeps up the same, make forward orthogonal to up
    var right = up.cross(forward);
    var ret = new Quat();
    ret.w = Math.sqrt(1.0 + right.x + up.y + forward.z) * 0.5;
    var w4_recip = 1.0 / (4.0 * ret.w);
    ret.x = (forward.y - up.z) * w4_recip;
    ret.y = (right.z - forward.x) * w4_recip;
    ret.z = (up.x - right.y) * w4_recip;
    return ret;
};

/**
 * Computes a Quat from from source point heading to the destination point.
 * @static
 * @param {og.math.Vector3} sourcePoint - Source coordinate.
 * @param {og.math.Vector3} destPoint - Destination coordinate.
 * @returns {og.math.Quat}
 */
Quat.getLookAtSourceDest = function (sourcePoint, destPoint) {
    var forwardVector = destPoint.subA(sourcePoint).normalize();
    var dot = _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"].FORWARD.dot(forwardVector);
    if (Math.abs(dot - (-1.0)) < 0.000001) {
        return Quat.axisAngleToQuat(_Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"].UP, Math.PI);
    }
    if (Math.abs(dot - (1.0)) < 0.000001) {
        return new Quat(0, 0, 0, 1);
    }
    var rotAngle = Math.acos(dot);
    var rotAxis = _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"].FORWARD.cross(forwardVector).normalize();
    return Quat.axisAngleToQuat(rotAxis, rotAngle);
};

/**
 * Compute rotation between two vectors.
 * @static
 * @param {og.math.Vector3} u - First vector.
 * @param {og.math.Vector3} v - Second vector.
 * @returns {og.math.Quat}
 */
Quat.getRotationBetweenVectors = function (u, v) {
    var w = u.cross(v);
    var q = new Quat(w.x, w.y, w.z, 1.0 + u.dot(v));
    return q.normalize();
};

/**
 * Compute rotation between two vectors with around vector up for exactly opposite vectors. If vectors exaclty in the same direction than returns identity Quat.
 * @static
 * @param {og.math.Vector3} source - First vector.
 * @param {og.math.Vector3} dest - Second vector.
 * @param {og.math.Vector3} up - Up vector.
 * @returns {og.math.Quat}
 */
Quat.getRotationBetweenVectorsUp = function (source, dest, up) {
    var dot = source.dot(dest);
    if (Math.abs(dot + 1.0) < 0.000001) {
        // vector source and dest point exactly in the opposite direction, 
        // so it is a 180 degrees turn around the up-axis
        return Quat.axisAngleToQuat(up, Math.PI);
    }
    if (Math.abs(dot - 1.0) < 0.000001) {
        // vector source and dest point exactly in the same direction
        // so we return the identity Quat
        return new Quat(0, 0, 0, 1);
    }
    var rotAngle = Math.acos(dot);
    var rotAxis = source.cross(dest).normalize();
    return Quat.axisAngleToQuat(rotAxis, rotAngle);
};

/**
 * Clear Quat. Sets zeroes.
 * @public
 * @returns {og.math.Quat}
 */
Quat.prototype.clear = function () {
    this.x = this.y = this.z = this.w = 0;
    return this;
};

/**
 * Sets Quat values.
 * @public
 * @param {Number} [x=0.0] The X component.
 * @param {Number} [y=0.0] The Y component.
 * @param {Number} [z=0.0] The Z component.
 * @param {Number} [w=0.0] The W component.
 * @returns {og.math.Quat}
 */
Quat.prototype.set = function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
};

/**
 * Copy Quat values.
 * @public
 * @param {og.math.Quat} q - Copy Quat.
 * @returns {og.math.Quat}
 */
Quat.prototype.copy = function (q) {
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    this.w = q.w;
    return this;
};

/**
 * Set current Quat instance to identity Quat.
 * @public
 * @returns {og.math.Quat}
 */
Quat.prototype.setIdentity = function () {
    this.x = 0.0;
    this.y = 0.0;
    this.z = 0.0;
    this.w = 1.0;
    return this;
};

/**
 * Duplicates a Quat instance.
 * @public
 * @returns {og.math.Quat}
 */
Quat.prototype.clone = function () {
    return new Quat(this.x, this.y, this.z, this.w);
};

/**
 * Computes the componentwise sum of two Quats.
 * @public
 * @param {og.math.Quat} q - Quat to add.
 * @returns {og.math.Quat}
 */
Quat.prototype.add = function (q) {
    return new Quat(this.x + q.x, this.y + q.y, this.z + q.z, this.w + q.w);
};

/**
 * Computes the componentwise difference of two Quats.
 * @public
 * @param {og.math.Quat} q - Quat to subtract.
 * @returns {og.math.Quat}
 */
Quat.prototype.sub = function (q) {
    return new Quat(this.x - q.x, this.y - q.y, this.z - q.z, this.w - q.w);
};

/**
 * Multiplies the provided Quat componentwise by the provided scalar.
 * @public
 * @param {Number} scale - The scalar to multiply with.
 * @returns {og.math.Quat}
 */
Quat.prototype.scaleTo = function (scale) {
    return new Quat(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
};

/**
 * Converts Quat values to array.
 * @public
 * @returns {Array.<number,number,number,number>}
 */
Quat.prototype.toVec = function () {
    return [this.x, this.y, this.z, this.w];
};

/**
 * Sets current cuaternion by spherical coordinates.
 * @public
 * @param {number} lat - Latitude.
 * @param {number} lon - Longitude.
 * @param {number} angle - Angle in radians.
 * @returns {og.math.Quat}
 */
Quat.prototype.setFromSphericalCoords = function (lat, lon, angle) {
    var sin_a = Math.sin(angle / 2);
    var cos_a = Math.cos(angle / 2);
    var sin_lat = Math.sin(lat);
    var cos_lat = Math.cos(lat);
    var sin_long = Math.sin(lon);
    var cos_long = Math.cos(lon);
    this.x = sin_a * cos_lat * sin_long;
    this.y = sin_a * sin_lat;
    this.z = sin_a * sin_lat * cos_long;
    this.w = cos_a;
    return this;
};

/**
 * Gets spherical coordinates.
 * @public
 * @returns {Object} Returns object with latitude, longitude and alpha. 
 */
Quat.prototype.toSphericalCoords = function () {
    var cos_a = this.w;
    var sin_a = Math.sqrt(1.0 - cos_a * cos_a);
    var angle = Math.acos(cos_a) * 2;
    if (Math.abs(sin_a) < 0.0005)
        sin_a = 1;
    var tx = this.x / sin_a;
    var ty = this.y / sin_a;
    var tz = this.z / sin_a;

    var lon, lat = -Math.asin(ty);
    if (tx * tx + tz * tz < 0.0005)
        lon = 0;
    else
        lon = Math.atan2(tx, tz);
    if (lon < 0)
        lon += 360.0;

    return { lat: lat, lon: lon, alpha: Math.acos(cos_a) };
};

/**
 * Sets current Quat representing a rotation around an axis.
 * @public
 * @param {og.math.Vector3} axis - The axis of rotation.
 * @param {number} angle The angle in radians to rotate around the axis.
 * @returns {og.math.Quat}
 */
Quat.prototype.setFromAxisAngle = function (axis, angle) {
    var v = axis.normal();
    var half_angle = angle * 0.5;
    var sin_a = Math.sin(half_angle);
    this.set(v.x * sin_a, v.y * sin_a, v.z * sin_a, Math.cos(half_angle));
    return this;
};

/**
 * Returns axis and angle of the current Quat.
 * @public
 * @returns {Object}
 */
Quat.prototype.getAxisAngle = function () {
    var vl = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    var axis, angle;
    if (vl > 0.0000001) {
        var ivl = 1.0 / vl;
        axis = new _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"](x * ivl, y * ivl, z * ivl);
        if (this.w < 0)
            angle = 2.0 * Math.atan2(-vl, -w); //-PI,0 
        else
            angle = 2.0 * Math.atan2(vl, w); //0,PI 
    } else {
        axis = new _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"](0, 0, 0);
        angle = 0;
    }
    return { axis: axis, angle: angle };
};

/**
 * Sets current Quat by Euler's angles.
 * @public
 * @param {number} pitch - Pitch angle in degrees.
 * @param {number} yaw - Yaw angle in degrees.
 * @param {number} roll - Roll angle in degrees.
 * @returns {og.math.Quat}
 */
Quat.prototype.setFromEulerAngles = function (pitch, yaw, roll) {
    var ex, ey, ez;
    var cr, cp, cy, sr, sp, sy, cpcy, spsy;

    ex = pitch * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] / 2.0;
    ey = yaw * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] / 2.0;
    ez = roll * _math_js__WEBPACK_IMPORTED_MODULE_0__["RADIANS"] / 2.0;

    cr = Math.cos(ex);
    cp = Math.cos(ey);
    cy = Math.cos(ez);

    sr = Math.sin(ex);
    sp = Math.sin(ey);
    sy = Math.sin(ez);

    cpcy = cp * cy;
    spsy = sp * sy;

    this.w = cr * cpcy + sr * spsy;
    this.x = sr * cpcy - cr * spsy;
    this.y = cr * sp * cy + sr * cp * sy;
    this.z = cr * cp * sy - sr * sp * cy;

    return this.normalize();
};

/**
 * Returns Euler's angles of the current Quat.
 * @public
 * @returns {Object}
 */
Quat.prototype.getEulerAngles = function () {
    var matrix = this.getMat4();
    return matrix.getEulerAngles();
};

/**
 * Computes a Quat from the provided 4x4 matrix instance.
 * @public
 * @param {og.math.Matrix4} m - The rotation matrix.
 */
Quat.prototype.setFromMatrix4 = function (m) {
    var tr, s, q = [];
    var i, j, k;
    m = m._m;

    var nxt = [1, 2, 0];

    tr = m[0] + m[5] + m[10];

    if (tr > 0.0) {
        s = Math.sqrt(tr + 1.0);
        this.w = s / 2.0;
        s = 0.5 / s;
        this.x = (m[6] - m[9]) * s;
        this.y = (m[8] - m[2]) * s;
        this.z = (m[1] - m[4]) * s;
    } else {
        i = 0;
        if (m[5] > m[0]) i = 1;
        if (m[10] > m[i * 5]) i = 2;
        j = nxt[i];
        k = nxt[j];

        s = Math.sqrt((m[i * 5] - (m[j * 5] + m[k * 5])) + 1.0);

        q[i] = s * 0.5;

        if (s != 0.0) s = 0.5 / s;

        q[3] = (m[j * 4 + k] - m[k * 4 + j]) * s;
        q[j] = (m[i * 4 + j] + m[j * 4 + i]) * s;
        q[k] = (m[i * 4 + k] + m[k * 4 + i]) * s;

        this.x = q[0];
        this.y = q[1];
        this.z = q[2];
        this.w = q[3];
    }
    return this;
};

/**
 * Converts current Quat to the rotation matrix.
 * @public
 * @returns {og.math.Matrix4}
 */
Quat.prototype.getMat4 = function () {
    var m = new _Mat4_js__WEBPACK_IMPORTED_MODULE_1__["Mat4"]();
    var mx = m._m;
    var c = this.x, d = this.y, e = this.z, g = this.w, f = c + c, h = d + d, i = e + e, j = c * f, k = c * h;
    c = c * i;
    var l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    mx[0] = 1 - (l + e); mx[1] = k - g; mx[2] = c + h; mx[3] = 0;
    mx[4] = k + g; mx[5] = 1 - (j + e); mx[6] = d - f; mx[7] = 0;
    mx[8] = c - h; mx[9] = d + f; mx[10] = 1 - (j + l); mx[11] = 0;
    mx[12] = 0; mx[13] = 0; mx[14] = 0; mx[15] = 1;
    return m;
};

/**
 * Returns quatrenion and vector production.
 * @public
 * @param {og.math.Vector3} v - 3d Vector.
 * @returns {og.math.Vector3}
 */
Quat.prototype.mulVec3 = function (v) {
    var d = v.x, e = v.y, g = v.z;
    var b = this.x, f = this.y, h = this.z, a = this.w;
    var i = a * d + f * g - h * e,
        j = a * e + h * d - b * g,
        k = a * g + b * e - f * d;
    d = -b * d - f * e - h * g;
    return new _Vec3_js__WEBPACK_IMPORTED_MODULE_2__["Vec3"](
        i * a + d * -b + j * -h - k * -f,
        j * a + d * -f + k * -b - i * -h,
        k * a + d * -h + i * -f - j * -b);
};

/**
 * Computes the product of two Quats.
 * @public
 * @param {og.math.Quat} q - Quat to multiply.
 * @returns {og.math.Quat}
 */
Quat.prototype.mul = function (q) {
    var d = this.x, e = this.y, g = this.z, a = this.w;
    var f = q.x, h = q.y, i = q.z, b = q.w;
    return new Quat(
        d * b + a * f + e * i - g * h,
        e * b + a * h + g * f - d * i,
        g * b + a * i + d * h - e * f,
        a * b - d * f - e * h - g * i);
};

/**
 * Gets the conjugate of the Quat.
 * @public
 * @returns {og.math.Quat}
 */
Quat.prototype.conjugate = function () {
    return new Quat(-this.x, -this.y, -this.z, this.w);
};

/** 
 * Computes the inverse of the Quat.
 * @public
 * @retuns {og.math.Quat}
 */
Quat.prototype.inverse = function () {
    var n = 1 / this.magnitude2();
    return new Quat(-this.x * n, -this.y * n, -this.z * n, this.w * n);
};

/**
 * Computes a magnitude of the Quat.
 * @public
 * @returns {number}
 */
Quat.prototype.magnitude = function () {
    var b = this.x, c = this.y, d = this.z, a = this.w;
    return Math.sqrt(b * b + c * c + d * d + a * a);
};

/**
 * Computes a squared magnitude of the Quat.
 * @public
 * @returns {number}
 */
Quat.prototype.magnitude2 = function () {
    var b = this.x, c = this.y, d = this.z, a = this.w;
    return b * b + c * c + d * d + a * a;
};

/**
 * Computes the dot (scalar) product of two Quats.
 * @public
 * @param {og.math.Quat} q - Second quatrnion.
 * @returns {number}
 */
Quat.prototype.dot = function (q) {
    return this.x * q.x + this.y * q.y + this.z * q.z;
};

/**
 * Current Quat normalization.
 * @public
 * @returns {og.math.Quat}
 */
Quat.prototype.normalize = function () {
    var c = this.x, d = this.y, e = this.z, g = this.w,
        f = Math.sqrt(c * c + d * d + e * e + g * g);
    if (f == 0) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
    }
    f = 1 / f;
    this.x = c * f;
    this.y = d * f;
    this.z = e * f;
    this.w = g * f;
    return this;
};

/**
 * Compares two Quats.
 * @public
 * @param {og.math.Quat} q - Second quatrnion.
 * @returns {boolean}
 */
Quat.prototype.isEqual = function (q) {
    var matching = this.dot(q);
    if (Math.abs(matching - 1.0) < 0.001) {
        return true;
    }
    return false;
};

/**
 * Performs a spherical linear interpolation between two Quats.
 * @public
 * @param {og.math.Quat} b - The end rotation Quat.
 * @param {number} t - interpolation amount between the two Quats.
 * @returns {og.math.Quat}
 */
Quat.prototype.slerp = function (b, t) {

    var ax = this.x, ay = this.y, az = this.z, aw = this.w,
        bx = b.x, by = b.y, bz = b.z, bw = b.w;

    var omega, cosom, sinom, scale0, scale1;

    cosom = ax * bx + ay * by + az * bz + aw * bw;

    if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
    }

    if ((1.0 - cosom) > 0.000001) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        scale0 = 1.0 - t;
        scale1 = t;
    }

    return new Quat(
        scale0 * ax + scale1 * bx,
        scale0 * ay + scale1 * by,
        scale0 * az + scale1 * bz,
        scale0 * aw + scale1 * bw
    );
};

/**
 * Returns a roll angle in radians.
 * @public
 * @returns {number}
 */
Quat.prototype.getRoll = function (reprojectAxis) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    if (reprojectAxis) {
        var fTy = 2.0 * y;
        var fTz = 2.0 * z;
        var fTwz = fTz * w;
        var fTxy = fTy * x;
        var fTyy = fTy * y;
        var fTzz = fTz * z;
        return Math.atan2(fTxy + fTwz, 1.0 - (fTyy + fTzz));
    } else {
        return Math.atan2(2 * (x * y + w * z), w * w + x * x - y * y - z * z);
    }
};

/**
 * Returns a pitch angle in radians.
 * @public
 * @returns {number}
 */
Quat.prototype.getPitch = function (reprojectAxis) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    if (reprojectAxis) {
        var fTx = 2.0 * x;
        var fTz = 2.0 * z;
        var fTwx = fTx * w;
        var fTxx = fTx * x;
        var fTyz = fTz * y;
        var fTzz = fTz * z;
        return Math.atan2(fTyz + fTwx, 1.0 - (fTxx + fTzz));
    } else {
        return Math.atan2(2 * (y * z + w * x), w * w - x * x - y * y + z * z);
    }
};

/**
 * Returns a yaw angle in radians.
 * @public
 * @returns {number}
 */
Quat.prototype.getYaw = function (reprojectAxis) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    if (reprojectAxis) {
        var fTx = 2.0 * x;
        var fTy = 2.0 * y;
        var fTz = 2.0 * z;
        var fTwy = fTy * w;
        var fTxx = fTx * x;
        var fTxz = fTz * x;
        var fTyy = fTy * y;
        return Math.atan2(fTxz + fTwy, 1.0 - (fTxx + fTyy));
    } else {
        return Math.asin(-2 * (x * z - w * y));
    }
};



/***/ }),

/***/ "./src/og/math/Ray.js":
/*!****************************!*\
  !*** ./src/og/math/Ray.js ***!
  \****************************/
/*! exports provided: ray, Ray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ray", function() { return ray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/math/Ray
 */







/**
 * Represents a ray that extends infinitely from the provided origin in the provided direction.
 * @class
 * @param {og.math.Vec3} origin - The origin of the ray.
 * @param {og.math.Vec3} direction - The direction of the ray.
 */
const Ray = function (origin, direction) {

    /**
     * The origin of the ray.
     * @public
     * @type {og.math.Vec3}
     */
    this.origin = origin.clone();

    /**
     * The direction of the ray.
     * @public
     * @type {og.math.Vec3}
     */
    this.direction = direction.clone();
};

/**
 * Ray object creator.
 * @function
 * @param {og.math.Vec3} origin - The origin of the ray.
 * @param {og.math.Vec3} direction - The direction of the ray.
 * @returns {og.math.Ray}
 */
function ray(origin, direction) {
    return new Ray(origin, direction);
};

/** @const */
Ray.OUTSIDE = 0;
/** @const */
Ray.INSIDE = 1;
/** @const */
Ray.INPLANE = 2;
/** @const */
Ray.AWAY = 3;

/**
 * Sets a ray parameters.
 * @public
 * @param {og.math.Vec3} origin - The origin of the ray.
 * @param {og.math.Vec3} direction - The direction of the ray.
 * @returns {og.math.Ray}
 */
Ray.prototype.set = function (origin, direction) {
    this.origin = origin.clone();
    this.direction = direction.clone();
    return this;
};

/**
 * Computes the point along the ray on the distance.
 * @public
 * @param {number} distance - Point distance.
 * @returns {og.math.Vec3}
 */
Ray.prototype.getPoint = function (distance) {
    return _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].add(this.origin, this.direction.scaleTo(distance));
};

/**
 * Returns ray hit a triange result.
 * @public
 * @param {og.math.Vec3} v0 - First triangle corner coordinate.
 * @param {og.math.Vec3} v1 - Second triangle corner coordinate.
 * @param {og.math.Vec3} v2 - Third triangle corner coordinate.
 * @param {og.math.Vec3} res - Hit point object pointer that stores hit result.
 * @returns {number} - Hit code, could 0 - og.math.Ray.OUTSIDE, 1 - og.math.Ray.INSIDE, 
 *      2 - og.math.Ray.INPLANE and 3 - og.math.Ray.AWAY(ray goes away from triangle).
 */
Ray.prototype.hitTriangle = function (v0, v1, v2, res) {
    var state;
    var u = v1.sub(v0);
    var v = v2.sub(v0);
    var n = u.cross(v);

    var w0 = this.origin.sub(v0);
    var a = -n.dot(w0);
    var b = n.dot(this.direction);

    // ray is  parallel to triangle plane
    if (Math.abs(b) < _math_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON10"]) {
        if (a === 0) {
            res.copy(this.origin);
            // ray lies in triangle plane
            return Ray.INPLANE;
        } else {
            // ray disjoint from plane
            return Ray.OUTSIDE;
        }
    }

    var r = a / b;

    // intersect point of ray and plane
    res.copy(this.origin.add(this.direction.scaleTo(r)));

    // ray goes away from triangle
    if (r < 0.0)
        return Ray.AWAY;

    // is res point inside the triangle?
    var uu = u.dot(u);
    var uv = u.dot(v);
    var vv = v.dot(v);
    var w = res.sub(v0);
    var wu = w.dot(u);
    var wv = w.dot(v);
    var D = uv * uv - uu * vv;

    var s = (uv * wv - vv * wu) / D;
    if (s < 0.0 || s > 1.0)
        return Ray.OUTSIDE;

    var t = (uv * wu - uu * wv) / D;
    if (t < 0.0 || (s + t) > 1.0)
        return Ray.OUTSIDE;

    return Ray.INSIDE;
};

/**
 * Gets a ray hit a plane result. If the ray cross the plane returns 1 - og.math.Ray.INSIDE otherwise returns 0 - og.math.Ray.OUTSIDE.
 * @public
 * @param {og.math.Vec3} v0 - First plane point.
 * @param {og.math.Vec3} v1 - Second plane point.
 * @param {og.math.Vec3} v2 - Third plane point.
 * @param {og.math.Vec3} res - Hit point object pointer that stores hit result.
 * @returns {number}
 */
Ray.prototype.hitPlane = function (v0, v1, v2, res) {
    var u = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(v1, v0);
    var v = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(v2, v0);
    var n = u.cross(v);

    var w0 = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(this.origin, v0);
    var a = -n.dot(w0);
    var b = n.dot(this.direction);

    // ray is  parallel to the plane
    if (Math.abs(b) < _math_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON10"]) {
        if (a === 0) {
            return Ray.OUTSIDE;
        }
    }

    var r = a / b;

    if (r < 0) {
        return Ray.OUTSIDE;
    }

    var d = this.direction.scaleTo(r);

    // intersect point of ray and plane
    res.x = this.origin.x + d.x;
    res.y = this.origin.y + d.y;
    res.z = this.origin.z + d.z;

    return Ray.INSIDE;
};

/**
 * Returns a ray hit sphere coordiante. If there isn't hit returns null.
 * @public
 * @param {og.bv.Sphere} sphere - Sphere object.
 * @returns {og.math.Vec3}
 */
Ray.prototype.hitSphere = function (sphere) {
    var r = sphere.radius,
        c = sphere.center,
        o = this.origin,
        d = this.direction;
    var vpc = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(c, o);
    if (vpc.dot(d) < 0) {
        var l = vpc.length();
        if (l > r) {
            return null;
        } else if (l === r) {
            return o.clone();
        }
        var pc = c.projToRay(o, vpc);
        var lc = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(pc, c).length();
        var dist = Math.sqrt(r * r - lc * lc);
        var di1 = dist - _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(pc, o).length();
        var intersection = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].add(o, d.scaleTo(di1));
        return intersection;
    } else {
        var pc = c.projToRay(o, d);
        var cpcl = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].sub(c, pc).length();
        if (cpcl > sphere.radius) {
            return null;
        } else {
            var dist = Math.sqrt(r * r - cpcl * cpcl);
            var di1;
            pc.subA(o);
            if (vpc.length() > r) {
                di1 = pc.length() - dist;
            } else {
                di1 = pc.length() + dist;
            }
            var intersection = _Vec3_js__WEBPACK_IMPORTED_MODULE_1__["Vec3"].add(o, d.scaleTo(di1));
            return intersection;
        }
    }
};

Ray.prototype.hitBox = function (box) {
    //
    //TODO
    //
};



/***/ }),

/***/ "./src/og/math/Vec2.js":
/*!*****************************!*\
  !*** ./src/og/math/Vec2.js ***!
  \*****************************/
/*! exports provided: vec2, Vec2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return vec2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vec2", function() { return Vec2; });
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/math/Vec2
 */





/**
 * Class represents a 3d vector.
 * @class
 * @param {number} [x] - First value.
 * @param {number} [y] - Second value.
 */
const Vec2 = function (x, y) {

    /**
     * @public
     * @type {number}
     */
    this.x = x || 0.0;

    /**
     * @public
     * @type {number}
     */
    this.y = y || 0.0;
};

/**
 * Vector 2d object creator.
 * @function
 * @param {number} [x] - First cvalue.
 * @param {number} [y] - Second value.
 * @returns {og.math.Vec2}
 */
function vec2(x, y) {
    return new Vec2(x, y);
};

/** @const */
Vec2.UP = new Vec2(0, 1);
/** @const */
Vec2.DOWN = new Vec2(0, -1);
/** @const */
Vec2.RIGHT = new Vec2(1, 0);
/** @const */
Vec2.LEFT = new Vec2(-1, 0);
/** @const */
Vec2.ZERO = new Vec2();

/**
 * Returns summary vector.
 * @static
 * @param {og.math.Vec2} a - First vector.
 * @param {og.math.Vec2} b - Second vector.
 * @returns {og.math.Vec2} - Summary vector.
 */
Vec2.add = function (a, b) {
    var res = new Vec2(a.x, a.y);
    res.addA(b);
    return res;
};

/**
 * Returns two vectors subtraction.
 * @static
 * @param {og.math.Vec2} a - First vector.
 * @param {og.math.Vec2} b - Second vector.
 * @returns {og.math.Vec2} - Vectors subtraction.
 */
Vec2.sub = function (a, b) {
    var res = new oVec2(a.x, a.y);
    res.subA(b);
    return res;
};

/**
 * Returns scaled vector.
 * @static
 * @param {og.math.Vec2} a - Input vector.
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec2}
 */
Vec2.scale = function (a, scale) {
    var res = new Vec2(a.x, a.y);
    res.scale(scale)
    return res;
};

/**
 * Returns two vectors production.
 * @static
 * @param {og.math.Vec2} a - First vector.
 * @param {og.math.Vec2} b - Second vector.
 * @returns {og.math.Vec2}
 */
Vec2.mul = function (a, b) {
    var res = new Vec2(a.x, a.y);
    res.mulA(b);
    return res;
};

/**
 * Returns vector components division product one to another.
 * @static
 * @param {og.math.Vec2} a - First vector.
 * @param {og.math.Vec2} b - Second vector.
 * @returns {og.math.Vec2}
 */
Vec2.div = function (a, b) {
    var res = new Vec2(a.x, a.y);
    res.divA(b);
    return res;
};

/**
 * Get projection of the first vector to the second.
 * @static
 * @param {og.math.Vec2} b - First vector.
 * @param {og.math.Vec2} a - Second vector.
 * @returns {og.math.Vec2}
 */
Vec2.proj_b_to_a = function (b, a) {
    return a.scaleTo(a.dot(b) / a.dot(a));
};

/**
 * Gets angle between two vectors.
 * @static
 * @param {og.math.Vec2} a - First vector.
 * @param {og.math.Vec2} b - Second vector.
 * @returns {number}
 */
Vec2.angle = function (a, b) {
    return Math.acos(a.dot(b) / Math.sqrt(a.length2() * b.length2()));
};

/**
 * Makes vectors normalized and orthogonal to each other.
 * @static
 * @param {og.math.Vec2} normal - Normal vector.
 * @param {og.math.Vec2} tangent - Tangent vector.
 * @returns {og.math.Vec2}
 */
Vec2.orthoNormalize = function (normal, tangent) {
    normal = normal.norm();
    normal.scale(tangent.dot(normal));
    return tangent.sub(normal).normalize();
};

/**
 * Converts to 3d vector, third value is 0.0.
 * @public
 * @returns {og.math.Vector3}
 */
Vec2.prototype.toVector3 = function () {
    return new _Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](this.x, this.y, 0);
};

/**
 * Returns clone vector.
 * @public
 * @returns {og.math.Vec2}
 */
Vec2.prototype.clone = function () {
    return new Vec2(this.x, this.y);
};

/**
 * Compares with vector. Returns true if it equals another.
 * @public
 * @param {og.math.Vec2} p - Vector to compare.
 * @returns {boolean}
 */
Vec2.prototype.equal = function (p) {
    return this.x === p.x && this.y === p.y;
};

/**
 * Copy input vector's values.
 * @param {og.math.Vec2} point2 - Vector to copy.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.copy = function (point2) {
    this.x = point2.x;
    this.y = point2.y;
    return this;
};

/**
 * Gets vector's length.
 * @public
 * @returns {number}
 */
Vec2.prototype.length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Returns squared vector's length.
 * @public
 * @returns {number}
 */
Vec2.prototype.length2 = function () {
    return this.x * this.x + this.y * this.y;
};

/**
 * Adds vector to the current.
 * @public
 * @param {og.math.Vec2}
 * @returns {og.math.Vec2}
 */
Vec2.prototype.addA = function (v) {
    this.x += v.x;
    this.y += v.y;
    return this;
};

/**
 * Summarize two vectors.
 * @public
 * @param {og.math.Vec2}
 * @returns {og.math.Vec2}
 */
Vec2.prototype.add = function (v) {
    return new Vec2(this.x + v.x, this.y + v.y);
};

/**
 * Subtract vector from the current where results saved on the current instance.
 * @public
 * @param {og.math.Vec2} v - Subtract vector.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.subA = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
};

/**
 * Subtract vector from the current.
 * @public
 * @param {og.math.Vec2} v - Subtract vector.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.sub = function (v) {
    return new Vec2(this.x - v.x, this.y - v.y);
};

/**
 * Scale current vector.
 * @public
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.scale = function (scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
};

/**
 * Scale current vector to another instance.
 * @public
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.scaleTo = function (scale) {
    return new Vec2(this.x * scale, this.y * scale);
};

/**
 * Multiply current vector object to another and store result in the current instance.
 * @public
 * @param {og.math.Vec2} vec - Multiply vector.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.mulA = function (vec) {
    this.x *= vec.x;
    this.y *= vec.y;
    return this;
};

/**
 * Multiply current vector object to another and returns new vector instance.
 * @public
 * @param {og.math.Vec2} vec - Multiply vector.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.mul = function (vec) {
    return new Vec2(this.x * vec.x, this.y * vec.y);
};


/**
 * Divide current vector's components to another. Results stores in the current vector object.
 * @public
 * @param {og.math.Vec2}
 * @returns {og.math.Vec2}
 */
Vec2.prototype.divA = function (vec) {
    this.x /= vec.x;
    this.y /= vec.y;
    return this;
};

/**
 * Gets vectors dot production.
 * @public
 * @param {og.math.Vec2} v - Another vector.
 * @returns {number}
 */
Vec2.prototype.dot = function (v) {
    return v.x * this.x + v.y * this.y;
};

/**
 * Gets vectors dot production.
 * @public
 * @param {Array.<number,number>} arr - Array vector.
 * @returns {number}
 */
Vec2.prototype.dotArr = function (arr) {
    return arr[0] * this.x + arr[1] * this.y;
};

/**
 * Gets vectors cross production.
 * @public
 * @param {og.math.Vec2} v - Another vector.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.cross = function (v) {
    return this.x * v.y - this.y * v.x;
};

/**
 * Sets vector to zero.
 * @public
 * @returns {og.math.Vec2}
 */
Vec2.prototype.clear = function () {
    this.x = this.y = 0;
    return this;
};

/**
 * Returns normalized vector.
 * @public
 * @returns {og.math.Vec2}
 */
Vec2.prototype.normal = function () {
    var res = new Vec2();
    res.copy(this);

    var length = 1.0 / res.length();

    res.x *= length;
    res.y *= length;

    return res;
};

/**
 * Normalize current vector.
 * @public
 * @returns {og.math.Vec2}
 */
Vec2.prototype.normalize = function () {
    var length = 1.0 / this.length();

    this.x *= length;
    this.y *= length;

    return this;
};

/**
 * Converts vector to a number array.
 * @public
 * @returns {Array.<number,number>}
 */
Vec2.prototype.toVec = function () {
    return [this.x, this.y];
};

/**
 * Gets distance to point.
 * @public
 * @param {og.math.Vec2} p - Distant point.
 * @returns {number}
 */
Vec2.prototype.distance = function (p) {
    var vec = Vec2.sub(this, p);
    return vec.length();
};

/**
 * Sets vector's values.
 * @public
 * @param {number} x - Value X.
 * @param {number} y - Value Y.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.set = function (x, y) {
    this.x = x;
    this.y = y;
    return this;
};

/**
 * Negate current vector.
 * @public
 * @returns {og.math.Vec2}
 */
Vec2.prototype.negate = function () {
    this.x = -this.x;
    this.y = -this.y;
    return this;
};

/**
 * Negate current vector to another instance.
 * @public
 * @returns {og.math.Vec2}
 */
Vec2.prototype.negateTo = function () {
    return new Vec2(-this.x, -this.y);
};

/**
 * Gets projected point coordinates of the current vector on the ray.
 * @public
 * @param {og.math.Vec2} pos - Ray position.
 * @param {og.math.Vec2} direction - Ray direction.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.projToRay = function (pos, direction) {
    var v = Vec2.proj_b_to_a(Vec2.sub(this, pos), direction);
    v.add(pos);
    return v;
};

/**
 * Gets angle between two vectors.
 * @public
 * @param {og.math.Vec2} a - Another vector.
 * @returns {number}
 */
Vec2.prototype.angle = function (a) {
    return Vec2.angle(this, a);
};

/**
 * Returns two vectors linear interpolation.
 * @public
 * @param {og.math.Vec2} v2 - End vector.
 * @param {number} l - Interpolate value.
 * @returns {og.math.Vec2}
 */
Vec2.prototype.lerp = function (v1, v2, l) {
    var res = Vec2.clone(this);
    if (l <= 0.0) {
        res.copy(v1);
    } else if (l >= 1.0) {
        res.copy(v2);
    } else {
        res = Vec2.add(v1, Vec2.sub(v2, v1).scale(l));
    }
    return res;
};

Vec2.LERP_DELTA = 1e-6;

/**
 * Spherically interpolates between two vectors.
 * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that 
 * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated 
 * by the angle and its magnitude is interpolated between the magnitudes of from and to.
 * @public
 * @param {og.math.Vec2} v2 - 
 * @param {number} t - The parameter t is clamped to the range [0, 1].
 * @returns {og.math.Vec2}
 */
Vec2.prototype.slerp = function (v2, t) {
    var res = new Vec2();

    if (t <= 0.0) {
        res.copy(this);
        return;
    } else if (t >= 1.0) {
        res.copy(v2);
        return;
    }

    var omega, sinom, scale0, scale1;
    var cosom = this.dot(v2);

    if ((1.0 - cosom) > Vec2.LERP_DELTA) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        scale0 = 1.0 - t;
        scale1 = t;
    }

    return Vec2.add(this.scale(scale0), v2.scale(scale1));
};



/***/ }),

/***/ "./src/og/math/Vec3.js":
/*!*****************************!*\
  !*** ./src/og/math/Vec3.js ***!
  \*****************************/
/*! exports provided: vec3, Vec3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return vec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vec3", function() { return Vec3; });
/* harmony import */ var _Vec4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec4.js */ "./src/og/math/Vec4.js");
/* harmony import */ var _Quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quat.js */ "./src/og/math/Quat.js");
/**
 * @module og/math/Vec3
 */






/**
 * Class represents a 3d vector.
 * @class
 * @param {number} [x] - First value.
 * @param {number} [y] - Second value.
 * @param {number} [z] - Third value.
 */
const Vec3 = function (x, y, z) {

    /**
     * @public
     * @type {number}
     */
    this.x = x || 0.0;

    /**
     * @public
     * @type {number}
     */
    this.y = y || 0.0;

    /**
     * @public
     * @type {number}
     */
    this.z = z || 0.0;
};

/** @const */
Vec3.UP = new Vec3(0, 1, 0);
/** @const */
Vec3.DOWN = new Vec3(0, -1, 0);
/** @const */
Vec3.RIGHT = new Vec3(1, 0, 0);
/** @const */
Vec3.LEFT = new Vec3(-1, 0, 0);
/** @const */
Vec3.FORWARD = new Vec3(0, 0, -1);
/** @const */
Vec3.BACKWARD = new Vec3(0, 0, 1);
/** @const */
Vec3.ZERO = new Vec3();

/**
 * Vector 3d object creator.
 * @function
 * @param {number} [x] - First cvalue.
 * @param {number} [y] - Second value.
 * @param {number} [z] - Third value.
 * @returns {og.math.Vec3}
 */
function vec3(x, y, z) {
    return new Vec3(x, y, z);
};

/**
 * Creates 3d vector from array.
 * @function
 * @param {Array.<number,number,number>}
 * @returns {og.math.Vec3}
 */
Vec3.fromVec = function (arr) {
    return new Vec3(arr[0], arr[1], arr[2]);
};

/**
 * Gets angle between two vectors.
 * @static
 * @param {og.math.Vec3} a - First vector.
 * @param {og.math.Vec3} b - Second vector.
 * @returns {number}
 */
Vec3.angle = function (a, b) {
    return Math.acos(a.dot(b) / Math.sqrt(a.length2() * b.length2()));
};

/**
 * Returns two vectors linear interpolation.
 * @static
 * @param {og.math.Vec3} v1 - Start vector.
 * @param {og.math.Vec3} v2 - End vector.
 * @param {number} l - Interpolate value.
 * @returns {og.math.Vec3}
 */
Vec3.lerp = function (v1, v2, l) {
    return Vec3(v1.x + (v2.x - v1.x) * l, v1.y + (v2.y - v1.y) * l, v1.z + (v2.z - v1.z) * l);
};

/**
 * Returns summary vector.
 * @static
 * @param {og.math.Vec3} a - First vector.
 * @param {og.math.Vec3} b - Second vector.
 * @returns {og.math.Vec3} - Summary vector.
 */
Vec3.add = function (a, b) {
    var res = new Vec3(a.x, a.y, a.z);
    res.addA(b);
    return res;
};

/**
 * Returns two vectors subtraction.
 * @static
 * @param {og.math.Vec3} a - First vector.
 * @param {og.math.Vec3} b - Second vector.
 * @returns {og.math.Vec3} - Vectors subtraction.
 */
Vec3.sub = function (a, b) {
    var res = new Vec3(a.x, a.y, a.z);
    res.subA(b);
    return res;
};

/**
 * Returns scaled vector.
 * @static
 * @param {og.math.Vec3} a - Input vector.
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec3}
 */
Vec3.scale = function (a, scale) {
    var res = new Vec3(a.x, a.y, a.z);
    res.scale(scale)
    return res;
};

/**
 * Returns two vectors production.
 * @static
 * @param {og.math.Vec3} a - First vector.
 * @param {og.math.Vec3} b - Second vector.
 * @returns {og.math.Vec3}
 */
Vec3.mul = function (a, b) {
    var res = new Vec3(a.x, a.y, a.z);
    res.mulA(b);
    return res;
};

/**
 * Returns true if two vectors are non collinear.
 * @public
 * @param {og.math.Vec3} a - First vector.
 * @param {og.math.Vec3} b - Second vector.
 * @returns {og.math.Vec3}
 */
Vec3.noncollinear = function (a, b) {
    return a.y * b.z - a.z * b.y || a.z * b.x - a.x * b.z || a.x * b.y - a.y * b.z;
};

/**
 * Get projection of the vector to plane where n - normal to the plane.
 * @static
 * @param {og.math.Vec3} b - Vector.
 * @param {og.math.Vec3} n - Plane normal.
 * @returns {og.math.Vec3}
 */
Vec3.proj_b_to_plane = function (b, n, def) {
    var res = b.sub(n.scaleTo(n.dot(b) / n.dot(n)));
    if (def && res.isZero()) {
        return new Vec3(def.x, def.y, def.z);
    }
    return res;
};

/**
 * Get projection of the first vector to the second.
 * @static
 * @param {og.math.Vec3} b - First vector.
 * @param {og.math.Vec3} a - Second vector.
 * @returns {og.math.Vec3}
 */
Vec3.proj_b_to_a = function (b, a) {
    return a.scaleTo(a.dot(b) / a.dot(a));
};

/**
 * Makes vectors normalized and orthogonal to each other.
 * Normalizes normal. Normalizes tangent and makes sure it is orthogonal to normal (that is, angle between them is 90 degrees).
 * @static
 * @param {og.math.Vec3} normal - Normal vector.
 * @param {og.math.Vec3} tangent - Tangent vector.
 * @returns {og.math.Vec3}
 */
Vec3.orthoNormalize = function (normal, tangent) {
    normal = normal.normal();
    normal.scale(tangent.dot(normal));
    return tangent.subA(normal).normalize();
};

/**
 * Returns vector components division product one to another.
 * @static
 * @param {og.math.Vec3} a - First vector.
 * @param {og.math.Vec3} b - Second vector.
 * @returns {og.math.Vec3}
 */
Vec3.div = function (a, b) {
    var res = new Vec3(a.x, a.y, a.z);
    res.divA(b);
    return res;
};

/**
 * Converts to 4d vector, Fourth value is 1.0.
 * @public
 * @returns {og.math.Vector4}
 */
Vec3.prototype.toVec4 = function () {
    return new _Vec4_js__WEBPACK_IMPORTED_MODULE_0__["Vec4"](this.x, this.y, this.z, 1.0);
};

/**
 * Returns clone vector.
 * @public
 * @returns {og.math.Vec3}
 */
Vec3.prototype.clone = function () {
    return new Vec3(this.x, this.y, this.z);
};

/**
 * Converts vector to text string.
 * @public
 * @returns {string}
 */
Vec3.prototype.toString = function () {
    return "(" + this.x + "," + this.y + "," + this.z + ")";
};

/**
 * Returns true if vector's values are zero.
 * @public
 * @returns {boolean}
 */
Vec3.prototype.isZero = function () {
    return !(this.x || this.y || this.z);
};

/**
 * Get projection of the first vector to the second.
 * @static
 * @param {og.math.Vec3} a - Project vector.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.projToVec = function (a) {
    return a.scaleTo(a.dot(this) / a.dot(a));
};

/**
 * Compares with vector. Returns true if it equals another.
 * @public
 * @param {og.math.Vec3} p - Vector to compare.
 * @returns {boolean}
 */
Vec3.prototype.equal = function (p) {
    return this.x === p.x && this.y === p.y && this.z === p.z;
};

/**
 * Copy input vector's values.
 * @param {og.math.Vec3} point3 - Vector to copy.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.copy = function (point3) {
    this.x = point3.x;
    this.y = point3.y;
    this.z = point3.z;
    return this;
};

/**
 * Gets vector's length.
 * @public
 * @returns {number}
 */
Vec3.prototype.length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
};

/**
 * Returns squared vector's length.
 * @public
 * @returns {number}
 */
Vec3.prototype.length2 = function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
};

/**
 * Converts vector's values to a quaternion object.
 * @public
 * @returns {og.math.Quat}
 */
Vec3.prototype.getQuat = function () {
    return new _Quat_js__WEBPACK_IMPORTED_MODULE_1__["Quat"](this.x, this.y, this.z);
};

/**
 * Adds vector to the current.
 * @public
 * @param {og.math.Vec3}
 * @returns {og.math.Vec3}
 */
Vec3.prototype.addA = function (point3) {
    this.x += point3.x;
    this.y += point3.y;
    this.z += point3.z;
    return this;
};

/**
 * Gets two vectors summarization.
 * @public
 * @param {og.math.Vec3} - Vector to add.
 * @returns {og.math.Vec3} Returns a sum vector.
 */
Vec3.prototype.add = function (point3) {
    return new Vec3(this.x + point3.x, this.y + point3.y, this.z + point3.z);
};

/**
 * Subtract vector from the current.
 * @public
 * @param {og.math.Vec3} point3 - Subtract vector.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.subA = function (point3) {
    this.x -= point3.x;
    this.y -= point3.y;
    this.z -= point3.z;
    return this;
};

/**
 * Gets vector subtraction.
 * @public
 * @param {og.math.Vec3} point3 - Subtract vector.
 * @return {og.math.Vec3} Returns new instance of a subtraction
 */
Vec3.prototype.sub = function (point3) {
    return new Vec3(this.x - point3.x, this.y - point3.y, this.z - point3.z);
};

/**
 * Scale current vector.
 * @public
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.scale = function (scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    return this;
};

/**
 * Scale current vector to another instance.
 * @public
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.scaleTo = function (scale) {
    return new Vec3(this.x * scale, this.y * scale, this.z * scale);
};

/**
 * Multiply current vector object to another and store result in the current instance.
 * @public
 * @param {og.math.Vec3} vec - Multiply vector.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.mulA = function (vec) {
    this.x *= vec.x;
    this.y *= vec.y;
    this.z *= vec.z;
    return this;
};

/**
 * Multiply current vector object to another and returns new vector instance.
 * @public
 * @param {og.math.Vec3} vec - Multiply vector.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.mul = function (vec) {
    return new Vec3(this.x * vec.x, this.y * vec.y, this.z * vec.z);
};

/**
 * Divide current vector's components to another. Results stores in the current vector object.
 * @public
 * @param {og.math.Vec3}
 * @returns {og.math.Vec3}
 */
Vec3.prototype.divA = function (vec) {
    this.x /= vec.x;
    this.y /= vec.y;
    this.z /= vec.z;
    return this;
};

/**
 * Divide current vector's components to another and returns new vector instance.
 * @public
 * @param {og.math.Vec3}
 * @returns {og.math.Vec3}
 */
Vec3.prototype.div = function (vec) {
    return new Vec3(this.x / vec.x, this.y / vec.y, this.z / vec.z);
};

/**
 * Gets vectors dot production.
 * @public
 * @param {og.math.Vec3} point3 - Another vector.
 * @returns {number}
 */
Vec3.prototype.dot = function (point3) {
    return point3.x * this.x + point3.y * this.y + point3.z * this.z;
};

/**
 * Gets vectors dot production.
 * @public
 * @param {Array.<number,number,number>} arr - Array vector.
 * @returns {number}
 */
Vec3.prototype.dotArr = function (arr) {
    return arr[0] * this.x + arr[1] * this.y + arr[2] * this.z;
};


/**
 * Gets vectors cross production.
 * @public
 * @param {og.math.Vec3} point3 - Another vector.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.cross = function (point3) {
    return new Vec3(
        this.y * point3.z - this.z * point3.y,
        this.z * point3.x - this.x * point3.z,
        this.x * point3.y - this.y * point3.x
    );
};

/**
 * Sets vector to zero.
 * @public
 * @returns {og.math.Vec3}
 */
Vec3.prototype.clear = function () {
    this.x = this.y = this.z = 0;
    return this;
};

/**
 * Returns normalized vector.
 * @public
 * @returns {og.math.Vec3}
 */
Vec3.prototype.normal = function () {
    var res = new Vec3();
    res.copy(this);

    var length = 1.0 / res.length();

    res.x *= length;
    res.y *= length;
    res.z *= length;

    return res;
};

/**
 * Normalize current vector.
 * @public
 * @returns {og.math.Vec3}
 */
Vec3.prototype.normalize = function () {
    var length = 1.0 / this.length();

    this.x *= length;
    this.y *= length;
    this.z *= length;

    return this;
};

/**
 * Converts vector to a number array.
 * @public
 * @returns {Array.<number,number,number>}
 * @deprecated
 */
Vec3.prototype.toVec = function () {
    return [this.x, this.y, this.z];
};

/**
 * Converts vector to a number array.
 * @public
 * @returns {Array.<number,number,number>}
 */
Vec3.prototype.toArray = function () {
    return [this.x, this.y, this.z];
};

/**
 * Gets distance to point.
 * @public
 * @param {og.math.Vec3} point3 - Distant point.
 * @returns {number}
 */
Vec3.prototype.distance = function (point3) {
    return Vec3.sub(this, point3).length();
};

/**
 * Sets vector's values.
 * @public
 * @param {number} x - Value X.
 * @param {number} y - Value Y.
 * @param {number} z - Value Z.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.set = function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
};

/**
 * Negate current vector.
 * @public
 * @returns {og.math.Vec3}
 */
Vec3.prototype.negate = function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Negate current vector to another instance.
 * @public
 * @returns {og.math.Vec3}
 */
Vec3.prototype.negateTo = function () {
    return new Vec3(-this.x, -this.y, -this.z);
};

/**
 * Gets projected point coordinates of the current vector on the ray.
 * @public
 * @param {og.math.Vec3} pos - Ray position.
 * @param {og.math.Vec3} direction - Ray direction.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.projToRay = function (pos, direction) {
    var v = Vec3.proj_b_to_a(Vec3.sub(this, pos), direction);
    v.addA(pos);
    return v;
};

/**
 * Gets angle between two vectors.
 * @public
 * @param {og.math.Vec3} a - Another vector.
 * @returns {number}
 */
Vec3.prototype.angle = function (a) {
    return Vec3.angle(this, a);
};

/**
 * Returns two vectors linear interpolation.
 * @public
 * @param {og.math.Vec3} v2 - End vector.
 * @param {number} l - Interpolate value.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.lerp = function (v2, l) {
    return new Vec3(this.x + (v2.x - this.x) * l, this.y + (v2.y - this.y) * l, this.z + (v2.z - this.z) * l);
};

/**
 * Returns vector interpolation by v(t) = v1 * t + v2 * (1 - t)
 * @public
 * @param {og.math.Vec3} v2 - End vector.
 * @param {number} t - Interpolate value.
 * @returns {og.math.Vec3}
 */
Vec3.prototype.smerp = function (v2, t) {
    var one_d = 1 - t;
    return new Vec3(this.x * t + v2.x * one_d, this.y * t + v2.y * one_d, this.z * t + v2.z * one_d);
};

Vec3.LERP_DELTA = 1e-6;

/**
 * Spherically interpolates between two vectors.
 * Interpolates between current and v2 vector by amount t. The difference between this and linear interpolation (aka, "lerp") is that 
 * the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated 
 * by the angle and its magnitude is interpolated between the magnitudes of from and to.
 * @public
 * @param {og.math.Vec3} v2 - 
 * @param {number} t - The parameter t is clamped to the range [0, 1].
 * @returns {og.math.Vec3}
 */
Vec3.prototype.slerp = function (v2, t) {
    var res = new Vec3();

    if (t <= 0.0) {
        res.copy(this);
        return;
    } else if (t >= 1.0) {
        res.copy(v2);
        return;
    }

    var omega, sinom, scale0, scale1;
    var cosom = this.dot(v2);

    if ((1.0 - cosom) > Vec3.LERP_DELTA) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        scale0 = 1.0 - t;
        scale1 = t;
    }

    return Vec3.add(this.scaleTo(scale0), v2.scale(scale1));
};



/***/ }),

/***/ "./src/og/math/Vec4.js":
/*!*****************************!*\
  !*** ./src/og/math/Vec4.js ***!
  \*****************************/
/*! exports provided: vec4, Vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return vec4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vec4", function() { return Vec4; });
/* harmony import */ var _Vec3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/math/Vec4
 */





/**
 * Class represents a 4d vector.
 * @class
 * @param {number} [x] - First value.
 * @param {number} [y] - Second value.
 * @param {number} [z] - Third value.
 * @param {number} [w] - Fourth value.
 */
const Vec4 = function (x, y, z, w) {

    /**
     * @public
     * @type {number}
     */
    this.x = x || 0.0;

    /**
     * @public
     * @type {number}
     */
    this.y = y || 0.0;

    /**
     * @public
     * @type {number}
     */
    this.z = z || 0.0;

    /**
     * @public
     * @type {number}
     */
    this.w = w || 0.0;
};

/**
 * Identity vector [0,0,0,1].
 * @const
 * @type {og.math.Vec4}
 */
Vec4.identity = new Vec4(0, 0, 0, 1);

/**
 * Vector 4d object creator.
 * @function
 * @param {number} [x] - First cvalue.
 * @param {number} [y] - Second value.
 * @param {number} [z] - Third value.
 * @param {number} [w] - Fourth value.
 * @returns {og.math.Vec4}
 */
function vec4(x, y, z, w) {
    return new og.math.Vec4(x, y, z, w);
};

/**
 * Creates 4d vector from array.
 * @function
 * @param {Array.<number,number,number,number>}
 * @returns {og.math.Vec4}
 */
Vec4.fromVec = function (arr) {
    return new Vec4(arr[0], arr[1], arr[2], arr[3]);
};

/**
 * Converts to 3d vector, without fourth value.
 * @public
 * @returns {og.math.Vector3}
 */
Vec4.prototype.toVec3 = function () {
    return new _Vec3_js__WEBPACK_IMPORTED_MODULE_0__["Vec3"](this.x, this.y, this.z);
};

/**
 * Returns clone vector.
 * @public
 * @returns {og.math.Vec4}
 */
Vec4.prototype.clone = function (v) {
    return new Vec4(this.x, this.y, this.z, this.w);
};

/**
 * Compares with vector. Returns true if it equals another.
 * @public
 * @param {og.math.Vec4} p - Vector to compare.
 * @returns {boolean}
 */
Vec4.prototype.equal = function (v) {
    return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
};

/**
 * Copy input vector's values.
 * @param {og.math.Vec4} v - Vector to copy.
 * @returns {og.math.Vec4}
 */
Vec4.prototype.copy = function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w;
    return this;
};

/**
 * Converts vector to a number array.
 * @public
 * @returns {Array.<number,number,number,number>}
 * @deprecated
 */
Vec4.prototype.toVec = function () {
    return [this.x, this.y, this.z, this.w];
};


/**
 * Converts vector to a number array.
 * @public
 * @returns {Array.<number,number,number,number>}
 */
Vec4.prototype.toArray = function () {
    return [this.x, this.y, this.z, this.w];
};

/**
 * Sets vector's values.
 * @public
 * @param {number} x - Value X.
 * @param {number} y - Value Y.
 * @param {number} z - Value Z.
 * @param {number} w - Value W.
 * @returns {og.math.Vec4}
 */
Vec4.prototype.set = function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
};

/**
 * Adds vector to the current.
 * @public
 * @param {og.math.Vec4}
 * @returns {og.math.Vec4}
 */
Vec4.prototype.addA = function (v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
};

/**
 * Subtract vector from the current.
 * @public
 * @param {og.math.Vec4} v - Subtract vector.
 * @returns {og.math.Vec4}
 */
Vec4.prototype.subA = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
};

/**
 * Scale current vector.
 * @public
 * @param {number} scale - Scale value.
 * @returns {og.math.Vec4}
 */
Vec4.prototype.scale = function (scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    this.w *= scale;
    return this;
};

/**
 * Makes vector affinity. Thereby fourh component becomes to 1.0.
 * @public
 * @returns {og.math.Vec4}
 */
Vec4.prototype.affinity = function () {
    var iw = 1 / this.w;
    this.x *= iw;
    this.y *= iw;
    this.z *= iw;
    this.w = 1.0;
    return this;
};

/**
 * Scale current vector to another instance.
 * @public
 * @param {number} scale - Scale value.
 * @returns {og.math.Vector3}
 */
Vec4.prototype.scaleTo = function (scale) {
    return new Vec4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
};

/**
 * Vector's edge function that returns vector where each component is 0.0 if it's smaller then edge and otherwise 1.0.
 * @public
 * @returns {og.math.Vec4}
 */
Vec4.prototype.getStep = function (edge) {
    return new Vec4(
        this.x < edge ? 0.0 : 1.0,
        this.y < edge ? 0.0 : 1.0,
        this.z < edge ? 0.0 : 1.0,
        this.w < edge ? 0.0 : 1.0
    );
};

/**
 * The vector fract function returns the vector of fractional parts of each value, i.e. x minus floor(x).
 * @public
 * @returns {og.math.Vec4}
 */
Vec4.prototype.getFrac = function (v) {
    return new Vec4(
        og.math.frac(v.x),
        og.math.frac(v.y),
        og.math.frac(v.z),
        og.math.frac(v.w)
    );
};

/**
 * Gets vectors dot production.
 * @public
 * @param {og.math.Vec4} v - Another vector.
 * @returns {number} - Dot product.
 */
Vec4.prototype.dot = function (v) {
    return v.x * this.x + v.y * this.y + v.z * this.z + v.w * this.w;
};



/***/ }),

/***/ "./src/og/math/coder.js":
/*!******************************!*\
  !*** ./src/og/math/coder.js ***!
  \******************************/
/*! exports provided: encodeFloatToRGBA, decodeFloatFromRGBA, doubleToTwoFloats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeFloatToRGBA", function() { return encodeFloatToRGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeFloatFromRGBA", function() { return decodeFloatFromRGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "doubleToTwoFloats", function() { return doubleToTwoFloats; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _Vec4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec4.js */ "./src/og/math/Vec4.js");
/**
 * @module og/math/coder
 */






/**
 * Encode 32 bit float value to the RGBA vector.
 * @function
 * @param {nummer} v - 32 bit float value.
 * @returns {og.math.Vec4} - RGBA vector value.
 */
function encodeFloatToRGBA(v) {
    var enc = new _Vec4_js__WEBPACK_IMPORTED_MODULE_1__["Vec4"](1.0 * v % 1, 255.0 * v % 1, 65025.0 * v % 1, 160581375.0 * v % 1);
    var yzww = new _Vec4_js__WEBPACK_IMPORTED_MODULE_1__["Vec4"](enc.y / 255, enc.z / 255, enc.w / 255, 0);
    return enc.subA(yzww);
};

/**
 * Decode RGBA vector to 32 bit float value.
 * @function
 * @param {og.math.Vector4} rgba - RGBA encoded 32 bit float value.
 * @returns {number} - Float value.
 */
function decodeFloatFromRGBA(rgba) {
    var s = 1.0 - _math_js__WEBPACK_IMPORTED_MODULE_0__["step"](128.0, rgba.x) * 2.0;
    var e = 2.0 * _math_js__WEBPACK_IMPORTED_MODULE_0__["mod"](rgba.x, 128.0) + _math_js__WEBPACK_IMPORTED_MODULE_0__["step"](128.0, rgba.y) - 127.0;
    var m = _math_js__WEBPACK_IMPORTED_MODULE_0__["mod"](rgba.y, 128.0) * 65536.0 + rgba.z * 256.0 + rgba.w + 8388608.00;
    return s * _math_js__WEBPACK_IMPORTED_MODULE_0__["exp2"](e) * (m * 1.1920928955078125e-7);
};

/**
 * Separate 63 bit value to two 32 bit float values.
 * @function
 * @param {number} value - Double type value.
 * @returns {Array.<number,number>} Encoded array.
 */
function doubleToTwoFloats(value) {
    var high, low;
    if (value >= 0.0) {
        var doubleHigh = Math.floor(value / 65536.0) * 65536.0;
        high = Math.fround(doubleHigh);
        low = Math.fround(value - doubleHigh);
    } else {
        var doubleHigh = Math.floor(-value / 65536.0) * 65536.0;
        high = Math.fround(-doubleHigh);
        low = Math.fround(value + doubleHigh);
    }
    return [high, low];
};

/***/ }),

/***/ "./src/og/mercator.js":
/*!****************************!*\
  !*** ./src/og/mercator.js ***!
  \****************************/
/*! exports provided: POLE, POLE_DOUBLE, ONE_BY_POLE_DOUBLE, forward_lon, forward_lat, inverse_lon, inverse_lat, getTileX, getTileY, forwardArray, MAX_LAT, MIN_LAT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLE", function() { return POLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLE_DOUBLE", function() { return POLE_DOUBLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_BY_POLE_DOUBLE", function() { return ONE_BY_POLE_DOUBLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward_lon", function() { return forward_lon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forward_lat", function() { return forward_lat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse_lon", function() { return inverse_lon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse_lat", function() { return inverse_lat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileX", function() { return getTileX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileY", function() { return getTileY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forwardArray", function() { return forwardArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_LAT", function() { return MAX_LAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_LAT", function() { return MIN_LAT; });
/**
 * @module og/mercator
 */



/**
 * Mercator size.
 * @const
 * @type {number}
 */
const POLE = 20037508.34;

/**
 * Double mercator size.
 * @const
 * @type {number}
 */
const POLE_DOUBLE = 2.0 * POLE;

/**
 * One by mercator double size.
 * @const
 * @type {number}
 */
const ONE_BY_POLE_DOUBLE = 1.0 / POLE_DOUBLE;

/**
 * Converts degrees longitude to mercator coordinate.
 * @function
 * @param {number} lon - Degrees geodetic longitude.
 * @returns {number}
 */
function forward_lon(lon) {
    return lon * POLE / 180;
};

/**
 * Converts degrees latitude to mercator coordinate.
 * @function
 * @param {number} lat - Degrees geodetic latitude.
 * @returns {number}
 */
function forward_lat(lat) {
    return Math.log(Math.tan((90 + lat) * Math.PI / 360)) / Math.PI * POLE;
};

/**
 * Converts mercator longitude to degrees coordinate.
 * @function
 * @param {number} lon - Mercator longitude.
 * @returns {number}
 */
function inverse_lon(lon) {
    return 180 * lon / POLE;
};

/**
 * Converts mercator latitude to degrees coordinate.
 * @function
 * @param {number} lon - Mercator latitude.
 * @returns {number}
 */
function inverse_lat(lat) {
    return 180 / Math.PI * (2 * Math.atan(Math.exp((lat / POLE) * Math.PI)) - Math.PI / 2);
};

/**
 * Returns mercator map tile grid horizontal coordinate index by geodetic 
 * longitude and zoom level. Where top left corner of the grid is 0 coordinate index.
 * @function
 * @param {number} lon - Geodetic degrees longitude.
 * @param {number} zoom - Zoom level.
 * @returns {number}
 */
function getTileX(lon, zoom) {
    return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
};

/**
 * Returns mercator map tile grid vertical coordinate index by geodetic 
 * latitude and zoom level. Where top left corner of the grid is 0 coordinate index.
 * @function
 * @param {number} lat - Geodetic degrees latitude.
 * @param {number} zoom - Zoom level.
 * @returns {number}
 */
function getTileY(lat, zoom) {
    return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
};

/**
 * Converts geodetic coordinate array to mercator coordinate array.
 * @function
 * @param {Array.<og.LonLat>} lonLatArr - LonLat array to convert.
 * @returns {Array.<og.LonLat>}
 */
function forwardArray(lonlatArr) {
    var res = [];
    for (var i = 0; i < lonlatArr.length; i++) {
        res.push(lonlatArr[i].forwardMercator());
    }
    return res;
};

/**
 * Max mercator latitude.
 * @const
 * @type {number}
 */
const MAX_LAT = inverse_lat(POLE);

/**
 * Min mercator latitude.
 * @const
 * @type {number}
 */
const MIN_LAT = -MAX_LAT;


/***/ }),

/***/ "./src/og/proj/EPSG3857.js":
/*!*********************************!*\
  !*** ./src/og/proj/EPSG3857.js ***!
  \*********************************/
/*! exports provided: EPSG3857 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSG3857", function() { return EPSG3857; });
/* harmony import */ var _Proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Proj.js */ "./src/og/proj/Proj.js");
/**
 * @module og/proj/EPSG3857
 */





/**
 * EPSG:3857 projection object.
 * @type {og.proj.Projection}
 */
const EPSG3857 = new _Proj_js__WEBPACK_IMPORTED_MODULE_0__["Proj"]({ code: "epsg:3857", units: _Proj_js__WEBPACK_IMPORTED_MODULE_0__["Units"].METERS });

/***/ }),

/***/ "./src/og/proj/EPSG4326.js":
/*!*********************************!*\
  !*** ./src/og/proj/EPSG4326.js ***!
  \*********************************/
/*! exports provided: EPSG4326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSG4326", function() { return EPSG4326; });
/* harmony import */ var _Proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Proj.js */ "./src/og/proj/Proj.js");
/**
 * @module og/proj/EPSG4326
 */





/**
 * EPSG:4326 projection object.
 * @type {og.proj.Proj}
 */
const EPSG4326 = new _Proj_js__WEBPACK_IMPORTED_MODULE_0__["Proj"]({ code: "epsg:4326", units: _Proj_js__WEBPACK_IMPORTED_MODULE_0__["Units"].DEGREES });

/***/ }),

/***/ "./src/og/proj/Proj.js":
/*!*****************************!*\
  !*** ./src/og/proj/Proj.js ***!
  \*****************************/
/*! exports provided: Units, METERS_PER_UNIT, Proj */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Units", function() { return Units; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Proj", function() { return Proj; });
/**
 * @module og/proj/Proj
 */



/**
 * Projection units: 'degrees', 'ft', 'm' or 'km'.
 * @enum {string}
 * @api
 */
const Units = {
    "DEGREES": "degrees",
    "FEET": "ft",
    "METERS": "m",
    "KILOMETERS": "km"
};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<og.proj.Units, number>}
 */
const METERS_PER_UNIT = {};
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.KILOMETERS] = 1000;

const Proj = function (options) {

    /**
     * @public
     * @type {string}
     */
    this.code = options.code;

    /**
     * @public
     * @type {og.proj.Units}
     */
    this.units = /** @type {Units} */ (options.units);

    /**
     * Projection identifier, especially usefull for comparison.
     * @const
     * @type {integer}
     */
    this.id = Proj._counter++;
};

/**
 * Compare projections.
 * @public
 * @param {og.proj.Projection} proj - Projetion object.
 * @returns {boolean}
 */
Proj.prototype.equal = function (proj) {
    return proj.id == this.id;
};

Proj._counter = 0;



/***/ }),

/***/ "./src/og/quadTree/EntityCollectionNode.js":
/*!*************************************************!*\
  !*** ./src/og/quadTree/EntityCollectionNode.js ***!
  \*************************************************/
/*! exports provided: EntityCollectionNode, EntityCollectionNodeWGS84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityCollectionNode", function() { return EntityCollectionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityCollectionNodeWGS84", function() { return EntityCollectionNodeWGS84; });
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _quadTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _bv_Box_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bv/Box.js */ "./src/og/bv/Box.js");
/* harmony import */ var _entity_EntityCollection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../entity/EntityCollection.js */ "./src/og/entity/EntityCollection.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _inherits_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../inherits.js */ "./src/og/inherits.js");
/* harmony import */ var _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../bv/Sphere.js */ "./src/og/bv/Sphere.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/quadTree/EntityCollectionNode
 */













const EntityCollectionNode = function (layer, partId, parent, id, extent, planet, zoom) {
    this.layer = layer;
    this.parentNode = parent;
    this.childrenNodes = [];
    this.partId = partId;
    this.nodeId = partId + id;
    this.state = null;
    this.extent = extent;
    this.count = 0;
    this.deferredEntities = [];
    this.entityCollection = null;
    this.zoom = zoom;
    this._inTheQueue = false;

    this.bsphere = new _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_7__["Sphere"]();

    planet && this._setExtentBounds();
};

EntityCollectionNode.prototype.insertEntity = function (entity, isInside, rightNow) {

    var p = this._setLonLat(entity);

    if (isInside || p && this.extent.isInside(p)) {

        this.count++;

        if (this.count > this.layer._nodeCapacity) {
            var cn = this.childrenNodes;
            if (cn.length) {
                if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].extent.isInside(p)) {
                    cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].insertEntity(entity, true, rightNow);
                } else if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].extent.isInside(p)) {
                    cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].insertEntity(entity, true, rightNow);
                } else if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].extent.isInside(p)) {
                    cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].insertEntity(entity, true, rightNow);
                } else if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].extent.isInside(p)) {
                    cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].insertEntity(entity, true, rightNow);
                }
            } else {
                var entities = this.entityCollection.getEntities();
                entities.push(entity);
                this.entityCollection.events.clear();
                this.entityCollection.clear();
                this.entityCollection = null;
                //this._freeCollection();

                /** Build sub tree with new inserted entity */
                this.buildTree(entities, rightNow);
            }
        } else {
            this._addEntitiesToCollection([entity], rightNow);
        }
    }
};

EntityCollectionNode.prototype._addEntitiesToCollection = function (entities, rightNow) {
    if (entities.length) {
        var l = this.layer,
            p = l._planet,
            ell = p.ellipsoid,
            ext = this.extent;

        var ec = this.entityCollection;

        if (!ec) {
            ec = new _entity_EntityCollection_js__WEBPACK_IMPORTED_MODULE_3__["EntityCollection"]({
                'pickingEnabled': l._pickingEnabled
            });
            ec._layer = this.layer;
            ec.addTo(p, true);
            ec._quadNode = this;
            l._bindEventsDefault(ec);
            this.entityCollection = ec;
        }

        if (rightNow) {
            this.entityCollection.addEntities(entities);
        } else {
            this.deferredEntities.push.apply(this.deferredEntities, entities);
        }
    }
};

EntityCollectionNode.prototype._setExtentBounds = function () {
    if (!this.nodeId) {
        this.bsphere.radius = this.layer._planet.ellipsoid._a;
        this.bsphere.center = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_8__["Vec3"]();
    } else {
        this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent.inverseMercator());
    }
};

EntityCollectionNode.prototype._setLonLat = function (entity) {
    if (!entity._lonlat) {
        entity._lonlat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
    }
    this.layer._fitExtent(entity);
    if (Math.abs(entity._lonlat.lat) < _mercator_js__WEBPACK_IMPORTED_MODULE_0__["MAX_LAT"]) {
        entity._lonlatMerc = entity._lonlat.forwardMercator();
    } else {
        entity._lonlatMerc = null;
    }
    return entity._lonlatMerc;
};

EntityCollectionNode.prototype.buildTree = function (entities, rightNow) {

    this.count = entities.length;

    if (entities.length > this.layer._nodeCapacity ||
        this.zoom < this.layer.minZoom || this.zoom < this.layer._minDepth) {
        var cn = this.childrenNodes;
        if (!cn.length) {
            this.createChildrenNodes();
        }

        var en_nw = [],
            en_ne = [],
            en_sw = [],
            en_se = [];

        var i = entities.length;
        while (i--) {
            var ei = entities[i];
            var p = this._setLonLat(ei);
            if (p) {
                if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].extent.isInside(p)) {
                    ei._nodePtr = cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]];
                    en_nw.push(ei);
                } else if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].extent.isInside(p)) {
                    ei._nodePtr = cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]];
                    en_ne.push(ei);
                } else if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].extent.isInside(p)) {
                    ei._nodePtr = cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]];
                    en_sw.push(ei);
                } else if (cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].extent.isInside(p)) {
                    ei._nodePtr = cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]];
                    en_se.push(ei);
                }
            }
        }

        en_nw.length && cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].buildTree(en_nw, rightNow);
        en_ne.length && cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].buildTree(en_ne, rightNow);
        en_sw.length && cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].buildTree(en_sw, rightNow);
        en_se.length && cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].buildTree(en_se, rightNow);

    } else {
        this._addEntitiesToCollection(entities, rightNow);
    }
};


EntityCollectionNode.prototype.createChildrenNodes = function () {
    var l = this.layer;
    var ext = this.extent;
    var size_x = ext.getWidth() * 0.5;
    var size_y = ext.getHeight() * 0.5;
    var ne = ext.northEast,
        sw = ext.southWest;
    var id = this.nodeId * 4 + 1;
    var c = new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](sw.lon + size_x, sw.lat + size_y);
    var nd = this.childrenNodes;
    var p = this.layer._planet;
    var z = this.zoom + 1;

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]] = new EntityCollectionNode(l, _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"], this, id,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_4__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](sw.lon, sw.lat + size_y), new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](sw.lon + size_x, ne.lat)), p, z);

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]] = new EntityCollectionNode(l, _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"], this, id,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_4__["Extent"](c, new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](ne.lon, ne.lat)), p, z);

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]] = new EntityCollectionNode(l, _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"], this, id,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_4__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](sw.lon, sw.lat), c), p, z);

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]] = new EntityCollectionNode(l, _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"], this, id,
        new oExtent(new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](sw.lon + size_x, sw.lat), new _LonLat_js__WEBPACK_IMPORTED_MODULE_5__["LonLat"](ne.lon, sw.lat + size_y)), p, z);
};

EntityCollectionNode.prototype.collectRenderCollectionsPASS1 = function (visibleNodes, outArr) {
    var p = this.layer._planet;
    var cam = p.renderer.activeCamera;
    var n = visibleNodes[this.nodeId];

    if (n) {
        var cn = this.childrenNodes;
        if (this.entityCollection) {
            this.renderCollection(outArr, visibleNodes);
        } else if (cn.length) {
            if (n.state === _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["RENDERING"]) {
                this.layer._secondPASS.push(this);
            } else {
                cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].collectRenderCollectionsPASS1(visibleNodes, outArr);
                cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].collectRenderCollectionsPASS1(visibleNodes, outArr);
                cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].collectRenderCollectionsPASS1(visibleNodes, outArr);
                cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].collectRenderCollectionsPASS1(visibleNodes, outArr);
            }
        }
    }
};

EntityCollectionNode.prototype.collectRenderCollectionsPASS2 = function (visibleNodes, outArr, renderingNodeId) {
    var p = this.layer._planet;
    var cam = p.renderer.activeCamera;

    var altVis = (cam.eye.distance(this.bsphere.center) - this.bsphere.radius <
        _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["VISIBLE_DISTANCE"] * Math.sqrt(cam._lonLat.height)) || cam._lonLat.height > 10000;

    if (this.count > 0 && altVis &&
        p.renderer.activeCamera.frustum.containsSphere(this.bsphere) > 0) {

        var cn = this.childrenNodes;

        if (this.entityCollection) {
            this.renderCollection(outArr, visibleNodes, renderingNodeId);
        } else if (cn.length) {
            cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
            cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
            cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
            cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].collectRenderCollectionsPASS2(visibleNodes, outArr, renderingNodeId);
        }

    }
};

EntityCollectionNode.prototype.applyCollection = function () {
    this.entityCollection.addEntities(this.deferredEntities);
    this.deferredEntities.length = 0;
    this.deferredEntities = [];
    this._inTheQueue = false;
};

EntityCollectionNode.prototype.traverseTree = function (callback) {

    var cn = this.childrenNodes;

    if (this.entityCollection) {
        callback(this);
    } else if (cn.length) {
        cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NW"]].traverseTree(callback);
        cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["NE"]].traverseTree(callback);
        cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SW"]].traverseTree(callback);
        cn[_quadTree_js__WEBPACK_IMPORTED_MODULE_1__["SE"]].traverseTree(callback);
    }
};

EntityCollectionNode.prototype.renderCollection = function (outArr, visibleNodes, renderingNodeId) {

    var l = this.layer;

    l._renderingNodes[this.nodeId] = true;

    if (this.deferredEntities.length && !this._inTheQueue) {
        if (l.async) {
            l._queueDeferredNode(this);
        } else {
            this.applyCollection();
        }
    }

    var ec = this.entityCollection;
    ec._animatedOpacity = l.opacity;
    ec.scaleByDistance = l.scaleByDistance;
    outArr.push(this.entityCollection);

    if (l.clampToGround || l.relativeToGround) {
        var e = ec._entities;
        var i = e.length;

        if (visibleNodes[this.nodeId] && visibleNodes[this.nodeId].state === _quadTree_js__WEBPACK_IMPORTED_MODULE_1__["RENDERING"]) {
            while (i--) {
                var ei = e[i];
                this.alignEntityToTheGround(ei, visibleNodes[this.nodeId].segment);
            }
        } else if (renderingNodeId) {
            while (i--) {
                var ei = e[i];
                this.alignEntityToTheGround(ei, visibleNodes[renderingNodeId].segment);
            }
        } else {
            var n = l._planet._renderedNodes;
            while (i--) {
                var ei = e[i];
                var j = n.length;
                while (j--) {
                    if (n[j].segment.isEntityInside(ei)) {
                        this.alignEntityToTheGround(ei, n[j].segment);
                        break;
                    }
                }
            }
        }
    }
};

EntityCollectionNode.prototype.alignEntityToTheGround = function (entity, segment) {
    segment.getEntityTerrainPoint(entity, entity._cartesian);
    entity._setCartesian3vSilent(entity._cartesian.addA(entity._cartesian.normal().scale(this.layer.relativeToGround && entity._altitude || 0.1)));
};

EntityCollectionNode.prototype.isVisible = function () {
    if (this.layer._renderingNodes[this.nodeId]) {
        return true;
    }
    return false;
};

/**
 * Node of entity collections for WGS84 coordinates.
 * @param {any} layer
 * @param {any} partId
 * @param {any} parent
 * @param {any} id
 * @param {any} extent
 * @param {any} planet
 * @param {any} zoom
 */
const EntityCollectionNodeWGS84 = function (layer, partId, parent, id, extent, planet, zoom) {
    EntityCollectionNode.call(this, layer, partId, parent, id, extent, planet, zoom);
    this.isNorth = false;
};

Object(_inherits_js__WEBPACK_IMPORTED_MODULE_6__["inherits"])(EntityCollectionNodeWGS84, EntityCollectionNode);

EntityCollectionNodeWGS84.prototype._setExtentBounds = function () {
    if (this.extent.northEast.lat > 0) {
        this.isNorth = true;
    }
    this.bsphere.setFromExtent(this.layer._planet.ellipsoid, this.extent);
};

EntityCollectionNodeWGS84.prototype._setLonLat = function (entity) {
    if (!entity._lonlat) {
        entity._lonlat = this.layer._planet.ellipsoid.cartesianToLonLat(entity._cartesian);
    }
    return entity._lonlat;
};

EntityCollectionNodeWGS84.prototype.isVisible = function () {
    if (this.isNorth && this.layer._renderingNodesNorth[this.nodeId]) {
        return true;
    } else if (this.layer._renderingNodesSouth[this.nodeId]) {
        return true;
    }
    return false;
};

EntityCollectionNodeWGS84.prototype.renderCollection = function (outArr, visibleNodes, renderingNode) {

    if (this.isNorth) {
        this.layer._renderingNodesNorth[this.nodeId] = true;
    } else {
        this.layer._renderingNodesSouth[this.nodeId] = true;
    }

    if (this.deferredEntities.length && !this._inTheQueue) {
        if (this.layer.async) {
            this.layer._queueDeferredNode(this);
        } else {
            this.applyCollection();
        }
    }

    this.entityCollection._animatedOpacity = this.layer.opacity;
    this.entityCollection.scaleByDistance = this.layer.scaleByDistance;
    outArr.push(this.entityCollection);
};



/***/ }),

/***/ "./src/og/quadTree/Node.js":
/*!*********************************!*\
  !*** ./src/og/quadTree/Node.js ***!
  \*********************************/
/*! exports provided: Node */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _quadTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _proj_EPSG4326_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj/EPSG4326.js */ "./src/og/proj/EPSG4326.js");
/* harmony import */ var _proj_EPSG3857_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj/EPSG3857.js */ "./src/og/proj/EPSG3857.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/quadTree/Node
 */













/**
 * Returns triangle coordinate array from inside of the source triangle array.
 * @static
 * @param {Array.<number>} sourceArr - Source array
 * @param {number} gridSize - Source array square matrix size
 * @param {number} i0 - First row index source array matrix
 * @param {number} j0 - First column index
 * @param {number} size - Square matrix result size.
 * @return{Array.<number>} Triangle coordinates array from the source array.
 */
function getMatrixSubArray(sourceArr, gridSize, i0, j0, size) {
    var res = new Float32Array((i0 + size + 1) * (j0 + size + 1) * 3);
    var vInd = 0;
    for (var i = i0; i <= i0 + size; i++) {
        for (var j = j0; j <= j0 + size; j++) {
            var ind = 3 * (i * (gridSize + 1) + j);
            res[vInd++] = sourceArr[ind];
            res[vInd++] = sourceArr[ind + 1];
            res[vInd++] = sourceArr[ind + 2];
        }
    }
    return res;
};

/**
 * Quad tree planet segment node.
 * @constructor
 * @param {og.planetSegment.Segment|og.planetSegment.SegmentLonLat} segmentPrototype - Planet segment node constructor.
 * @param {og.scene.RenderNode} planet - Planet render node.
 * @param {number} partId - NorthEast, SouthWest etc.
 * @param {og.quadTree.Node} parent - Parent of this node.
 * @param {number} id - Tree node identifier (id * 4 + 1);
 * @param {number} tileZoom - Deep index of the quad tree.
 * @param {og.Extent} extent - Planet segment extent.
 */
const Node = function (segmentPrototype, planet, partId, parent, id, tileZoom, extent) {
    this.planet = planet;
    this.parentNode = parent;
    this.nodes = [];
    this.partId = partId;
    this.nodeId = partId + id;
    this.state = null;
    this.appliedTerrainNodeId = -1;
    this.sideSize = [1, 1, 1, 1];
    this.hasNeighbor = [false, false, false, false];
    this.neighbors = [null, null, null, null];
    this.SegmentPrototype = segmentPrototype;
    this.segment = new segmentPrototype(this, planet, tileZoom, extent);

    /**
     * @private
     */
    this._cameraInside = false;
    this.createBounds();
    this.planet._createdNodesCount++;
};

const _vertOrder = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }];
const _neGridSize = Math.sqrt(_vertOrder.length) - 1;

Node.prototype.createChildrenNodes = function () {
    var p = this.planet;
    var ps = this.segment;
    var ext = ps._extent;
    var size_x = ext.getWidth() * 0.5;
    var size_y = ext.getHeight() * 0.5;
    var ne = ext.northEast, sw = ext.southWest;
    var z = ps.tileZoom + 1;
    var id = this.nodeId * 4 + 1;
    var c = new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](sw.lon + size_x, sw.lat + size_y);
    var nd = this.nodes;

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NW"]] = new Node(this.SegmentPrototype, p, _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NW"], this, id, z,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](sw.lon, sw.lat + size_y), new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](sw.lon + size_x, ne.lat)));

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NE"]] = new Node(this.SegmentPrototype, p, _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NE"], this, id, z,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](c, new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](ne.lon, ne.lat)));

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["SW"]] = new Node(this.SegmentPrototype, p, _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["SW"], this, id, z,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](sw.lon, sw.lat), c));

    nd[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["SE"]] = new Node(this.SegmentPrototype, p, _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["SE"], this, id, z,
        new _Extent_js__WEBPACK_IMPORTED_MODULE_3__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](sw.lon + size_x, sw.lat), new _LonLat_js__WEBPACK_IMPORTED_MODULE_4__["LonLat"](ne.lon, sw.lat + size_y)));
};

Node.prototype.createBounds = function () {

    var seg = this.segment;

    if (!seg.tileZoom) {
        seg.bsphere.radius = seg.planet.ellipsoid._a;
        seg.bsphere.center = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"]();
    } else if (seg.tileZoom < seg.planet.terrain.minZoom) {
        seg.createBoundsByExtent();
    } else {
        var pn = this;

        while (pn.parentNode && !pn.segment.terrainReady) {
            pn = pn.parentNode;
        }

        var scale = this.segment.tileZoom - pn.segment.tileZoom;

        var dZ2 = Math.pow(2, scale);

        var offsetX = this.segment.tileX - pn.segment.tileX * dZ2,
            offsetY = this.segment.tileY - pn.segment.tileY * dZ2;

        if (pn.segment.terrainReady) {
            var gridSize = pn.segment.gridSize / Math.pow(2, scale);
            if (gridSize >= 1) {
                var pVerts = pn.segment.terrainVertices;
                var i0 = gridSize * offsetY;
                var j0 = gridSize * offsetX;
                var ind1 = 3 * (i0 * (pn.segment.gridSize + 1) + j0);
                var ind2 = 3 * ((i0 + gridSize) * (pn.segment.gridSize + 1) + j0 + gridSize);
                seg.bsphere.setFromBounds([pVerts[ind1], pVerts[ind2], pVerts[ind1 + 1], pVerts[ind2 + 1], pVerts[ind1 + 2], pVerts[ind2 + 2]]);
            } else {
                var pseg = pn.segment;

                var i0 = Math.floor(gridSize * offsetY);
                var j0 = Math.floor(gridSize * offsetX);

                var insideSize = 1 / gridSize;
                var fullSize = insideSize * pseg.gridSize;

                var t_i0 = offsetY - insideSize * i0,
                    t_j0 = offsetX - insideSize * j0;

                var bigOne = getMatrixSubArray(pseg.terrainVertices, pseg.gridSize, i0, j0, 1);

                var v_lt = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[0], bigOne[1], bigOne[2]),
                    v_rb = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[9], bigOne[10], bigOne[11]);

                var vn = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]),
                    vw = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]),
                    ve = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[3] - bigOne[9], bigOne[4] - bigOne[10], bigOne[5] - bigOne[11]),
                    vs = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[6] - bigOne[9], bigOne[7] - bigOne[10], bigOne[8] - bigOne[11]);

                var vi_y = t_i0,
                    vi_x = t_j0;

                var coords_lt, coords_rb;

                if (vi_y + vi_x < insideSize) {
                    coords_lt = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"].add(vn.scaleTo(vi_x / insideSize), vw.scaleTo(vi_y / insideSize)).addA(v_lt);
                } else {
                    coords_lt = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"].add(vs.scaleTo(1 - vi_x / insideSize), ve.scaleTo(1 - vi_y / insideSize)).addA(v_rb);
                }

                vi_y = t_i0 + 1,
                    vi_x = t_j0 + 1;

                if (vi_y + vi_x < insideSize) {
                    coords_rb = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"].add(vn.scaleTo(vi_x / insideSize), vw.scaleTo(vi_y / insideSize)).addA(v_lt);
                } else {
                    coords_rb = _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"].add(vs.scaleTo(1 - vi_x / insideSize), ve.scaleTo(1 - vi_y / insideSize)).addA(v_rb);
                }

                seg.bsphere.radius = coords_lt.distance(coords_rb) * 0.5;
                seg.bsphere.center = coords_lt.addA(coords_rb.subA(coords_lt).scale(0.5));
            }
        } else {
            seg.createBoundsByExtent();
        }
    }
};

Node.prototype.getState = function () {
    //return this.segment.getNodeState();
    var pn = this.parentNode;
    while (pn) {
        if (pn.state !== _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["WALKTHROUGH"]) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];
        }
        pn = pn.parentNode;
    }
    return this.state;
};

/**
 * Returns the same deep existent neighbour node.
 * @public
 * @param {Number} side - Neighbour side index e.g. og.quadTree.N, og.quadTree.W etc.
 * @returns {og.quadTree.Node} -
 */
Node.prototype.getEqualNeighbor = function (side) {
    var pn = this;
    var part = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NEIGHBOUR"][side][pn.partId];
    if (part !== -1) {
        return pn.parentNode.nodes[part];
    } else {
        var pathId = [];
        while (pn.parentNode) {
            pathId.push(pn.partId);
            part = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NEIGHBOUR"][side][pn.partId];
            pn = pn.parentNode;
            if (part !== -1) {
                var i = pathId.length;
                side = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][side];
                while (pn && i--) {
                    part = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPPART"][side][pathId[i]];
                    pn = pn.nodes[part];
                }
                return pn;
            }
        }
    }
};

Node.prototype.prepareForRendering = function (height, altVis, onlyTerrain) {
    if (height < 3000000.0) {
        if (altVis) {
            this.renderNode(onlyTerrain);
        } else {
            this.state = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];
        }
    } else {
        this.renderNode(onlyTerrain);
    }
};

Node.prototype.traverseNodes = function (maxZoom) {
    if (!this.nodes.length) {
        this.createChildrenNodes();
    }
    this.nodes[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NW"]].renderTree(maxZoom);
    this.nodes[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NE"]].renderTree(maxZoom);
    this.nodes[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["SW"]].renderTree(maxZoom);
    this.nodes[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["SE"]].renderTree(maxZoom);
};

Node.prototype.isBrother = function (node) {
    return !(this.parentNode || node.parentNode) ||
        this.parentNode.id === node.parentNode.id;
};

Node.prototype.renderTree = function (maxZoom) {
    this.state = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["WALKTHROUGH"];

    this.neighbors[0] = null;
    this.neighbors[1] = null;
    this.neighbors[2] = null;
    this.neighbors[3] = null;

    var cam = this.planet.renderer.activeCamera,
        seg = this.segment,
        planet = this.planet;


    if (this.parentNode) {

        this._cameraInside = false;

        //Search a node which the camera is flying over.
        if (this.parentNode._cameraInside) {
            var inside;
            if (Math.abs(cam._lonLat.lat) <= _mercator_js__WEBPACK_IMPORTED_MODULE_0__["MAX_LAT"] &&
                seg._projection.id === _proj_EPSG3857_js__WEBPACK_IMPORTED_MODULE_6__["EPSG3857"].id) {
                inside = seg._extent.isInside(cam._lonLatMerc);
                cam._insideSegmentPosition = cam._lonLatMerc;
            } else if (seg._projection.id === _proj_EPSG4326_js__WEBPACK_IMPORTED_MODULE_5__["EPSG4326"].id) {
                inside = seg._extent.isInside(cam._lonLat);
                cam._insideSegmentPosition = cam._lonLat;
            }

            if (inside) {
                cam._insideSegment = seg;
                this._cameraInside = true;
            }
        }
    } else {
        this._cameraInside = true;
    }

    var inFrustum = cam.frustum.containsSphere(seg.bsphere),
        underBottom = false;

    var h = cam._lonLat.height;

    // if (h < 10000.0) {
    //     underBottom = true;
    // }

    var onlyTerrain = !inFrustum && underBottom;

    var altVis = cam.eye.distance(seg.bsphere.center) - seg.bsphere.radius <
        _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["VISIBLE_DISTANCE"] * Math.sqrt(h);

    if (inFrustum || onlyTerrain || this._cameraInside) {
        if (seg.tileZoom < 2 && seg.normalMapReady) {
            this.traverseNodes(maxZoom);
        } else if (seg.tileZoom === maxZoom || !maxZoom && seg.acceptForRendering(cam)) {
            this.prepareForRendering(h, altVis, onlyTerrain);
        } else {
            if (seg.tileZoom < planet.terrain.gridSizeByZoom.length - 1) {
                this.traverseNodes(maxZoom);
            } else {
                this.prepareForRendering(h, altVis, onlyTerrain);
            }
        }
    } else {
        this.state = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];
    }

    if (inFrustum && (altVis || h > 10000.0)) {
        seg._collectRenderNodes();
    }
};

/**
 * When a node is visible in frustum than begins to render it.
 * @public
 * @param {Boolean} onlyTerrain - It means that loads only terrain for this node.
 */
Node.prototype.renderNode = function (onlyTerrain) {

    this.state = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];

    var seg = this.segment;

    //Create and load terrain data.
    if (!seg.terrainReady) {
        //if true proceed to load
        if (this.whileTerrainLoading()) {
            seg.loadTerrain();
        }
    }

    if (onlyTerrain) {
        return;
    }

    this.state = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["RENDERING"];

    //Create normal map texture.
    if (seg.planet.lightEnabled && !seg.normalMapReady && !seg.parentNormalMapReady) {
        this.whileNormalMapCreating();
    }

    //Calculate minimal and maximal zoom index on the screen
    if (!this._cameraInside && seg.tileZoom > this.planet.maxCurrZoom) {
        this.planet.maxCurrZoom = seg.tileZoom;
    }

    if (seg.tileZoom < this.planet.minCurrZoom) {
        this.planet.minCurrZoom = seg.tileZoom;
    }

    seg._addViewExtent();

    //Finally this node proceed to rendering.
    this.addToRender();
};

/**
 * Seraching for neighbours and pickup current node to render processing.
 * @public
 */
Node.prototype.addToRender = function () {
    var node = this;
    var nodes = node.planet._renderedNodes;
    for (var i = 0; i < nodes.length; i++) {
        var ni = nodes[i];
        var cs = node.getCommonSide(ni);
        if (cs !== -1) {
            var opcs = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][cs];

            node.neighbors[cs] = ni;
            ni.neighbors[opcs] = node;

            if (!(node.hasNeighbor[cs] && ni.hasNeighbor[opcs])) {
                var ap = node.segment;
                var bp = ni.segment;
                var ld = ap.gridSize / (bp.gridSize * Math.pow(2, bp.tileZoom - ap.tileZoom));

                node.hasNeighbor[cs] = true;
                ni.hasNeighbor[opcs] = true;

                if (ld > 1) {
                    node.sideSize[cs] = Math.ceil(ap.gridSize / ld);
                    ni.sideSize[opcs] = bp.gridSize;
                }
                else if (ld < 1) {
                    node.sideSize[cs] = ap.gridSize;
                    ni.sideSize[opcs] = Math.ceil(bp.gridSize * ld);
                } else {
                    node.sideSize[cs] = ap.gridSize;
                    ni.sideSize[opcs] = bp.gridSize;
                }
            }
        }
    }
    nodes.push(node);
};

Node.prototype.getCommonSide = function (node) {
    var a = this.segment._extent,
        b = node.segment._extent;
    var a_ne = a.northEast, a_sw = a.southWest,
        b_ne = b.northEast, b_sw = b.southWest;
    var a_ne_lon = a_ne.lon, a_ne_lat = a_ne.lat, a_sw_lon = a_sw.lon, a_sw_lat = a_sw.lat,
        b_ne_lon = b_ne.lon, b_ne_lat = b_ne.lat, b_sw_lon = b_sw.lon, b_sw_lat = b_sw.lat;

    var POLE = _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"],
        MAX_LAT = _mercator_js__WEBPACK_IMPORTED_MODULE_0__["MAX_LAT"];

    if (a_ne_lat <= b_ne_lat && a_sw_lat >= b_sw_lat || a_ne_lat >= b_ne_lat && a_sw_lat <= b_sw_lat) {
        if (a_ne_lon === b_sw_lon) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"];
        } else if (a_sw_lon === b_ne_lon) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["W"];
        } else if (this.segment.tileZoom > 0) {
            if (a_ne_lon === POLE && b_sw_lon === -POLE) {
                return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"];
            } else if (a_sw_lon === -POLE && b_ne_lon === POLE) {
                return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"];
            } else if (a_sw_lon === -POLE && b_ne_lon === POLE) {
                return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["W"];
            }
        }
    } else if (a_sw_lon >= b_sw_lon && a_ne_lon <= b_ne_lon || a_sw_lon <= b_sw_lon && a_ne_lon >= b_ne_lon) {
        if (a_ne_lat === b_sw_lat) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["N"];
        } else if (a_sw_lat === b_ne_lat) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["S"];
        } else if (a_ne_lat === POLE && b_sw_lat === MAX_LAT) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["N"];
        } else if (a_sw_lat === -POLE && b_ne_lat === -MAX_LAT) {
            return _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["S"];
        }
    }

    return -1;
};

Node.prototype.whileNormalMapCreating = function () {

    var seg = this.segment;
    var maxZ = this.planet.terrain.maxZoom;

    if (seg.tileZoom <= maxZ && !seg.terrainIsLoading && seg.terrainReady && !seg._inTheQueue) {
        seg.planet._normalMapCreator.queue(seg);
    }

    var pn = this;

    while (pn.parentNode && !pn.segment.normalMapReady) {
        pn = pn.parentNode;
    }

    var dZ2 = 2 << (seg.tileZoom - pn.segment.tileZoom - 1);

    seg.normalMapTexture = pn.segment.normalMapTexture;
    seg.normalMapTextureBias[0] = seg.tileX - pn.segment.tileX * dZ2;
    seg.normalMapTextureBias[1] = seg.tileY - pn.segment.tileY * dZ2;
    seg.normalMapTextureBias[2] = 1 / dZ2;


    if (seg.tileZoom > maxZ) {
        if (pn.segment.tileZoom === maxZ) {
            seg.parentNormalMapReady = true;
        } else {
            pn = this;
            while (pn.parentNode && pn.segment.tileZoom !== maxZ) {
                pn = pn.parentNode;
            }
            var pns = pn.segment;
            if (!pns.ready) {
                pns.createPlainSegment();
                pns.loadTerrain();
            } else if (!pns._inTheQueue && !pns.terrainIsLoading) {
                pns.planet._normalMapCreator.queue(pns);
            }
        }
    }
};

Node.prototype.whileTerrainLoading = function () {

    var seg = this.segment;

    //Looking for terrain nodes under
    var n = this.nodes;

    //Maybe better is to replace this code to the Segment module?
    if (seg.tileZoom >= this.planet.terrain.minZoom &&
        seg.tileZoom < this.planet.terrain.maxZoom &&
        n.length === 4 && n[0].segment.terrainReady && n[1].segment.terrainReady &&
        n[2].segment.terrainReady && n[3].segment.terrainReady
    ) {
        var xmin = _math_js__WEBPACK_IMPORTED_MODULE_1__["MAX"], xmax = _math_js__WEBPACK_IMPORTED_MODULE_1__["MIN"], ymin = _math_js__WEBPACK_IMPORTED_MODULE_1__["MAX"],
            ymax = _math_js__WEBPACK_IMPORTED_MODULE_1__["MIN"], zmin = _math_js__WEBPACK_IMPORTED_MODULE_1__["MAX"], zmax = _math_js__WEBPACK_IMPORTED_MODULE_1__["MIN"];

        seg.initializePlainSegment();

        var fgs = this.planet.terrain.fileGridSize;
        var dg = Math.max(fgs / seg.gridSize, 1),
            gs = Math.max(fgs, seg.gridSize) + 1;
        var ind = 0,
            nmInd = 0;

        var gs3 = gs * gs * 3,
            sgs3 = (seg.gridSize + 1) * (seg.gridSize + 1) * 3;

        var hgsOne = 0.5 * (gs - 1) + 1;

        seg.terrainVertices && (seg.terrainVertices = null);
        seg.normalMapNormals && (seg.normalMapNormals = null);
        seg.normalMapVertices && (seg.normalMapVertices = null);

        seg.terrainVertices = new Float32Array(sgs3);
        seg.normalMapVertices = new Float32Array(gs3);
        seg.normalMapNormals = new Float32Array(gs3);

        var verts = seg.terrainVertices,
            nmVerts = seg.normalMapVertices,
            nmNorms = seg.normalMapNormals;

        for (var i = 0; i < gs; i++) {

            var ni = Math.floor(i / hgsOne),
                ii = i % hgsOne + ni;

            for (var j = 0; j < gs; j++) {

                var nj = Math.floor(j / hgsOne);
                var n = this.nodes[2 * ni + nj];

                var nii = ii * 2,
                    njj = (j % hgsOne + nj) * 2;

                var n_index = 3 * (nii * gs + njj);

                var n_nmVerts = n.segment.normalMapVertices,
                    n_nmNorms = n.segment.normalMapNormals;

                var x = n_nmVerts[n_index],
                    y = n_nmVerts[n_index + 1],
                    z = n_nmVerts[n_index + 2];

                nmVerts[nmInd] = x;
                nmNorms[nmInd++] = n_nmNorms[n_index];

                nmVerts[nmInd] = y;
                nmNorms[nmInd++] = n_nmNorms[n_index + 1];

                nmVerts[nmInd] = z;
                nmNorms[nmInd++] = n_nmNorms[n_index + 2];

                if (i % dg === 0 && j % dg === 0) {
                    verts[ind++] = x;
                    verts[ind++] = y;
                    verts[ind++] = z;

                    if (x < xmin) xmin = x; if (x > xmax) xmax = x;
                    if (y < ymin) ymin = y; if (y > ymax) ymax = y;
                    if (z < zmin) zmin = z; if (z > zmax) zmax = z;
                }
            }
        }

        if (seg.planet.lightEnabled) {
            //seg.createNormalMapTexture();
            this.planet._normalMapCreator.unshift(seg);
        }

        seg.createCoordsBuffers(seg.terrainVertices, seg.gridSize);
        seg.bsphere.setFromBounds([xmin, xmax, ymin, ymax, zmin, zmax]);

        this.appliedTerrainNodeId = this.nodeId;
        seg.terrainReady = true;
        seg.terrainExists = true;
        seg.terrainIsLoading = false;

        seg.ready = true;

        var e = seg._extent;
        seg._globalTextureCoordinates[0] = (e.southWest.lon + _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"]) * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["ONE_BY_POLE_DOUBLE"];
        seg._globalTextureCoordinates[1] = (_mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"] - e.northEast.lat) * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["ONE_BY_POLE_DOUBLE"];
        seg._globalTextureCoordinates[2] = (e.northEast.lon + _mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"]) * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["ONE_BY_POLE_DOUBLE"];
        seg._globalTextureCoordinates[3] = (_mercator_js__WEBPACK_IMPORTED_MODULE_0__["POLE"] - e.southWest.lat) * _mercator_js__WEBPACK_IMPORTED_MODULE_0__["ONE_BY_POLE_DOUBLE"];

        return false;
    }


    //Looking for ready terrain above

    if (!seg.ready) {
        seg.createPlainSegment();
    }

    var pn = this;

    while (pn.parentNode && !pn.segment.terrainReady) {
        pn = pn.parentNode;
    }

    if (pn.segment.terrainReady) {

        var dZ2 = 2 << (seg.tileZoom - pn.segment.tileZoom - 1);
        var offsetX = seg.tileX - pn.segment.tileX * dZ2,
            offsetY = seg.tileY - pn.segment.tileY * dZ2;

        var pseg = pn.segment;

        if (pn.segment.terrainExists && this.appliedTerrainNodeId !== pn.nodeId) {

            var gridSize = pn.segment.gridSize / dZ2;
            var tempVertices;

            var fgs = this.planet.terrain.fileGridSize,
                fgsZ = fgs / dZ2;
            var tempNormalMapNormals;

            seg.deleteBuffers();
            seg.refreshIndexesBuffer = true;

            if (gridSize >= 1) {
                seg.gridSize = gridSize;
                this.sideSize = [gridSize, gridSize, gridSize, gridSize];

                tempVertices = getMatrixSubArray(pseg.terrainVertices,
                    pseg.gridSize, gridSize * offsetY, gridSize * offsetX, gridSize);

                tempNormalMapNormals = getMatrixSubArray(pseg.normalMapNormals,
                    fgs, fgsZ * offsetY, fgsZ * offsetX, fgsZ);
            } else {
                seg.gridSize = _neGridSize;
                this.sideSize = [seg.gridSize, seg.gridSize, seg.gridSize, seg.gridSize];

                var i0 = Math.floor(gridSize * offsetY);
                var j0 = Math.floor(gridSize * offsetX);

                var bigOne = getMatrixSubArray(pseg.terrainVertices, pseg.gridSize, i0, j0, 1);

                var insideSize = 1.0 / gridSize;

                var t_i0 = offsetY - insideSize * i0,
                    t_j0 = offsetX - insideSize * j0;

                var v_lt = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[0], bigOne[1], bigOne[2]),
                    v_rb = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[9], bigOne[10], bigOne[11]);

                var vn = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[3] - bigOne[0], bigOne[4] - bigOne[1], bigOne[5] - bigOne[2]),
                    vw = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[6] - bigOne[0], bigOne[7] - bigOne[1], bigOne[8] - bigOne[2]),
                    ve = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[3] - bigOne[9], bigOne[4] - bigOne[10], bigOne[5] - bigOne[11]),
                    vs = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"](bigOne[6] - bigOne[9], bigOne[7] - bigOne[10], bigOne[8] - bigOne[11]);

                var coords = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_7__["Vec3"]();
                var vo = _vertOrder;

                tempVertices = new Float32Array(3 * vo.length);

                for (var i = 0; i < vo.length; i++) {
                    var vi_y = vo[i].y + t_i0,
                        vi_x = vo[i].x + t_j0;

                    var vi_x_is = vi_x * gridSize,
                        vi_y_is = vi_y * gridSize;

                    if (vi_y + vi_x < insideSize) {
                        coords = vn.scaleTo(vi_x_is).addA(vw.scaleTo(vi_y_is)).addA(v_lt);
                    } else {
                        coords = vs.scaleTo(1 - vi_x_is).addA(ve.scaleTo(1 - vi_y_is)).addA(v_rb);
                    }

                    var i3 = i * 3;

                    tempVertices[i3] = coords.x;
                    tempVertices[i3 + 1] = coords.y;
                    tempVertices[i3 + 2] = coords.z;
                }
            }

            seg.createCoordsBuffers(tempVertices, seg.gridSize);

            //seg.tempVertices is useful for earth point calculation(see segment object)
            seg.tempVertices = tempVertices;
            this.appliedTerrainNodeId = pn.nodeId;
        }

        var maxZ = this.planet.terrain.maxZoom;

        if (seg.tileZoom > maxZ) {
            if (pn.segment.tileZoom >= maxZ) {
                seg.terrainReady = true;
                seg.terrainIsLoading = false;
                this.appliedTerrainNodeId = this.nodeId;
                if (pn.segment.terrainExists) {
                    seg.terrainExists = true;
                    seg.terrainVertices = tempVertices;
                    seg.normalMapNormals = tempNormalMapNormals;
                }
            } else {
                pn = this;
                while (pn.parentNode && pn.segment.tileZoom !== maxZ) {
                    pn = pn.parentNode;
                }
                var pns = pn.segment;
                if (!pns.ready) {
                    pns.createPlainSegment();
                }
                pns.loadTerrain();
            }
        }
    }

    return true;
};

Node.prototype.clearTree = function () {

    var state = this.getState();

    if (state === _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"]) {
        this.destroyBranches(true);
    } else if (state === _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["RENDERING"]) {
        this.destroyBranches(false);
    } else {
        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].clearTree();
        }
    }
};

Node.prototype.destroy = function () {
    this.state = _quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];
    this.segment.destroySegment();
    var n = this.neighbors;
    n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["N"]] && n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["N"]].neighbors && (n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["N"]].neighbors[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["S"]] = null);
    n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"]] && n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"]].neighbors && (n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"]].neighbors[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["W"]] = null);
    n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["S"]] && n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["S"]].neighbors && (n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["S"]].neighbors[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["N"]] = null);
    n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["W"]] && n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["W"]].neighbors && (n[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["W"]].neighbors[_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["E"]] = null);
    this.neighbors = null;
    this.hasNeighbors = null;
    this.parentNode = null;
    this.sideSize = null;
    this.segment = null;
};

Node.prototype.destroyBranches = function (cls) {

    var nodesToRemove = [],
        i;

    for (i = 0; i < this.nodes.length; i++) {
        nodesToRemove[i] = this.nodes[i];
    }

    this.nodes.neighbors = [null, null, null, null];
    this.nodes.length = 0;
    this.nodes = [];

    for (i = 0; i < nodesToRemove.length; i++) {
        nodesToRemove[i].destroyBranches(false);
        nodesToRemove[i].destroy();
        nodesToRemove[i] = null;
    }
    nodesToRemove.length = 0;
    nodesToRemove = null;
};

Node.prototype.traverseTree = function (callback) {
    callback(this);
    for (var i = 0; i < this.nodes.length; i++) {
        this.nodes[i].traverseTree(callback);
    }
};



/***/ }),

/***/ "./src/og/quadTree/quadTree.js":
/*!*************************************!*\
  !*** ./src/og/quadTree/quadTree.js ***!
  \*************************************/
/*! exports provided: VISIBLE_DISTANCE, NW, NE, SW, SE, N, E, S, W, NOTRENDERING, RENDERING, WALKTHROUGH, OPSIDE, NEIGHBOUR, OPPART, NOPSORD */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VISIBLE_DISTANCE", function() { return VISIBLE_DISTANCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NW", function() { return NW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NE", function() { return NE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SW", function() { return SW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SE", function() { return SE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return N; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return W; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NOTRENDERING", function() { return NOTRENDERING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RENDERING", function() { return RENDERING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WALKTHROUGH", function() { return WALKTHROUGH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OPSIDE", function() { return OPSIDE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEIGHBOUR", function() { return NEIGHBOUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OPPART", function() { return OPPART; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NOPSORD", function() { return NOPSORD; });
/**
 * @module og/quadTree/quadTree
 */



const VISIBLE_DISTANCE = 3570;

const NW = 0;
const NE = 1;
const SW = 2;
const SE = 3;

const N = 0;
const E = 1;
const S = 2;
const W = 3;

const NOTRENDERING = 0;
const RENDERING = 1;
const WALKTHROUGH = 2;

/**
 * World opposite side table.
 */
const OPSIDE = [S, W, N, E];

const NEIGHBOUR =
    [[-1, -1, NW, NE],
    [NE, -1, SE, -1],
    [SW, SE, -1, -1],
    [-1, NW, -1, SW]];

/**
 * Neighbor's oposite part. For example oposite side
 * on the east neighbor side is: [S][SE] = NE
 */
const OPPART = [[SW, SE, NW, NE],
[NE, NW, SE, SW],
[SW, SE, NW, NE],
[NE, NW, SE, SW]];

/**
 * Neighbos's opside array order. For example NW node
 * by E side array index is 0, SE node by S side is 1.
 */
const NOPSORD = [[0, 1, 0, 1],
[0, 0, 1, 1],
[0, 1, 0, 1],
[0, 0, 1, 1]];


/***/ }),

/***/ "./src/og/renderer/Renderer.js":
/*!*************************************!*\
  !*** ./src/og/renderer/Renderer.js ***!
  \*************************************/
/*! exports provided: Renderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderer", function() { return Renderer; });
/* harmony import */ var _camera_Camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../camera/Camera.js */ "./src/og/camera/Camera.js");
/* harmony import */ var _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Framebuffer.js */ "./src/og/webgl/Framebuffer.js");
/* harmony import */ var _webgl_MultiFramebuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/MultiFramebuffer.js */ "./src/og/webgl/MultiFramebuffer.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _RendererEvents_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RendererEvents.js */ "./src/og/renderer/RendererEvents.js");
/* harmony import */ var _math_Vec2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vec2.js */ "./src/og/math/Vec2.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _cons_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cons.js */ "./src/og/cons.js");
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/* harmony import */ var _input_input_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../input/input.js */ "./src/og/input/input.js");
/**
 * @module og/renderer/Renderer
 */















/**
 * Represents high level WebGL context interface that starts WebGL handler works real time.
 * @class
 * @param {og.webgl.Handler} handler - WebGL handler context.
 * @param {Object} [params] - Renderer parameters:
 * @fires og.RendererEvents#draw
 * @fires og.RendererEvents#resize
 * @fires og.RendererEvents#mousemove
 * @fires og.RendererEvents#mousestop
 * @fires og.RendererEvents#lclick
 * @fires og.RendererEvents#rclick
 * @fires og.RendererEvents#mclick
 * @fires og.RendererEvents#ldblclick
 * @fires og.RendererEvents#rdblclick
 * @fires og.RendererEvents#mdblclick
 * @fires og.RendererEvents#lup
 * @fires og.RendererEvents#rup
 * @fires og.RendererEvents#mup
 * @fires og.RendererEvents#ldown
 * @fires og.RendererEvents#rdown
 * @fires og.RendererEvents#mdown
 * @fires og.RendererEvents#lhold
 * @fires og.RendererEvents#rhold
 * @fires og.RendererEvents#mhold
 * @fires og.RendererEvents#mousewheel
 * @fires og.RendererEvents#touchstart
 * @fires og.RendererEvents#touchend
 * @fires og.RendererEvents#touchcancel
 * @fires og.RendererEvents#touchmove
 * @fires og.RendererEvents#doubletouch
 * @fires og.RendererEvents#touchleave
 * @fires og.RendererEvents#touchenter
 */
class Renderer {
    constructor(handler, params) {

        params = params || {};

        /**
         * Div element with WebGL canvas.
         * @public
         * @type {object}
         */
        this.div = null;

        /**
         * WebGL handler context.
         * @public
         * @type {og.webgl.Handler}
         */
        this.handler = handler;

        /**
         * Render nodes drawing queue.
         * @private
         * @type {Array.<og.scene.RenderNode>}
         */
        this._renderNodesArr = [];

        /**
         * Render nodes store for the comfortable access by the node name.
         * @public
         * @type {Object.<og.scene.RenderNode>}
         */
        this.renderNodes = {};

        /**
         * Cameras array.
         * @public
         * @type {Array.<og.Camera>}
         */
        this.cameras = [];

        /**
         * Current active camera.
         * @public
         * @type {og.Camera}
         */
        this.activeCamera = null;

        /**
         * Renderer events. Represents interface for setting events like mousemove, draw, keypress etc.
         * @public
         * @type {og.RendererEvents}
         */
        this.events = new _RendererEvents_js__WEBPACK_IMPORTED_MODULE_4__["RendererEvents"](this);

        /**
         * OpenGlobus controls array.
         * @public
         * @type {Array.<og.control.Control>}
         */
        this.controls = params.controls || [];

        /**
         * Provides exchange between controls.
         * @public
         * @type {Object}
         */
        this.controlsBag = {};

        /**
         * Hash table for drawing objects.
         * @public
         * @type {Object}
         */
        this.colorObjects = {};

        /**
         * Color picking objects rendering queue.
         * @type {Array.<og.Renderer~pickingCallback>}
         */
        this._pickingCallbacks = [];

        /**
         * Picking objects(labels and billboards) framebuffer.
         * @public
         * @type {og.webgl.Framebuffer}
         */
        this.pickingFramebuffer = null;

        /**
         * Whole scene rendering framebuffer.
         * @public
         * @type {og.webgl.Framebuffer|og.webgl.MultiFramebuffer}
         */
        this.sceneFramebuffer = null;

        /**
         * Stores current picking rgb color.
         * @private
         * @type {Array.<number,number,number>}
         */
        this._currPickingColor = [0, 0, 0];

        /**
         * Stores previous picked rgb color.
         * @private
         * @type {Array.<number,number,number>}
         */
        this._prevPickingColor = [0, 0, 0];

        /**
         * @private
         */
        this._fnScreenFrame = null;

        if (params.autoActivate) {
            this.initialize();
            this.start();
        }
    }

    /**
     * Adds picking rendering callback function.
     * @param {object} sender - Callback context.
     * @param {og.Renderer~pickingCallback} callback - Rendering callback.
     */
    addPickingCallback(sender, callback) {
        this._pickingCallbacks.push({ "callback": callback, "sender": sender });
    }

    /**
     * Assign picking color to the object.
     * @public
     * @param {Object} obj - Object that pressume to be picked.
     */
    assignPickingColor(obj) {
        if (!obj._pickingColor || obj._pickingColor.isZero()) {
            var r = 0, g = 0, b = 0;
            var str = "0_0_0";
            while (!(r || g || b) || this.colorObjects[str]) {
                r = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["randomi"])(1, 255);
                g = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["randomi"])(1, 255);
                b = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["randomi"])(1, 255);
                str = r + "_" + g + "_" + b;
            }

            if (!obj._pickingColor)
                obj._pickingColor = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](r, g, b);
            else
                obj._pickingColor.set(r, g, b);

            this.colorObjects[str] = obj;
        }
    }

    /**
     * Removes picking color from object.
     * @public
     * @param {Object} obj - Object to remove picking color.
     */
    clearPickingColor(obj) {
        if (!obj._pickingColor.isZero()) {
            var c = obj._pickingColor;
            if (!c.isZero()) {
                this.colorObjects[c.x + "_" + c.y + "_" + c.z] = null;
                delete this.colorObjects[c.x + "_" + c.y + "_" + c.z];
                c.x = c.y = c.z = 0;
            }
        }
    }

    /**
     * Get the client width.
     * @public
     * @returns {number} -
     */
    getWidth() {
        return this.handler.canvas.width;
    }

    /**
     * Get the client height.
     * @public
     * @returns {number} -
     */
    getHeight() {
        return this.handler.canvas.height;
    }

    /**
     * Get center of the screen
     * @public
     * @returns {og.math.Vec2} -
     */
    getCenter() {
        var cnv = this.handler.canvas;
        return new _math_Vec2_js__WEBPACK_IMPORTED_MODULE_5__["Vec2"](Math.round(cnv.width * 0.5), Math.round(cnv.height * 0.5));
    }

    /**
     * Add the given control to the renderer.
     * @param {og.control.BaseControl} control - Control.
     */
    addControl(control) {
        control.addTo(this);
    }

    /**
     * Add the given controls array to the planet node.
     * @param {Array.<og.control.BaseControl>} cArr - Control array.
     */
    addControls(cArr) {
        for (var i = 0; i < cArr.length; i++) {
            cArr[i].addTo(this);
        }
    }

    /**
     * Remove control from the renderer.
     * @param {og.control.BaseControl} control  - Control.
     * @return {og.control.BaseControl|undefined} -
     */
    removeControl(control) {
        for (var i = 0; i < this.controls.length; i++) {
            if (this.controls[i].isEqual(control)) {
                this.controls.splice(i, 1);
                control.remove();
                return control;
            }
        }
        return undefined;
    }

    /**
     * Renderer initialization.
     * @public
     */
    initialize() {
        var that = this;

        this.handler.setFrameCallback(function () {
            that.draw();
        });

        this.activeCamera = new _camera_Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"](this, {
            'eye': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](0, 0, 0),
            'look': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](0, 0, -1),
            'up': new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](0, 1, 0)
        });

        this.events.initialize();

        //Bind console key
        this.events.on("charkeypress", _input_input_js__WEBPACK_IMPORTED_MODULE_10__["input"].KEY_APOSTROPHE, function () {
            _cons_js__WEBPACK_IMPORTED_MODULE_7__["cons"].setVisibility(!_cons_js__WEBPACK_IMPORTED_MODULE_7__["cons"].getVisibility());
        });

        this.handler.onCanvasResize = function (obj) {
            that.activeCamera.setAspectRatio(obj.clientWidth / obj.clientHeight);
            that.sceneFramebuffer.setSize(obj.clientWidth, obj.clientHeight);
            that.events.dispatch(that.events.resize, obj);
        };

        this.pickingFramebuffer = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__["Framebuffer"](this.handler, {
            'width': 640,
            'height': 480
        });
        this.pickingFramebuffer.init();

        this.handler.addShaderProgram(new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_8__["ShaderProgram"]("screenFrame", {
            uniforms: {
                texture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_9__["types"].SAMPLER2D }
            },
            attributes: {
                corners: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_9__["types"].VEC3, enableArray: true },
            },
            vertexShader:
            'attribute vec2 corners;\
            \
            varying vec2 tc;\
            void main(void) {\
                gl_Position = vec4(corners, 0.0, 1.0);\
                tc = corners * 0.5 + 0.5;\
            }',
            fragmentShader:
            'precision highp float;\
            uniform sampler2D texture;\
            \
            varying vec2 tc;\
            \
            void main(void) {\
                gl_FragColor = texture2D( texture, tc );\
            }'
        }));

        //Append multiframebuffer(WEBGL_draw_buffers) extension.
        this._drawBuffersExtension = this.handler.initializeExtension("WEBGL_draw_buffers");

        if (this._drawBuffersExtension) {
            this.sceneFramebuffer = new _webgl_MultiFramebuffer_js__WEBPACK_IMPORTED_MODULE_2__["MultiFramebuffer"](this.handler, { size: 3 });
            this.sceneFramebuffer.init();

            this._fnScreenFrame = this._multiframebufferScreenFrame;
        } else {
            this.sceneFramebuffer = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__["Framebuffer"](this.handler);
            this.sceneFramebuffer.init();

            this._fnScreenFrame = this._singleframebufferScreenFrame;
        }

        this._screenFrameCornersBuffer = this.handler.createArrayBuffer(new Float32Array([1, 1, -1, 1, 1, -1, -1, -1]), 2, 4);

        let _c = this.controls;
        this.controls = [];
        this.addControls(_c);
    };

    /**
     * Adds render node to the renderer.
     * @public
     * @param {og.scene.RenderNode} renderNode - Render node.
     */
    addRenderNode(renderNode) {
        if (!this.renderNodes[renderNode.name]) {
            renderNode.assignRenderer(this);
            this._renderNodesArr.unshift(renderNode);
            this.renderNodes[renderNode.name] = renderNode;
        } else {
            _cons_js__WEBPACK_IMPORTED_MODULE_7__["cons"].logWrn("og.Renderer(370) - node name: " + renderNode.name + " allready exists.");
        }
    }

    /**
     * Adds render nodes array to the renderer.
     * @public
     * @param {Array.<og.scene.RenderNode>} nodesArr - Render nodes array.
     */
    addRenderNodes(nodesArr) {
        for (var i = 0; i < nodesArr.length; i++) {
            this.addRenderNode(nodesArr[i]);
        }
    }

    /**
     * Draw nodes.
     * @public
     */
    draw() {

        this.activeCamera.checkMoveEnd();

        var e = this.events;
        e.handleEvents();
        e.dispatch(e.draw, this);

        var sfb = this.sceneFramebuffer;
        sfb.activate();
        var h = this.handler;
        h.clearFrame();

        h.gl.activeTexture(h.gl.TEXTURE0);
        h.gl.bindTexture(h.gl.TEXTURE_2D, h.transparentTexture);

        //Rendering scene nodes
        var rn = this._renderNodesArr;
        var i = rn.length;
        while (i--) {
            rn[i].drawNode();
        }

        sfb.deactivate();

        //Rendering picking callbacks and refresh pickingColor
        this._drawPickingBuffer();

        //Rendering on the screen
        this._fnScreenFrame();

        e.mouseState.moving = false;
        e.touchState.moving = false;
    }

    _multiframebufferScreenFrame() {
        var h = this.handler;
        var sh = h.shaderPrograms.screenFrame,
            p = sh._program,
            gl = h.gl;

        gl.disable(gl.DEPTH_TEST);
        sh.activate();
        gl.activeTexture(gl.TEXTURE0);
        //MAYBE: Could be refactored with framebuf function like getTexture()
        gl.bindTexture(gl.TEXTURE_2D, this.sceneFramebuffer.textures[0]);
        //gl.bindTexture(gl.TEXTURE_2D, this.pickingFramebuffer.texture);
        gl.uniform1i(p.uniforms.texture._pName, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._screenFrameCornersBuffer);
        gl.vertexAttribPointer(p.attributes.corners._pName, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.enable(gl.DEPTH_TEST);
    }

    _singleframebufferScreenFrame() {
        var h = this.handler;
        var sh = h.shaderPrograms.screenFrame,
            p = sh._program,
            gl = h.gl;

        gl.disable(gl.DEPTH_TEST);
        sh.activate();
        gl.activeTexture(gl.TEXTURE0);
        //gl.bindTexture(gl.TEXTURE_2D, this.pickingFramebuffer.texture);
        //gl.bindTexture(gl.TEXTURE_2D, globus.planet._heightPickingFramebuffer.texture);
        gl.bindTexture(gl.TEXTURE_2D, this.sceneFramebuffer.texture);
        gl.uniform1i(p.uniforms.texture._pName, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._screenFrameCornersBuffer);
        gl.vertexAttribPointer(p.attributes.corners._pName, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.enable(gl.DEPTH_TEST);
    }

    /**
     * Returns picking object by screen coordinates
     * @param {number} x - X position
     * @param {number} y - Y position
     * @return {Object} -
     */
    getPickingObject(x, y) {
        var cnv = this.renderer.handler.canvas;
        var c;
        if (this._drawBuffersExtension) {
            c = this.sceneFramebuffer.readPixel(x / cnv.width, (cnv.height - y) / cnv.height, 1);
        } else {
            c = this.sceneFramebuffer.readPixel(x / cnv.width, (cnv.height - y) / cnv.height);
        }
        return this.colorObjects[c[0] + "_" + c[1] + "_" + c[2]];
    }

    /** 
     * Returns true if 'WEBGL_draw_buffers' extension initialized.
     * @public
     * @returns {Boolean} -
     */
    isMultiFramebufferCompatible() {
        return (this._drawBuffersExtension ? true : false);
    }

    /**
     * Draw picking objects framebuffer.
     * @private
     */
    _drawPickingBuffer() {
        this.pickingFramebuffer.activate();

        var h = this.handler;
        var gl = h.gl;
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.disable(h.gl.BLEND);

        var dp = this._pickingCallbacks;
        var i = dp.length;
        while (i--) {
            /**
             * This callback renders picking frame.
             * @callback og.Renderer~pickingCallback
             */
            dp[i].callback.call(dp[i].sender);
        }

        this.pickingFramebuffer.deactivate();

        var ms = this.events.mouseState;
        var ts = this.events.touchState;

        if (!(ms.leftButtonHold || ms.rightButtonHold || ms.middleButtonHold)) {
            this._prevPickingColor[0] = this._currPickingColor[0];
            this._prevPickingColor[1] = this._currPickingColor[1];
            this._prevPickingColor[2] = this._currPickingColor[2];

            var pc;
            if (ts.x || ts.y) {
                pc = this.pickingFramebuffer.readPixel(ts.nx, 1.0 - ts.ny);
                if (!(pc[0] || pc[1] || pc[2]) && this._drawBuffersExtension)
                    pc = this.sceneFramebuffer.readPixel(ts.nx, 1.0 - ts.ny, 1);
            } else {
                pc = this.pickingFramebuffer.readPixel(ms.nx, 1.0 - ms.ny);
                if (!(pc[0] || pc[1] || pc[2]) && this._drawBuffersExtension)
                    pc = this.sceneFramebuffer.readPixel(ms.nx, 1.0 - ms.ny, 1);
            }
            this._currPickingColor = pc;
        }
    };

    /**
     * Function starts rendering.
     * @public
     */
    start() {
        this.handler.start();
    }
};



/***/ }),

/***/ "./src/og/renderer/RendererEvents.js":
/*!*******************************************!*\
  !*** ./src/og/renderer/RendererEvents.js ***!
  \*******************************************/
/*! exports provided: RendererEvents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RendererEvents", function() { return RendererEvents; });
/* harmony import */ var _Events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Events.js */ "./src/og/Events.js");
/* harmony import */ var _input_input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../input/input.js */ "./src/og/input/input.js");
/* harmony import */ var _input_KeyboardHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../input/KeyboardHandler.js */ "./src/og/input/KeyboardHandler.js");
/* harmony import */ var _input_MouseHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../input/MouseHandler.js */ "./src/og/input/MouseHandler.js");
/* harmony import */ var _input_TouchHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../input/TouchHandler.js */ "./src/og/input/TouchHandler.js");
/* harmony import */ var _math_Vec2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vec2.js */ "./src/og/math/Vec2.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/renderer/RendererEvents
 */











/**
 * Renderer events handler.
 * @class
 * @param {og.Renderer} renderer - Renderer object, events that works for.
 */
class RendererEvents extends _Events_js__WEBPACK_IMPORTED_MODULE_0__["Events"] {
    constructor(renderer) {

        super(EVENT_NAMES);

        /**
         * Assigned renderer.
         * @public
         * @type {og.Renderer}
         */
        this.renderer = renderer;

        /**
         * Low level touch events handler.
         * @private
         * @type {og.input.TouchHandler}
         */
        this._touchHandler = new _input_TouchHandler_js__WEBPACK_IMPORTED_MODULE_4__["TouchHandler"](renderer.handler.canvas);

        /**
         * Low level mouse events handler.
         * @private
         * @type {og.input.MouseHandler}
         */
        this._mouseHandler = new _input_MouseHandler_js__WEBPACK_IMPORTED_MODULE_3__["MouseHandler"](renderer.handler.canvas);

        /**
         * Low level keyboard events handler.
         * @private
         * @type {og.input.KeyboardHandler}
         */
        this._keyboardHandler = new _input_KeyboardHandler_js__WEBPACK_IMPORTED_MODULE_2__["KeyboardHandler"]();

        /**
         * Current mouse state.
         * @public
         * @enum {Object}
         */
        this.mouseState = {
            /** Current mouse X position. */
            x: 0,
            /** Current mouse Y position. */
            y: 0,
            /** Current mouse X position from 0 to 1 */
            nx: 0,
            /** Current mouse Y position from 0 to 1 */
            ny: 0,
            /** Previous mouse X position. */
            prev_x: 0,
            /** Previous mouse Y position. */
            prev_y: 0,
            /** Screen mouse position world direction. */
            direction: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_6__["Vec3"](),
            /** Left mouse button has stopped pushing down right now.*/
            leftButtonUp: false,
            /** Right mouse button has stopped pushing down right now.*/
            rightButtonUp: false,
            /** Middle mouse button has stopped pushing down right now.*/
            middleButtonUp: false,
            /** Left mouse button has pushed now.*/
            leftButtonDown: false,
            /** Right mouse button has pushed now.*/
            rightButtonDown: false,
            /** Middle mouse button has pushed now.*/
            middleButtonDown: false,
            /** Left mouse button is pushing.*/
            leftButtonHold: false,
            /** Right mouse button is pushing.*/
            rightButtonHold: false,
            /** Middle mouse button is pushing.*/
            middleButtonHold: false,
            /** Left mouse button has clicked twice now.*/
            leftButtonDoubleClick: false,
            /** Right mouse button has clicked twice now.*/
            rightButtonDoubleClick: false,
            /** Middle mouse button has clicked twice now.*/
            middleButtonDoubleClick: false,
            /** Left mouse button has clicked now. */
            leftButtonClick: false,
            /** Right mouse button has clicked now. */
            rightButtonClick: false,
            /** Middle mouse button has clicked now. */
            middleButtonClick: false,
            /** Mouse is moving now. */
            moving: false,
            /** Mouse has just stopped now. */
            justStopped: false,
            /** Mose double click delay response.*/
            doubleClickDelay: 300,
            /** Mouse wheel. */
            wheelDelta: 0,
            /** JavaScript mouse system event message. */
            sys: null,
            /** Current picking object. */
            pickingObject: null
        };

        /**
         * Current touch state.
         * @public
         * @enum {Object}
         */
        this.touchState = {
            /** Touching is moving now. */
            moving: false,
            /** Touch has ended right now.*/
            touchEnd: false,
            /** Touch has started right now.*/
            touchStart: false,
            /** Touch canceled.*/
            touchCancel: false,
            /** Touched twice.*/
            doubleTouch: false,
            /** Double touching responce delay.*/
            doubleTouchDelay: 550,
            /** Double touching responce radius in screen pixels.*/
            doubleTouchRadius: 10,
            /** Current touch X - coordinate. */
            x: 0,
            /** Current touch Y - coordinate. */
            y: 0,
            /** Current touch X - coordinate from 0 to 1 */
            nx: 0,
            /** Current touch Y - coordinate from 0 to 1 */
            ny: 0,
            /** Previous touch X coordinate. */
            prev_x: 0,
            /** Previous touch Y coordinate. */
            prev_y: 0,
            /** JavaScript touching system event message. */
            sys: null,
            /** Current touched(picking) object. */
            pickingObject: null
        };

        this._dblTchCoords = new _math_Vec2_js__WEBPACK_IMPORTED_MODULE_5__["Vec2"]();
        this._oneTouchStart = false;
        this._dblTchBegins = 0;
        this._mousestopThread = null;
        this._ldblClkBegins = 0;
        this._rdblClkBegins = 0;
        this._mdblClkBegins = 0;
        this._lclickX = 0;
        this._lclickY = 0;
        this._rclickX = 0;
        this._rclickY = 0;
        this._mclickX = 0;
        this._mclickY = 0;
    }

    /**
     * Used in render node frame.
     * @public
     */
    handleEvents() {
        this.mouseState.direction = this.renderer.activeCamera.unproject(this.mouseState.x, this.mouseState.y);
        this.entityPickingEvents();
        this._keyboardHandler.handleEvents();
        this.handleMouseEvents();
        this.handleTouchEvents();
    }

    /**
     * Set render event callback.
     * @public
     * @param {string} name - Event name
     * @param {eventCallback} callback - Callback function
     * @param {number} [key] - Key code from og.input
     * @param {*} sender - Callback context
     * @param {number} [priority] - Event callback priority
     */
    on(name, p0, p1, p2, p3) {
        if (name == "keypress" || name == "charkeypress") {
            this._keyboardHandler.addEvent(name, p2, p1, p0, p3);
        } else {
            super.on(name, p0, p1);
        }
    }

    /**
     * Check key is pressed.
     * @public
     * @param {number} keyCode - Key code
     * @return {boolean}
     */
    isKeyPressed(keyCode) {
        return this._keyboardHandler.isKeyPressed(keyCode);
    }

    /**
     * Renderer events initialization.
     * @public
     */
    initialize() {

        this._mouseHandler.setEvent("mouseup", this, this.onMouseUp);
        this._mouseHandler.setEvent("mousemove", this, this.onMouseMove);
        this._mouseHandler.setEvent("mousedown", this, this.onMouseDown);
        this._mouseHandler.setEvent("mousewheel", this, this.onMouseWheel);

        this._touchHandler.setEvent("touchstart", this, this.onTouchStart);
        this._touchHandler.setEvent("touchend", this, this.onTouchEnd);
        this._touchHandler.setEvent("touchcancel", this, this.onTouchCancel);
        this._touchHandler.setEvent("touchmove", this, this.onTouchMove);
    }

    /**
     * @private
     */
    onMouseWheel(event) {
        this.mouseState.wheelDelta = event.wheelDelta;
    }

    /**
     * @private
     */
    onMouseMove(event) {
        var ms = this.mouseState;
        ms.sys = event;

        if (ms.x === event.clientX && ms.y === event.clientY) {
            return;
        }

        this._ldblClkBegins = 0;
        this._rdblClkBegins = 0;
        this._mdblClkBegins = 0;

        ms.x = event.clientX;
        ms.y = event.clientY;

        var cnv = this.renderer.handler.canvas;
        ms.nx = ms.x / cnv.width;
        ms.ny = ms.y / cnv.height;

        ms.moving = true;

        //dispatch stop mouse event
        clearTimeout(this._mousestopThread);
        var that = this;
        this._mousestopThread = setTimeout(function () {
            ms.justStopped = true;
        }, 100);
    }

    /**
     * @private
     */
    onMouseDown(event) {
        if (event.button === _input_input_js__WEBPACK_IMPORTED_MODULE_1__["input"].MB_LEFT) {
            this._lclickX = event.clientX;
            this._lclickY = event.clientY;
            this.mouseState.sys = event;
            this.mouseState.leftButtonDown = true;
        } else if (event.button === _input_input_js__WEBPACK_IMPORTED_MODULE_1__["input"].MB_RIGHT) {
            this._rclickX = event.clientX;
            this._rclickY = event.clientY;
            this.mouseState.sys = event;
            this.mouseState.rightButtonDown = true;
        } else if (event.button === _input_input_js__WEBPACK_IMPORTED_MODULE_1__["input"].MB_MIDDLE) {
            this._mclickX = event.clientX;
            this._mclickY = event.clientY;
            this.mouseState.sys = event;
            this.mouseState.middleButtonDown = true;
        }
    }

    /**
     * @private
     */
    onMouseUp(event) {
        var ms = this.mouseState;
        ms.sys = event;
        if (event.button === _input_input_js__WEBPACK_IMPORTED_MODULE_1__["input"].MB_LEFT) {
            ms.leftButtonDown = false;
            ms.leftButtonUp = true;

            if (this._lclickX === event.clientX &&
                this._lclickY === event.clientY) {

                if (this._ldblClkBegins) {
                    var deltatime = new Date().getTime() - this._ldblClkBegins;
                    if (deltatime <= ms.doubleClickDelay) {
                        ms.leftButtonDoubleClick = true;
                    }
                    this._ldblClkBegins = 0;
                } else {
                    this._ldblClkBegins = new Date().getTime();
                }

                ms.leftButtonClick = true;
            }

        } else if (event.button === _input_input_js__WEBPACK_IMPORTED_MODULE_1__["input"].MB_RIGHT) {
            ms.rightButtonDown = false;
            ms.rightButtonUp = true;

            if (this._rclickX === event.clientX &&
                this._rclickY === event.clientY) {

                if (this._rdblClkBegins) {
                    var deltatime = new Date().getTime() - this._rdblClkBegins;
                    if (deltatime <= ms.doubleClickDelay) {
                        ms.rightButtonDoubleClick = true;
                    }
                    this._rdblClkBegins = 0;
                } else {
                    this._rdblClkBegins = new Date().getTime();
                }

                ms.rightButtonClick = true;
            }
        } else if (event.button === _input_input_js__WEBPACK_IMPORTED_MODULE_1__["input"].MB_MIDDLE) {
            ms.middleButtonDown = false;
            ms.middleButtonUp = true;

            if (this._mclickX === event.clientX &&
                this._mclickY === event.clientY) {

                if (this._mdblClkBegins) {
                    var deltatime = new Date().getTime() - this._mdblClkBegins;
                    if (deltatime <= ms.doubleClickDelay) {
                        ms.middleButtonDoubleClick = true;
                    }
                    this._mdblClkBegins = 0;
                } else {
                    this._mdblClkBegins = new Date().getTime();
                }

                ms.middleButtonClick = true;
            }
        }
    }

    /**
     * @private
     */
    onTouchStart(event) {
        var ts = this.touchState;
        ts.sys = event;
        ts.x = event.touches.item(0).clientX - event.offsetLeft;
        ts.y = event.touches.item(0).clientY - event.offsetTop;
        var cnv = this.renderer.handler.canvas;
        ts.nx = ts.x / cnv.width;
        ts.ny = ts.y / cnv.height;
        ts.prev_x = ts.x;
        ts.prev_y = ts.y;
        ts.touchStart = true;

        if (event.touches.length === 1) {
            this._dblTchCoords.x = ts.x;
            this._dblTchCoords.y = ts.y;
            this._oneTouchStart = true;
        } else {
            this._oneTouchStart = false;
        }
    }

    /**
     * @private
     */
    onTouchEnd(event) {
        var ts = this.touchState;
        ts.sys = event;
        ts.touchEnd = true;

        if (event.touches.length === 0) {

            ts.prev_x = ts.x;
            ts.prev_y = ts.y;

            if (this._oneTouchStart) {

                if (this._dblTchBegins) {
                    var deltatime = new Date().getTime() - this._dblTchBegins;
                    if (deltatime <= ts.doubleTouchDelay) {
                        ts.doubleTouch = true;
                    }
                    this._dblTchBegins = 0;
                }
                this._dblTchBegins = new Date().getTime();
                this._oneTouchStart = false;
            }
        }
    }

    /**
     * @private
     */
    onTouchCancel(event) {
        var ts = this.touchState;
        ts.sys = event;
        ts.touchCancel = true;
    }

    /**
     * @private
     */
    onTouchMove(event) {
        var ts = this.touchState;
        ts.x = event.touches.item(0).clientX - event.offsetLeft;
        ts.y = event.touches.item(0).clientY - event.offsetTop;
        var cnv = this.renderer.handler.canvas;
        ts.nx = ts.x / cnv.width;
        ts.ny = ts.y / cnv.height;
        ts.sys = event;
        ts.moving = true;
        this._dblTchBegins = 0;
        this._oneTouchStart = false;
    }

    /**
     * @private
     */
    entityPickingEvents() {
        var ts = this.touchState,
            ms = this.mouseState;

        if (!(ms.leftButtonHold || ms.rightButtonHold || ms.middleButtonHold)) {

            var r = this.renderer;

            var o = r.colorObjects;

            var c = r._currPickingColor,
                p = r._prevPickingColor;

            ms.pickingObject = null;
            ts.pickingObject = null;

            var co = o && o[c[0] + "_" + c[1] + "_" + c[2]];

            ms.pickingObject = co;
            ts.pickingObject = co;

            //object changed
            if (c[0] != p[0] || c[1] != p[1] || c[2] != p[2]) {
                //current black
                if (!(c[0] || c[1] || c[2])) {
                    var po = o[p[0] + "_" + p[1] + "_" + p[2]];
                    if (po) {
                        //TODO: This is a reason to replace geometryHandler to an entityCollection...or maybe not
                        var pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                        ms.pickingObject = po;
                        pe.dispatch(pe.mouseleave, ms);
                        ts.pickingObject = po;
                        pe.dispatch(pe.touchleave, ts);
                    }
                } else {
                    //current not black

                    //previous not black
                    if (p[0] || p[1] || p[2]) {
                        var po = o[p[0] + "_" + p[1] + "_" + p[2]];
                        if (po) {
                            var pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                            ms.pickingObject = po;
                            pe.dispatch(pe.mouseleave, ms);
                            ts.pickingObject = po;
                            pe.dispatch(pe.touchleave, ts);
                        }
                    }

                    if (co) {
                        var ce = co.events || co._entityCollection && co._entityCollection.events || co._layer.events;
                        ms.pickingObject = co;
                        ce.dispatch(ce.mouseenter, ms);
                        ts.pickingObject = co;
                        ce.dispatch(ce.touchenter, ts);
                    }
                }
            }
        }
    }

    /**
     * @private
     */
    handleMouseEvents() {
        let ms = this.mouseState;
        let po = ms.pickingObject,
            pe = null;

        if (ms.leftButtonClick) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.lclick, ms);
            }
            this.dispatch(this.lclick, ms);
            ms.leftButtonClick = false;
        }

        if (ms.rightButtonClick) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.rclick, ms);
            }
            this.dispatch(this.rclick, ms);
            ms.rightButtonClick = false;
        }

        if (ms.middleButtonClick) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.mclick, ms);
            }
            this.dispatch(this.mclick, ms);
            ms.middleButtonClick = false;
        }

        if (ms.leftButtonDown) {
            if (ms.leftButtonHold) {
                if (po) {
                    pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                    pe.dispatch(pe.lhold, ms);
                }
                this.dispatch(this.lhold, ms);
            } else {
                ms.leftButtonHold = true;
                if (po) {
                    pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                    pe.dispatch(pe.ldown, ms);
                }
                this.dispatch(this.ldown, ms);
            }
        }

        if (ms.rightButtonDown) {
            if (ms.rightButtonHold) {
                if (po) {
                    pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                    pe.dispatch(pe.rhold, ms);
                }
                this.dispatch(this.rhold, ms);
            } else {
                ms.rightButtonHold = true;
                if (po) {
                    pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                    pe.dispatch(pe.rdown, ms);
                }
                this.dispatch(this.rdown, ms);
            }
        }

        if (ms.middleButtonDown) {
            if (ms.middleButtonHold) {
                if (po) {
                    pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                    pe.dispatch(pe.mhold, ms);
                }
                this.dispatch(this.mhold, ms);
            } else {
                ms.middleButtonHold = true;
                if (po) {
                    pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                    pe.dispatch(pe.mdown, ms);
                }
                this.dispatch(this.mdown, ms);
            }
        }

        if (ms.leftButtonUp) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.lup, ms);
            }
            this.dispatch(this.lup, ms);
            ms.leftButtonUp = false;
            ms.leftButtonHold = false;
        }

        if (ms.rightButtonUp) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.rup, ms);
            }
            this.dispatch(this.rup, ms);
            ms.rightButtonUp = false;
            ms.rightButtonHold = false;
        }

        if (ms.middleButtonUp) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.mup, ms);
            }
            this.dispatch(this.mup, ms);
            ms.middleButtonUp = false;
            ms.middleButtonHold = false;
        }

        if (ms.leftButtonDoubleClick) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.ldblclick, ms);
            }
            this.dispatch(this.ldblclick, ms);
            ms.leftButtonDoubleClick = false;
        }

        if (ms.rightButtonDoubleClick) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.rdblclick, ms);
            }
            this.dispatch(this.rdblclick, ms);
            ms.rightButtonDoubleClick = false;
        }

        if (ms.middleButtonDoubleClick) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.mdblclick, ms);
            }
            this.dispatch(this.mdblclick, ms);
            ms.middleButtonDoubleClick = false;
        }

        if (ms.wheelDelta) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.mousewheel, ms);
            }
            this.dispatch(this.mousewheel, ms);
            ms.wheelDelta = 0;
        }

        if (ms.moving) {
            if (po) {
                pe = po.events || po._entityCollection && po._entityCollection.events || po._layer.events;
                pe.dispatch(pe.mousemove, ms);
            }
            this.dispatch(this.mousemove, ms);
            ms.prev_x = ms.x;
            ms.prev_y = ms.y;
        }

        if (ms.justStopped) {
            this.dispatch(this.mousestop, ms);
            ms.justStopped = false;
        }
    }

    /**
     * @private
     */
    handleTouchEvents() {
        var ts = this.touchState;

        var tpo = ts.pickingObject,
            tpe = null;

        if (ts.touchCancel) {
            this.dispatch(this.touchcancel, ts);
            ts.touchCancel = false;
        }

        if (ts.touchStart) {
            var r = this.renderer;
            r._currPickingColor = (r._drawBuffersExtension ?
                r.pickingFramebuffer.readPixel(ts.nx, 1.0 - ts.ny, 1) :
                r.pickingFramebuffer.readPixel(ts.nx, 1.0 - ts.ny));
            var o = r.colorObjects;
            var c = r._currPickingColor;
            var co = o[c[0] + "_" + c[1] + "_" + c[2]];
            tpo = ts.pickingObject = co;
            if (tpo) {
                tpe = tpo.events || tpo._entityCollection && tpo._entityCollection.events || tpo._layer.events;
                tpe.dispatch(tpe.touchstart, ts);
            }
            this.dispatch(this.touchstart, ts);
            ts.touchStart = false;
        }

        if (ts.doubleTouch) {
            if (tpo) {
                tpe = tpo.events || tpo._entityCollection && tpo._entityCollection.events || tpo._layer.events;
                tpe.dispatch(tpe.doubletouch, ts);
            }
            this.dispatch(this.doubletouch, ts);
            ts.doubleTouch = false;
        }

        if (ts.touchEnd) {
            if (tpo) {
                tpe = tpo.events || tpo._entityCollection && tpo._entityCollection.events || tpo._layer.events;
                tpe.dispatch(tpe.touchend, ts);
            }
            this.dispatch(this.touchend, ts);
            ts.x = 0;
            ts.y = 0;
            ts.touchEnd = false;
        }

        if (ts.moving) {
            if (tpo) {
                tpe = tpo.events || tpo._entityCollection && tpo._entityCollection.events || tpo._layer.events;
                tpe.dispatch(tpe.touchmove, ts);
            }
            this.dispatch(this.touchmove, ts);
            ts.prev_x = ts.x;
            ts.prev_y = ts.y;
        }
    }
};

const EVENT_NAMES = [
    /**
     * Triggered before scene frame is rendered(before render nodes).
     * @event og.RendererEvents#draw
     */
    "draw",

    /**
     * Triggered when screen is resized.
     * @event og.RendererEvents#resize
     */
    "resize",

    /**
     * Mouse is moving.
     * @event og.RendererEvents#mousemove
     */
    "mousemove",

    /**
     * Mouse is just stopped.
     * @event og.RendererEvents#mousestop
     */
    "mousestop",

    /**
     * Mouse left button clicked.
     * @event og.RendererEvents#lclick
     */
    "lclick",

    /**
     * Mouse right button clicked.
     * @event og.RendererEvents#rclick
     */
    "rclick",

    /**
     * Mouse middle button clicked.
     * @event og.RendererEvents#mclick
     */
    "mclick",

    /**
     * Mouse left button double click.
     * @event og.RendererEvents#ldblclick
     */
    "ldblclick",

    /**
     * Mouse right button double click.
     * @event og.RendererEvents#rdblclick
     */
    "rdblclick",

    /**
     * Mouse middle button double click.
     * @event og.RendererEvents#mdblclick
     */
    "mdblclick",

    /**
     * Mouse left button up(stop pressing).
     * @event og.RendererEvents#lup
     */
    "lup",

    /**
     * Mouse right button up(stop pressing).
     * @event og.RendererEvents#rup
     */
    "rup",

    /**
     * Mouse middle button up(stop pressing).
     * @event og.RendererEvents#mup
     */
    "mup",

    /**
     * Mouse left button is just pressed down(start pressing).
     * @event og.RendererEvents#ldown
     */
    "ldown",

    /**
     * Mouse right button is just pressed down(start pressing).
     * @event og.RendererEvents#rdown
     */
    "rdown",

    /**
     * Mouse middle button is just pressed down(start pressing).
     * @event og.RendererEvents#mdown
     */
    "mdown",

    /**
     * Mouse left button is pressing.
     * @event og.RendererEvents#lhold
     */
    "lhold",

    /**
     * Mouse right button is pressing.
     * @event og.RendererEvents#rhold
     */
    "rhold",

    /**
     * Mouse middle button is pressing.
     * @event og.RendererEvents#mhold
     */
    "mhold",

    /**
     * Mouse wheel is rotated.
     * @event og.RendererEvents#mousewheel
     */
    "mousewheel",

    /**
     * Triggered when touching starts.
     * @event og.RendererEvents#touchstart
     */
    "touchstart",

    /**
     * Triggered when touching ends.
     * @event og.RendererEvents#touchend
     */
    "touchend",

    /**
     * Triggered when touching cancel.
     * @event og.RendererEvents#touchcancel
     */
    "touchcancel",

    /**
     * Triggered when touch is move.
     * @event og.RendererEvents#touchmove
     */
    "touchmove",

    /**
     * Triggered when double touch.
     * @event og.RendererEvents#doubletouch
     */
    "doubletouch",

    /**
     * Triggered when touch leaves picked object.
     * @event og.RendererEvents#touchleave
     */
    "touchleave",

    /**
     * Triggered when touch enter picking object.
     * @event og.RendererEvents#touchenter
     */
    "touchenter"
];




/***/ }),

/***/ "./src/og/scene/BaseNode.js":
/*!**********************************!*\
  !*** ./src/og/scene/BaseNode.js ***!
  \**********************************/
/*! exports provided: BaseNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseNode", function() { return BaseNode; });
/**
 * @module og/scene/BaseNode
 */



/**
 * Scene node base class.
 * @class
 * @param {string} name - Node name.
 */
class BaseNode {
    constructor(name) {

        /**
         * Node name.
         * @public
         * @type {string}
         */
        this.name = name;

        /**
         * Top scene tree node pointer.
         * @public
         * @type {og.scene.Node}
         */
        this.topNode = this;

        this._dictionary = [];
        this._dictionary[name] = this;

        /**
         * Children nodes.
         * @public
         * @type {Array.<og.scene.Node>}
         */
        this.childNodes = [];

        /**
         * Parent node pointer.
         * @public
         * @type {og.scene.Node}
         */
        this.parentNode = null;

        this.__staticId = Node.__staticCounter++;
    }

    static get _staticCounter() {
        if (!this._counter && this._counter !== 0) {
            this._counter = 0;
        }
        return this._counter;
    }

    static set _staticCounter(n) {
        this._counter = n;
    }


    /**
     * Adds node to the current hierarchy.
     * @public
     * @type {og.scene.Node}
     */
    addNode(node) {
        if (this.parentNode == null) {
            node.topNode = this;
        }
        else {
            node.topNode = this.topNode;
        }
        node.parentNode = this;
        node._dictionary = this.topNode._dictionary;
        this.childNodes.push(node);
        this.topNode._dictionary[node.name] = node;
    }

    /**
     * Destroy node.
     * @public
     */
    destroy() {
        for (var i = 0; i < this.childNodes.length; i++) {
            this.childNodes[i].destroy();
        }
        this._clear();
    }

    /**
     * Gets node by name in the current.
     * @public
     * @param {string} name - Node name.
     * @return {og.scene.Node} Node object in the current node.
     */
    getNodeByName(name) {
        return this._dictionary[name];
    }

    /**
     * Clear current node.
     * @protected
     */
    _clear() {
        this.name = "";
        this.parentNode = null;
        this.topNode = null;
        this.childNodes.length = 0;
    }
};



/***/ }),

/***/ "./src/og/scene/Planet.js":
/*!********************************!*\
  !*** ./src/og/scene/Planet.js ***!
  \********************************/
/*! exports provided: Planet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Planet", function() { return Planet; });
/* harmony import */ var _math_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/coder.js */ "./src/og/math/coder.js");
/* harmony import */ var _shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shaders/drawnode.js */ "./src/og/shaders/drawnode.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _segment_segmentHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../segment/segmentHelper.js */ "./src/og/segment/segmentHelper.js");
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _proj_EPSG3857_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../proj/EPSG3857.js */ "./src/og/proj/EPSG3857.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl/Framebuffer.js */ "./src/og/webgl/Framebuffer.js");
/* harmony import */ var _utils_GeoImageCreator_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/GeoImageCreator.js */ "./src/og/utils/GeoImageCreator.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../layer/Vector.js */ "./src/og/layer/Vector.js");
/* harmony import */ var _utils_ImageBitmapLoader_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/ImageBitmapLoader.js */ "./src/og/utils/ImageBitmapLoader.js");
/* harmony import */ var _Lock_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../Lock.js */ "./src/og/Lock.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _quadTree_Node_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../quadTree/Node.js */ "./src/og/quadTree/Node.js");
/* harmony import */ var _utils_NormalMapCreator_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/NormalMapCreator.js */ "./src/og/utils/NormalMapCreator.js");
/* harmony import */ var _camera_PlanetCamera_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../camera/PlanetCamera.js */ "./src/og/camera/PlanetCamera.js");
/* harmony import */ var _RenderNode_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./RenderNode.js */ "./src/og/scene/RenderNode.js");
/* harmony import */ var _segment_Segment_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../segment/Segment.js */ "./src/og/segment/Segment.js");
/* harmony import */ var _segment_SegmentLonLat_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../segment/SegmentLonLat.js */ "./src/og/segment/SegmentLonLat.js");
/* harmony import */ var _utils_TerrainWorker_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../utils/TerrainWorker.js */ "./src/og/utils/TerrainWorker.js");
/* harmony import */ var _utils_VectorTileCreator_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../utils/VectorTileCreator.js */ "./src/og/utils/VectorTileCreator.js");
/* harmony import */ var _ellipsoid_wgs84_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../ellipsoid/wgs84.js */ "./src/og/ellipsoid/wgs84.js");
/**
 * @module og/scene/Planet
 */





























const RESOURCES_URL = "";

/**
 * Maximum created nodes count. The more nodes count the more memory usage.
 * @const
 * @type {number}
 * @default
 */
const MAX_NODES = 250;

const EVENT_NAMES = [
    /**
     * Triggered before globe frame begins to render.
     * @event og.scene.Planet#draw
     */
    "draw",

    /**
     * Triggered when layer has added to the planet.
     * @event og.scene.Planet#layeradd
     */
    "layeradd",

    /**
     * Triggered when base layer changed.
     * @event og.scene.Planet#baselayerchange
     */
    "baselayerchange",

    /**
     * Triggered when layer has removed from the planet.
     * @event og.scene.Planet#layerremove
     */
    "layerremove",

    /**
     * Triggered when some layer visibility changed.
     * @event og.scene.Planet#layervisibilitychange
     */
    "layervisibilitychange"
];

/**
 * Main class for rendering planet
 * @class
 * @extends {og.scene.RenderNode}
 * @param {string} name - Planet name(Earth by default)
 * @param {og.Ellipsoid} ellipsoid - Planet ellipsoid(WGS84 by default)
 * @fires og.scene.Planet#draw
 * @fires og.scene.Planet#layeradd
 * @fires og.scene.Planet#baselayerchange
 * @fires og.scene.Planet#layerremove
 * @fires og.scene.Planet#layervisibilitychange
 * @fires og.scene.Planet#geoimageadd
 */
class Planet extends _RenderNode_js__WEBPACK_IMPORTED_MODULE_19__["RenderNode"] {
    constructor(name, ellipsoid) {
        super(name);

        /**
         * @public
         * @type {og.Ellipsoid}
         */
        this.ellipsoid = ellipsoid || _ellipsoid_wgs84_js__WEBPACK_IMPORTED_MODULE_24__["wgs84"];

        /**
         * Squared ellipsoid radius.
         * @protected
         * @type {number}
         */
        this._planetRadius2 = this.ellipsoid.getPolarSize() * this.ellipsoid.getPolarSize();

        /**
         * All layers array.
         * @public
         * @type {Array.<og.layer.Layer>}
         */
        this.layers = [];

        /**
         * Current visible imagery tile layers array.
         * @public
         * @type {Array.<og.layer.Layer>}
         */
        this.visibleTileLayers = [];
        this._visibleTileLayerSlices = [];

        /**
         * Current visible vector layers array.
         * @protected
         * @type {Array.<og.layer.Vector>}
         */
        this.visibleVectorLayers = [];

        /**
         * Vector layers visible nodes with collections.
         * @protected
         * @type {Array.<og.EntityCollection>}
         */
        this._frustumEntityCollections = [];

        /**
         * There is only one base layer on the globe when layer.isBaseLayer is true.
         * @public
         * @type {og.layer.Layer}
         */
        this.baseLayer = null;

        /**
         * Terrain provider.
         * @public
         * @type {og.terrain.Terrain}
         */
        this.terrain = null;

        /**
         * Camera is this.renderer.activeCamera pointer.
         * @public
         * @type {og.PlanetCamera}
         */
        this.camera = null;

        /**
         * Screen mouse pointer projected to planet cartesian position.
         * @public
         * @type {og.math.Vector3}
         */
        this.mousePositionOnEarth = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_10__["Vec3"]();

        this.emptyTexture = null;
        this.transparentTexture = null;
        this.defaultTexture = null;

        /**
         * Current visible minimal zoom index planet segment.
         * @public
         * @type {number}
         */
        this.minCurrZoom = _math_js__WEBPACK_IMPORTED_MODULE_2__["MAX"];

        /**
         * Current visible maximal zoom index planet segment.
         * @public
         * @type {number}
         */
        this.maxCurrZoom = _math_js__WEBPACK_IMPORTED_MODULE_2__["MIN"];

        /**
         * Current view geodetic WGS84 extent.
         * @protected
         * @type {og.Extent}
         */
        this._viewExtentWGS84 = null;

        /**
         * Current view geodetic Web Mercator extent.
         * @protected
         * @type {og.Extent}
         */
        this._viewExtentMerc = null;

        /**
         * @protected
         */
        this._createdNodesCount = 0;

        /**
         * Planet's segments collected for rendering frame.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._renderedNodes = [];

        /**
         * Created nodes cache
         * @protected
         * @type {og.quadTree.Node}
         */
        this._quadTreeNodesCacheMerc = {};

        /**
         * Current visible mercator segments tree nodes array.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._visibleNodes = {};

        /**
         * Current visible north pole nodes tree nodes array.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._visibleNodesNorth = {};

        /**
         * Current visible south pole nodes tree nodes array.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._visibleNodesSouth = {};

        /**
         * Layers activity lock.
         * @public
         * @type {og.idle.Lock}
         */
        this.layerLock = new _Lock_js__WEBPACK_IMPORTED_MODULE_14__["Lock"]();

        /**
         * Terrain providers activity lock.
         * @public
         * @type {og.idle.Lock}
         */
        this.terrainLock = new _Lock_js__WEBPACK_IMPORTED_MODULE_14__["Lock"]();

        /**
         * Layer's transparent colors.
         * @protected
         */
        this._tcolorArr = [];

        /**
         * Height scale factor. 1 - is normal elevation scale.
         * @protected
         * @type {number}
         */
        this._heightFactor = 1.0;

        /**
         * Precomputed indexes array for differrent grid size segments.
         * @protected
         * @type {Array.<Array.<number>>}
         */
        this._indexesCache = [];

        /**
         * Precomputed indexes buffers for differrent grid size segments.
         * @protected
         * @type {Array.<Array.<number>>}
         */
        this._indexesBuffers = [];

        /**
         * Framebuffer for relief. Is null when WEBGL_draw_buffers extension initialized.
         * @protected
         * @type {Object}
         */
        this._heightPickingFramebuffer = null;

        /**
         * Calculates when mouse is moving or planet is rotating.
         * @protected
         * @type {number}
         */
        this._currentDistanceFromPixel = 0;

        /**
         * @protected
         */
        this._viewChanged = true;

        /**
         * Mercator grid tree.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._quadTree = null;

        /**
         * North grid tree.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._quadTreeNorth = null;

        /**
         * South grid tree.
         * @protected
         * @type {og.quadTree.Node}
         */
        this._quadTreeSouth = null;

        /**
         * Night glowing gl texture.
         * @protected
         */
        this._nightTexture = null;

        /**
         * Specular mask gl texture.
         * @protected
         */
        this._specularTexture = null;

        /**
         * True for rendering night glowing texture.
         * @protected
         * @type {boolean}
         */
        this._useNightTexture = true;

        /**
         * True for rendering specular mask texture.
         * @protected
         * @type {boolean}
         */
        this._useSpecularTexture = true;

        /**
         * Segment multiple textures size.(4 - convinient value for the most devices)
         * @const
         * @public
         */
        this.SLICE_SIZE = 4;
        this.SLICE_SIZE_4 = this.SLICE_SIZE * 4;
        this.SLICE_SIZE_3 = this.SLICE_SIZE * 3;

        /**
         * Level of the visible segment detalization.
         * @public
         * @type {number}
         */
        this.RATIO_LOD = 1.12;

        this._diffuseMaterialArr = new Float32Array(this.SLICE_SIZE_3 + 3);
        this._ambientMaterialArr = new Float32Array(this.SLICE_SIZE_3 + 3);
        this._specularMaterialArr = new Float32Array(this.SLICE_SIZE_4 + 4);

        this._tileOffsetArr = new Float32Array(this.SLICE_SIZE_4);
        this._visibleExtentOffsetArr = new Float32Array(this.SLICE_SIZE_4);
        this._transparentColorArr = new Float32Array(this.SLICE_SIZE_4);
        this._pickingColorArr = new Float32Array(this.SLICE_SIZE_3);
        this._samplerArr = new Int32Array(this.SLICE_SIZE);
        this._pickingMaskArr = new Int32Array(this.SLICE_SIZE);

        /**
         * GeoImage creator.
         * @protected
         * @type{og.utils.GeoImageCreator}
         */
        this._geoImageCreator = null;

        this._vectorTileCreator = null;

        this._normalMapCreator = null;

        this._terrainWorker = new _utils_TerrainWorker_js__WEBPACK_IMPORTED_MODULE_22__["TerrainWorker"](12);

        this._imageBitmapLoader = new _utils_ImageBitmapLoader_js__WEBPACK_IMPORTED_MODULE_13__["ImageBitmapLoader"]({ 'maxRequests': 20, 'numWorkers': 5 });

        /**
         * @protected
         */
        this._fnRendering = null;

        this._memKey = new _Lock_js__WEBPACK_IMPORTED_MODULE_14__["Key"]();

        //events initialization
        this.events.registerNames(EVENT_NAMES);
    }

    /**
     * Add the given control to the renderer of the planet scene.
     * @param {og.control.BaseControl} control - Control.
     */
    addControl(control) {
        control.planet = this;
        control.addTo(this.renderer);
    }

    /**
     * Add the given controls array to the renderer of the planet.
     * @param {Array.<og.control.BaseControl>} cArr - Control array.
     */
    addControls(cArr) {
        for (var i = 0; i < cArr.length; i++) {
            this.addControl(cArr[i]);
        }
    }

    /**
     * Return layer by it name
     * @param {string} name - Name of the layer. og.layer.Layer.prototype.name
     * @public
     * @returns {og.layer.Layer} -
     */
    getLayerByName(name) {
        var i = this.layers.length;
        while (i--) {
            if (this.layers[i].name === name)
                return this.layers[i];
        }
    }

    /**
     * Adds the given layer to the planet.
     * @param {og.layer.Layer} layer - Layer object.
     * @public
     */
    addLayer(layer) {
        layer.addTo(this);
    }

    /**
     * Dispatch layer visibility changing event.
     * @param {og.layer.Layer} layer - Changed layer.
     * @protected
     */
    _onLayerVisibilityChanged(layer) {
        this.events.dispatch(this.events.layervisibilitychange, layer);
    }

    /**
     * Adds the given layers array to the planet.
     * @param {Array.<og.layer.Layer>} layers - Layers array.
     * @public
     */
    addLayers(layers) {
        for (var i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    }

    /**
     * Removes the given layer from the planet.
     * @param {og.layer.Layer} layer - Layer to remove.
     * @return {og.layer.Layer|undefined} The removed layer or undefined if the layer was not found.
     * @public
     */
    removeLayer(layer) {
        return layer.remove();
    }

    /**
     *
     * @protected
     * @param {og.layer.Layer} layer - Material layer.
     */
    _clearLayerMaterial(layer) {
        var lid = layer._id;
        this._quadTree.traverseTree(function (node) {
            var mats = node.segment.materials;
            if (mats[lid]) {
                mats[lid].clear();
                mats[lid] = null;
            }
        });
    }

    /**
     * Get the collection of layers associated with this planet.
     * @return {Array.<og.layer.Layer>} Layers array.
     * @public
     */
    getLayers() {
        return this.layers;
    }

    /**
     * Sets base layer coverage to the planet.
     * @param {og.layer.Layer} layer - Layer object.
     * @public
     */
    setBaseLayer(layer) {
        if (this.baseLayer) {
            if (!this.baseLayer.isEqual(layer)) {
                this.baseLayer.setVisibility(false);
                this.baseLayer = layer;
                layer.setVisibility(true);
                this.events.dispatch(this.events.baselayerchange, layer);
            }
        } else {
            this.baseLayer = layer;
            this.baseLayer.setVisibility(true);
            this.events.dispatch(this.events.baselayerchange, layer);
        }
    }

    /**
     * Sets elevation scale. 1.0 is default.
     * @param {number} factor - Elevation scale.
     */
    setHeightFactor(factor) {
        if (this._heightFactor !== factor) {
            this._heightFactor = factor;
            var n = this._quadTree.nodes;
            this._quadTree.nodes = [];
            for (var i = 0; i < n.length; i++) {
                n[i].destroyBranches();
            }
        }
    }

    /**
     * Gets elevation scale.
     * @returns {number} Terrain elevation scale
     */
    getHeightFactor() {
        return this._heightFactor;
    }

    /**
     * Sets terrain provider
     * @public
     * @param {og.terrain.Terrain} terrain - Terrain provider.
     */
    setTerrain(terrain) {
        this.terrain = terrain;
        this.terrain._planet = this;
    }

    /**
     * @virtual
     * @protected
     */
    _initializeShaders() {
        var h = this.renderer.handler;
        if (this.renderer.isMultiFramebufferCompatible()) {
            h.addShaderProgram(_shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__["drawnode_nl"](), true);
            h.addShaderProgram(_shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__["drawnode_wl"](), true);
            this._fnRendering = this._multiframebufferRendering;
        } else {
            h.addShaderProgram(_shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__["drawnode_screen_nl"](), true);
            h.addShaderProgram(_shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__["drawnode_screen_wl"](), true);
            h.addShaderProgram(_shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__["drawnode_colorPicking"](), true);
            h.addShaderProgram(_shaders_drawnode_js__WEBPACK_IMPORTED_MODULE_1__["drawnode_heightPicking"](), true);
            this._fnRendering = this._singleframebufferRendering;

            this.renderer.addPickingCallback(this, this._renderColorPickingFramebufferPASS);

            this._heightPickingFramebuffer = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_8__["Framebuffer"](this.renderer.handler, {
                'width': 320,
                'height': 240
            });
            this._heightPickingFramebuffer.init();
        }
    }

    /**
     * @virtual
     * @public
     */
    initialization() {
        //Initialization indexes table
        var TABLESIZE = _segment_segmentHelper_js__WEBPACK_IMPORTED_MODULE_4__["TABLESIZE"];

        //Iniytialize indexes buffers cache. It takes ~120mb RAM!
        for (var i = 0; i <= TABLESIZE; i++) {
            var c = Math.pow(2, i);
            !this._indexesCache[c] && (this._indexesCache[c] = []);
            for (var j = 0; j <= TABLESIZE; j++) {
                var w = Math.pow(2, j);
                !this._indexesCache[c][w] && (this._indexesCache[c][w] = []);
                for (var k = 0; k <= TABLESIZE; k++) {
                    var n = Math.pow(2, k);
                    !this._indexesCache[c][w][n] && (this._indexesCache[c][w][n] = []);
                    for (var m = 0; m <= TABLESIZE; m++) {
                        var e = Math.pow(2, m);
                        !this._indexesCache[c][w][n][e] && (this._indexesCache[c][w][n][e] = []);
                        for (var q = 0; q <= TABLESIZE; q++) {
                            var s = Math.pow(2, q);

                            //!this._indexesCache[c][w][n][e][s] && (this._indexesCache[c][w][n][e][s] = []);

                            var indexes = _segment_segmentHelper_js__WEBPACK_IMPORTED_MODULE_4__["createSegmentIndexes"](c, [w, n, e, s]);

                            var buffer = null;

                            if (c === w && c === n && c === e && c === s) {
                                buffer = this.renderer.handler.createElementArrayBuffer(indexes, 1);
                            }

                            this._indexesCache[c][w][n][e][s] = {
                                'indexes': indexes,
                                'buffer': buffer
                            };
                        }
                    }
                }
            }
        }

        //create empty textures
        var that = this;
        this.renderer.handler.createDefaultTexture(null, function (t) {
            that.solidTextureOne = t;
            that.solidTextureTwo = t;
        });

        this.transparentTexture = this.renderer.handler.transparentTexture;

        this.camera = this.renderer.activeCamera = new _camera_PlanetCamera_js__WEBPACK_IMPORTED_MODULE_18__["PlanetCamera"](this, {
            eye: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_10__["Vec3"](0, 0, 28000000),
            look: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_10__["Vec3"](0, 0, 0),
            up: new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_10__["Vec3"](0, 1, 0)
        });

        //Creating quad trees nodes
        this._quadTree = new _quadTree_Node_js__WEBPACK_IMPORTED_MODULE_16__["Node"](_segment_Segment_js__WEBPACK_IMPORTED_MODULE_20__["Segment"], this, _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_5__["NW"], null, 0, 0, _Extent_js__WEBPACK_IMPORTED_MODULE_7__["Extent"].createFromArray([-20037508.34, -20037508.34, 20037508.34, 20037508.34]));
        this._quadTreeNorth = new _quadTree_Node_js__WEBPACK_IMPORTED_MODULE_16__["Node"](_segment_SegmentLonLat_js__WEBPACK_IMPORTED_MODULE_21__["SegmentLonLat"], this, _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_5__["NW"], null, 0, 0, _Extent_js__WEBPACK_IMPORTED_MODULE_7__["Extent"].createFromArray([-180, _mercator_js__WEBPACK_IMPORTED_MODULE_3__["MAX_LAT"], 180, 90]));
        this._quadTreeSouth = new _quadTree_Node_js__WEBPACK_IMPORTED_MODULE_16__["Node"](_segment_SegmentLonLat_js__WEBPACK_IMPORTED_MODULE_21__["SegmentLonLat"], this, _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_5__["NW"], null, 0, 0, _Extent_js__WEBPACK_IMPORTED_MODULE_7__["Extent"].createFromArray([-180, -90, 180, _mercator_js__WEBPACK_IMPORTED_MODULE_3__["MIN_LAT"]]));

        this.drawMode = this.renderer.handler.gl.TRIANGLE_STRIP;

        //Applying shaders
        this._initializeShaders();

        this.updateVisibleLayers();

        this.renderer.activeCamera.events.on("viewchange", function (e) {
            this._viewChanged = true;
        }, this);
        this.renderer.events.on("mousemove", function (e) {
            this._viewChanged = true;
        }, this);
        this.renderer.events.on("touchmove", function (e) {
            this._viewChanged = true;
        }, this);

        this.renderer.addPickingCallback(this, this._frustumEntityCollectionPickingCallback);

        //load Earth night glowing texture
        if (this._useNightTexture) {
            var img = new Image();
            img.crossOrigin = '';
            img.onload = function () {
                that._nightTexture = that.renderer.handler.createTexture_mm(this);
            };
            img.src = RESOURCES_URL + "night.png";
        }

        //load water specular mask
        if (this._useSpecularTexture) {
            var img2 = new Image();
            img2.crossOrigin = '';
            img2.onload = function () {
                that._specularTexture = that.renderer.handler.createTexture_l(this);
            };
            img2.src = RESOURCES_URL + "spec.png";
        }

        this._geoImageCreator = new _utils_GeoImageCreator_js__WEBPACK_IMPORTED_MODULE_9__["GeoImageCreator"](this.renderer.handler);

        this._vectorTileCreator = new _utils_VectorTileCreator_js__WEBPACK_IMPORTED_MODULE_23__["VectorTileCreator"](this);

        this._normalMapCreator = new _utils_NormalMapCreator_js__WEBPACK_IMPORTED_MODULE_17__["NormalMapCreator"](this);

        //Loads first nodes for better viewing if you have started on a lower altitude.
        this._preRender();
    }

    _preRender() {
        this._quadTree.traverseNodes();
        this._quadTree.renderNode();
        this._normalMapCreator.drawSingle(this._quadTree.segment);

        this._quadTreeNorth.traverseNodes();
        this._quadTreeNorth.renderNode();

        this._quadTreeSouth.traverseNodes();
        this._quadTreeSouth.renderNode();
    }

    /**
     * Creates default textures first for nirth pole and whole globe and second for south pole.
     * @public
     * @param{Object} param0 -
     * @param{Object} param1 - 
     */
    createDefaultTextures(param0, param1) {
        this.renderer.handler.gl.deleteTexture(this.solidTextureOne);
        this.renderer.handler.gl.deleteTexture(this.solidTextureTwo);
        var that = this;
        this.renderer.handler.createDefaultTexture(param0, function (t) {
            that.solidTextureOne = t;
        });
        this.renderer.handler.createDefaultTexture(param1, function (t) {
            that.solidTextureTwo = t;
        });
    }

    /**
     * Updates attribution lists
     * @public
     */
    updateAttributionsList() {
        var html = "";
        for (var i = 0; i < this.layers.length; i++) {
            var li = this.layers[i];
            if (li._visibility) {
                if (li._attribution.length) {
                    html += "<li>" + li._attribution + "</li>";
                }
            }
        }

        if (this.renderer) {
            if (html.length) {
                this.renderer.div.attributions.style.display = "block";
                this.renderer.div.attributions.innerHTML = "<ul>" + html + "</ul>";
            } else {
                this.renderer.div.attributions.style.display = "none";
                this.renderer.div.attributions.innerHTML = "";
            }
        }
    }

    /**
     * Updates visible layers.
     * @public
     */
    updateVisibleLayers() {

        this.visibleTileLayers = [];
        this.visibleTileLayers.length = 0;

        this.visibleVectorLayers = [];
        this.visibleVectorLayers.length = 0;

        var html = "";
        for (var i = 0; i < this.layers.length; i++) {
            var li = this.layers[i];
            if (li._visibility) {
                if (li._isBaseLayer) {
                    this.baseLayer = li;
                }

                if (li.hasImageryTiles()) {
                    this.visibleTileLayers.push(li);
                }

                if (li.isVector) {
                    this.visibleVectorLayers.push(li);
                }

                if (li._attribution.length) {
                    html += "<li>" + li._attribution + "</li>";
                }
            }
        }

        if (this.renderer) {
            if (html.length) {
                this.renderer.div.attributions.style.display = "block";
                this.renderer.div.attributions.innerHTML = "<ul>" + html + "</ul>";
            } else {
                this.renderer.div.attributions.style.display = "none";
                this.renderer.div.attributions.innerHTML = "";
            }
        }

        this._sortLayers();
    }

    /**
     * Sort visible layer - preparing for rendering.
     * @protected
     */
    _sortLayers() {


        this.visibleVectorLayers.sort(function (a, b) {
            return (a._zIndex - b._zIndex) || (a._height - b._height);
        });


        if (this.visibleTileLayers.length) {
            this.visibleTileLayers.sort(function (a, b) {
                return a._height - b._height || a._zIndex - b._zIndex;
            });

            this._visibleTileLayerSlices = [];
            this._visibleTileLayerSlices.length = 0;
            var k = -1;
            var currHeight = this.visibleTileLayers[0]._height;
            for (var i = 0; i < this.visibleTileLayers.length; i++) {
                if (i % this.SLICE_SIZE === 0 || this.visibleTileLayers[i]._height !== currHeight) {
                    k++;
                    this._visibleTileLayerSlices[k] = [];
                    currHeight = this.visibleTileLayers[i]._height;
                }
                this._visibleTileLayerSlices[k].push(this.visibleTileLayers[i]);
            }
        }
    }

    /**
     * Collects visible quad nodes.
     * @protected
     */
    _collectRenderNodes() {

        //clear first
        this._renderedNodes.length = 0;
        this._renderedNodes = [];

        this._viewExtentWGS84 = null;
        this._viewExtentMerc = null;

        this._visibleNodes = {};
        this._visibleNodesNorth = {};
        this._visibleNodesSouth = {};

        this._frustumEntityCollections.length = 0;
        this._frustumEntityCollections = [];

        this.minCurrZoom = _math_js__WEBPACK_IMPORTED_MODULE_2__["MAX"];
        this.maxCurrZoom = _math_js__WEBPACK_IMPORTED_MODULE_2__["MIN"];

        this._quadTreeNorth.renderTree();
        this._quadTreeSouth.renderTree();


        this._quadTree.renderTree();

        if (this.renderer.activeCamera.slope > 0.72 && this.renderer.activeCamera._lonLat.height < 850000) {
            this.minCurrZoom = this.maxCurrZoom;

            var temp = this._renderedNodes;

            this._renderedNodes = [];

            for (var i = 0; i < temp.length; i++) {
                var ri = temp[i];
                if (ri.segment.tileZoom === this.maxCurrZoom) {
                    this._renderedNodes.push(ri);
                }
            }

            for (i = 0; i < temp.length; i++) {
                var seg = temp[i].segment;
                if (seg._projection.id === _proj_EPSG3857_js__WEBPACK_IMPORTED_MODULE_6__["EPSG3857"].id && seg.tileZoom < this.maxCurrZoom) {
                    seg.node.renderTree(this.maxCurrZoom);
                }
            }
        }
    }

    /**
     * Render node callback.
     * @public
     */
    frame() {

        this._collectRenderNodes();

        //Here is the planet node dispatches a draw event before rendering begins.
        this.events.dispatch(this.events.draw, this);

        this.renderer.activeCamera.prepareFrame();

        this.transformLights();

        this._normalMapCreator.frame();

        //Here is the applyMaterial->loadMaterial call
        this._fnRendering();

        //Creates geoImages textures.
        this._geoImageCreator.frame();

        //free memory
        if (this._createdNodesCount > MAX_NODES) {
            this.memClear();
        }
    }

    /**
     * @virtual
     * @protected
     */
    _multiframebufferRendering() {
        this._multiRenderNodesPASS();
        this._renderVectorLayersPASS();
    }

    /**
     * @virtual
     * @protected
     */
    _singleframebufferRendering() {
        this._renderScreenNodesPASS();
        this._renderHeightPickingFramebufferPASS();
        this._renderVectorLayersPASS();
    }

    /**
     * @protected
     */
    _renderScreenNodesPASS() {

        var sh;
        var renderer = this.renderer;
        var h = renderer.handler;
        var gl = h.gl;

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        if (this.lightEnabled) {
            h.shaderPrograms.drawnode_screen_wl.activate();
            sh = h.shaderPrograms.drawnode_screen_wl._program,
                shu = sh.uniforms;

            gl.uniform4fv(shu.lightsPositions._pName, this._lightsTransformedPositions);

            gl.uniformMatrix3fv(shu.normalMatrix._pName, false, renderer.activeCamera._normalMatrix._m);
            gl.uniformMatrix4fv(shu.viewMatrix._pName, false, renderer.activeCamera._viewMatrix._m);
            gl.uniformMatrix4fv(shu.projectionMatrix._pName, false, renderer.activeCamera._projectionMatrix._m);

            //bind night glowing material
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE);
            gl.bindTexture(gl.TEXTURE_2D, (this.camera._lonLat.height > 329958.0) && (this._nightTexture || this.transparentTexture) || this.transparentTexture);
            gl.uniform1i(shu.nightTexture._pName, this.SLICE_SIZE);

            //bind specular material
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE + 1);
            gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
            gl.uniform1i(shu.specularTexture._pName, this.SLICE_SIZE + 1);

            var b = this.baseLayer;
            if (b) {
                this._diffuseMaterialArr[0] = b.diffuse.x;
                this._diffuseMaterialArr[1] = b.diffuse.y;
                this._diffuseMaterialArr[2] = b.diffuse.z;

                this._ambientMaterialArr[0] = b.ambient.x;
                this._ambientMaterialArr[1] = b.ambient.y;
                this._ambientMaterialArr[2] = b.ambient.z;

                this._specularMaterialArr[0] = b.specular.x;
                this._specularMaterialArr[1] = b.specular.y;
                this._specularMaterialArr[2] = b.specular.z;
                this._specularMaterialArr[3] = b.shininess;
            } else {
                this._diffuseMaterialArr[0] = 0.89;
                this._diffuseMaterialArr[1] = 0.9;
                this._diffuseMaterialArr[2] = 0.83;

                this._ambientMaterialArr[0] = 0.0;
                this._ambientMaterialArr[1] = 0.0;
                this._ambientMaterialArr[2] = 0.0;

                this._specularMaterialArr[0] = 0.0003;
                this._specularMaterialArr[1] = 0.00012;
                this._specularMaterialArr[2] = 0.00001;
                this._specularMaterialArr[3] = 20.0;
            }
        } else {
            h.shaderPrograms.drawnode_screen_nl.activate();
            sh = h.shaderPrograms.drawnode_screen_nl._program;
            gl.uniformMatrix4fv(sh.uniforms.projectionViewMatrix._pName, false, renderer.activeCamera._projectionViewMatrix._m);
        }

        //draw planet's nodes
        var rn = this._renderedNodes,
            sl = this._visibleTileLayerSlices;

        var i = rn.length;
        while (i--) {
            rn[i].segment._screenRendering(sh, sl[0], 0);
        }

        gl.enable(gl.POLYGON_OFFSET_FILL);
        for (j = 1; j < sl.length; j++) {
            i = rn.length;
            gl.polygonOffset(0, -j);
            while (i--) {
                rn[i].segment._screenRendering(sh, sl[j], j, this.transparentTexture, true);
            }
        }
        gl.disable(gl.POLYGON_OFFSET_FILL);

        gl.disable(gl.BLEND);
    };

    /**
     * @protected
     */
    _renderHeightPickingFramebufferPASS() {

        this._heightPickingFramebuffer.activate();

        var sh;
        var renderer = this.renderer;
        var h = renderer.handler;
        var gl = h.gl;

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.enable(gl.CULL_FACE);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        h.shaderPrograms.drawnode_heightPicking.activate();
        sh = h.shaderPrograms.drawnode_heightPicking._program;
        gl.uniformMatrix4fv(sh.uniforms.projectionViewMatrix._pName, false, renderer.activeCamera._projectionViewMatrix._m);

        h.gl.uniform3fv(sh.uniforms.cameraPosition._pName, renderer.activeCamera.eye.toVec());

        //draw planet's nodes
        var rn = this._renderedNodes,
            sl = this._visibleTileLayerSlices;

        var i = rn.length;
        while (i--) {
            rn[i].segment._heightPickingRendering(sh, sl[0], 0);
        }

        gl.enable(gl.POLYGON_OFFSET_FILL);
        for (j = 1; j < sl.length; j++) {
            i = rn.length;
            gl.polygonOffset(0, -j);
            while (i--) {
                rn[i].segment._heightPickingRendering(sh, sl[j], j, this.transparentTexture, true);
            }
        }
        gl.disable(gl.POLYGON_OFFSET_FILL);

        gl.disable(gl.BLEND);

        this._heightPickingFramebuffer.deactivate();
    }

    /**
     * @protected
     */
    _renderColorPickingFramebufferPASS() {
        var sh;
        var renderer = this.renderer;
        var h = renderer.handler;
        var gl = h.gl;

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        //gl.polygonOffset(0, 0);
        //gl.enable(gl.DEPTH_TEST);

        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0, -637000);

        h.shaderPrograms.drawnode_colorPicking.activate();
        sh = h.shaderPrograms.drawnode_colorPicking._program;
        gl.uniformMatrix4fv(sh.uniforms.projectionViewMatrix._pName, false, renderer.activeCamera._projectionViewMatrix._m);

        //draw planet's nodes
        var rn = this._renderedNodes,
            sl = this._visibleTileLayerSlices;

        var i = rn.length;
        while (i--) {
            rn[i].segment._colorPickingRendering(sh, sl[0], 0);
        }

        gl.enable(gl.POLYGON_OFFSET_FILL);
        for (j = 1; j < sl.length; j++) {
            i = rn.length;
            gl.polygonOffset(0, -637000 - j);
            while (i--) {
                rn[i].segment._colorPickingRendering(sh, sl[j], j, this.transparentTexture, true);
            }
        }
        gl.disable(gl.POLYGON_OFFSET_FILL);

        gl.disable(gl.BLEND);
    }


    /**
     * @protected
     */
    _multiRenderNodesPASS() {

        var sh, shu;
        var renderer = this.renderer;
        var h = renderer.handler;
        var gl = h.gl;

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        if (this.lightEnabled) {
            h.shaderPrograms.drawnode_wl.activate();
            sh = h.shaderPrograms.drawnode_wl._program;
            shu = sh.uniforms;

            gl.uniform4fv(shu.lightsPositions._pName, this._lightsTransformedPositions);

            gl.uniformMatrix3fv(shu.normalMatrix._pName, false, renderer.activeCamera._normalMatrix._m);
            gl.uniformMatrix4fv(shu.viewMatrix._pName, false, renderer.activeCamera._viewMatrix._m);
            gl.uniformMatrix4fv(shu.projectionMatrix._pName, false, renderer.activeCamera._projectionMatrix._m);

            //bind night glowing material
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE * 2);
            gl.bindTexture(gl.TEXTURE_2D, (this.camera._lonLat.height > 329958.0) && (this._nightTexture || this.transparentTexture) || this.transparentTexture);
            gl.uniform1i(shu.nightTexture._pName, this.SLICE_SIZE * 2);

            //bind specular material
            gl.activeTexture(gl.TEXTURE0 + this.SLICE_SIZE * 2 + 1);
            gl.bindTexture(gl.TEXTURE_2D, this._specularTexture || this.transparentTexture);
            gl.uniform1i(shu.specularTexture._pName, this.SLICE_SIZE * 2 + 1);

            var b = this.baseLayer;
            if (b) {
                this._diffuseMaterialArr[0] = b.diffuse.x;
                this._diffuseMaterialArr[1] = b.diffuse.y;
                this._diffuseMaterialArr[2] = b.diffuse.z;

                this._ambientMaterialArr[0] = b.ambient.x;
                this._ambientMaterialArr[1] = b.ambient.y;
                this._ambientMaterialArr[2] = b.ambient.z;

                this._specularMaterialArr[0] = b.specular.x;
                this._specularMaterialArr[1] = b.specular.y;
                this._specularMaterialArr[2] = b.specular.z;
                this._specularMaterialArr[3] = b.shininess;
            } else {
                this._diffuseMaterialArr[0] = 0.89;
                this._diffuseMaterialArr[1] = 0.9;
                this._diffuseMaterialArr[2] = 0.83;

                this._ambientMaterialArr[0] = 0.0;
                this._ambientMaterialArr[1] = 0.0;
                this._ambientMaterialArr[2] = 0.0;

                this._specularMaterialArr[0] = 0.0003;
                this._specularMaterialArr[1] = 0.00012;
                this._specularMaterialArr[2] = 0.00001;
                this._specularMaterialArr[3] = 20.0;
            }
        } else {
            h.shaderPrograms.drawnode_nl.activate();
            sh = h.shaderPrograms.drawnode_nl._program;
            gl.uniformMatrix4fv(sh.uniforms.projectionViewMatrix._pName, false, renderer.activeCamera._projectionViewMatrix._m);
        }

        h.gl.uniform3fv(sh.uniforms.cameraPosition._pName, renderer.activeCamera.eye.toVec());

        //draw planet's nodes
        var rn = this._renderedNodes,
            sl = this._visibleTileLayerSlices;

        var i = rn.length;
        while (i--) {
            rn[i].segment._multiRendering(sh, sl[0]);
        }

        gl.enable(gl.POLYGON_OFFSET_FILL);
        for (let j = 1; j < sl.length; j++) {
            i = rn.length;
            gl.polygonOffset(0, -j);
            while (i--) {
                rn[i].segment._multiRendering(sh, sl[j], this.transparentTexture, true);
            }
        }

        gl.disable(gl.POLYGON_OFFSET_FILL);

        gl.disable(gl.BLEND);
    }

    /**
     * Vector layers rendering
     * @protected
     */
    _renderVectorLayersPASS() {

        var i = this.visibleVectorLayers.length;
        while (i--) {
            this.visibleVectorLayers[i].update();
        }

        //3d entities(billnoards, labesl, shapes etc.) rendering
        this.drawEntityCollections(this._frustumEntityCollections);

        //Vector tiles rasteriazation
        this._vectorTileCreator.frame();
    }

    /**
     * Vector layers picking pass.
     * @protected
     */
    _frustumEntityCollectionPickingCallback() {
        this.drawPickingEntityCollections(this._frustumEntityCollections);
    }

    /**
     * Starts clear memory thread.
     * @public
     */
    memClear() {
        this.layerLock.lock(this._memKey);
        this.terrainLock.lock(this._memKey);
        this._normalMapCreator.lock(this._memKey);

        this._normalMapCreator.clear();
        this.terrain.abortLoading();

        var that = this;
        setTimeout(function () {
            that._quadTree.clearTree();
            that._quadTreeNorth.clearTree();
            that._quadTreeSouth.clearTree();

            that.layerLock.free(that._memKey);
            that.terrainLock.free(that._memKey);
            that._normalMapCreator.free(that._memKey);
        }, 0);

        this._createdNodesCount = 0;
    }

    /**
     * Returns ray vector hit ellipsoid coordinates.
     * If the ray doesn't hit ellipsoit returns null.
     * @public
     * @param {og.math.Ray} ray - Ray 3d.
     * @returns {og.math.Vector3} -
     */
    getRayIntersectionEllipsoid(ray) {
        return this.ellipsoid.hitRay(ray.origin, ray.direction);
    }

    /**
     * Returns 2d screen coordanates projection point to the planet ellipsoid 3d coordinates.
     * @public
     * @param {og.math.Pixel} px - 2D sreen coordinates.
     * @returns {og.math.Vector3} -
     */
    getCartesianFromPixelEllipsoid(px) {
        var cam = this.renderer.activeCamera;
        return this.ellipsoid.hitRay(cam.eye, cam.unproject(px.x, px.y));
    }

    /**
     * Returns 2d screen coordanates projection point to the planet ellipsoid geographical coordinates.
     * @public
     * @param {og.math.Pixel} px - 2D screen coordinates.
     * @returns {og.LonLat} -
     */
    getLonLatFromPixelEllipsoid(px) {
        var coords = this.getCartesianFromPixelEllipsoid(px);
        if (coords) {
            return this.ellipsoid.cartesianToLonLat(coords);
        }
        return null;
    }

    /**
     * Returns 3d cartesian coordinates on the relief planet by mouse cursor
     * position or null if mouse cursor is outside the planet.
     * @public
     * @param {Boolean} [force=false] - Force framebuffer rendering.
     * @returns {og.math.Vector3} -
     */
    getCartesianFromMouseTerrain(force) {
        var ms = this.renderer.events.mouseState;
        var distance = this.getDistanceFromPixel(ms, force);
        if (distance) {
            return ms.direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
        }
        return null;
    }

    /**
     * Returns 3d cartesian coordinates on the relief planet by 2d screen coordinates.
     * position or null if input coordinates is outside the planet.
     * @public
     * @param {og.math.Vector2} px - Pixel screen 2d coordinates.
     * @param {Boolean} [force=false] - Force framebuffer rendering.
     * @returns {og.math.Vector3} -
     */
    getCartesianFromPixelTerrain(px, force) {
        var distance = this.getDistanceFromPixel(px, force);
        if (distance) {
            var direction = this.renderer.activeCamera.unproject(px.x, px.y);
            return direction.scaleTo(distance).addA(this.renderer.activeCamera.eye);
        }
        return null;
    }

    /**
     * Returns geographical coordinates on the relief planet by 2d screen coordinates.
     * position or null if input coordinates is outside the planet.
     * @public
     * @param {og.math.Vector2} px - Pixel screen 2d coordinates.
     * @param {Boolean} [force=false] - Force framebuffer rendering.
     * @returns {og.LonLat} -
     */
    getLonLatFromPixelTerrain(px, force) {
        var coords = this.getCartesianFromPixelTerrain(px, force);
        if (coords) {
            return this.ellipsoid.cartesianToLonLat(coords);
        }
        return null;
    }

    /**
     * Returns projected 2d screen coordinates by 3d cartesian coordiantes.
     * @public
     * @param {og.math.Vector3} coords - Cartesian coordinates.
     * @returns {og.math.Vector2} -
     */
    getPixelFromCartesian(coords) {
        return this.renderer.activeCamera.project(coords);
    }

    /**
     * Returns projected 2d screen coordinates by geographical coordinates.
     * @public
     * @param {og.LonLat} lonlat - Geographical coordinates.
     * @returns {og.math.Vector2} -
     */
    getPixelFromLonLat(lonlat) {
        var coords = this.ellipsoid.lonLatToCartesian(lonlat);
        if (coords)
            return this.renderer.activeCamera.project(coords);
        return null;
    }

    /**
     * Returns distance from active camera to the the planet ellipsoid
     * coordiantes unprojected by 2d screen coordiantes, or null if screen coordinates outside the planet.
     * @public
     * @param {og.math.Vector2} px - Screen coordinates.
     * @returns {number} -
     */
    getDistanceFromPixelEllipsoid(px) {
        var coords = this.getCartesianFromPixelEllipsoid(px);
        return coords ? coords.distance(this.renderer.activeCamera.eye) : null;
    }

    /**
     * Returns distance from active camera to the the relief planet coordiantes unprojected
     * by 2d screen coordiantes, or null if screen coordinates outside the planet.
     * If screen coordinates inside the planet but relief is not exists in the
     * point than function returns distance to the planet ellipsoid.
     * @public
     * @param {og.math.Vector2} px - Screen coordinates.
     * @param {Boolean} [force=false] - Force framebuffer rendering.
     * @returns {number} -
     */
    getDistanceFromPixel(px, force) {
        if (this._viewChanged || force) {
            this._viewChanged = false;
            var cnv = this.renderer.handler.canvas;
            var color =
                this.renderer._drawBuffersExtension &&
                _math_Vec4_js__WEBPACK_IMPORTED_MODULE_11__["Vec4"].fromVec(this.renderer.sceneFramebuffer.readPixel(px.x / cnv.width, (cnv.height - px.y) / cnv.height, 2)) ||
                _math_Vec4_js__WEBPACK_IMPORTED_MODULE_11__["Vec4"].fromVec(this._heightPickingFramebuffer.readPixel(px.x / cnv.width, (cnv.height - px.y) / cnv.height));
            if (!(color.x | color.y | color.z)) {
                return this._currentDistanceFromPixel = this.getDistanceFromPixelEllipsoid(px);
            }
            color.w = 0.0;
            this._currentDistanceFromPixel = _math_coder_js__WEBPACK_IMPORTED_MODULE_0__["decodeFloatFromRGBA"](color);
            return this._currentDistanceFromPixel;
        }
        return this._currentDistanceFromPixel;
    }

    /**
     * Sets camera to the planet geographical extent.
     * @public
     * @param {og.Extent} extent - Geographical extent.
     */
    viewExtent(extent) {
        this.renderer.activeCamera.viewExtent(extent);
    }

    /**
     * Sets camera to the planet geographical extent.
     * @public
     * @param {Array.<number,number,number,number>} extentArr - Geographical extent array,
     * where index 0 - southwest longitude, 1 - latitude southwest, 2 - longitude northeast, 3 - latitude northeast.
     */
    viewExtentArr(extentArr) {
        this.renderer.activeCamera.viewExtent(
            new _Extent_js__WEBPACK_IMPORTED_MODULE_7__["Extent"](new _LonLat_js__WEBPACK_IMPORTED_MODULE_15__["LonLat"](extentArr[0], extentArr[1]),
                new _LonLat_js__WEBPACK_IMPORTED_MODULE_15__["LonLat"](extentArr[2], extentArr[3])));
    }

    /**
     * Gets current viewing geographical extent.
     * @public
     * @returns {og.Extent} -
     */
    getViewExtent() {
        if (this._viewExtentMerc) {
            var ne = this._viewExtentMerc.northEast.inverseMercator(),
                sw = this._viewExtentMerc.southWest.inverseMercator();
            if (this._viewExtentWGS84) {
                var e = this._viewExtentWGS84;
                if (e.northEast.lon > ne.lon) {
                    ne.lon = e.northEast.lon;
                }
                if (e.northEast.lat > ne.lat) {
                    ne.lat = e.northEast.lat;
                }
                if (e.southWest.lon < sw.lon) {
                    sw.lon = e.southWest.lon;
                }
                if (e.southWest.lat < sw.lat) {
                    sw.lat = e.southWest.lat;
                }
            }
            return new _Extent_js__WEBPACK_IMPORTED_MODULE_7__["Extent"](sw, ne);
        } else if (this._viewExtentWGS84) {
            return this._viewExtentWGS84;
        }
    }

    /**
     * Sets camera to the planet geographical position.
     * @public
     * @param {og.LonLat} lonlat - New geographical position.
     * @param {og.math.Vector3} [up] - Camera UP vector.
     */
    viewLonLat(lonlat, up) {
        this.renderer.activeCamera.setLonLat(lonlat, up);
    }

    /**
     * Fly camera to the planet geographical extent.
     * @public
     * @param {og.Extent} extent - Geographical extent.
     * @param {og.math.Vector3} [up] - Camera UP vector on the end of a flying.
     */
    flyExtent(extent, up) {
        this.renderer.activeCamera.flyExtent(extent, up);
    }

    /**
     * Fly camera to the new point.
     * @public
     * @param {og.math.Vector3} cartesian - Fly coordiantes.
     * @param {og.math.Vector3} [look] - Camera "look at" point.
     * @param {og.math.Vector3} [up] - Camera UP vector on the end of a flying.
     */
    flyCartesian(cartesian, look, up) {
        this.renderer.activeCamera.flyCartesian(cartesian, look, up);
    }

    /**
     * Fly camera to the new geographical position.
     * @public
     * @param {og.LonLat} lonlat - Fly geographical coordiantes.
     * @param {og.math.Vector3} [look] - Camera "look at" point on the end of a flying.
     * @param {og.math.Vector3} [up] - Camera UP vector on the end of a flying.
     */
    flyLonLat(lonlat, look, up) {
        this.renderer.activeCamera.flyLonLat(lonlat, look, up);
    }

    /**
     * Breaks the flight.
     * @public
     */
    stopFlying() {
        this.renderer.activeCamera.stopFlying();
    }

    updateBillboardsTexCoords() {
        for (var i = 0; i < this.entityCollections.length; i++) {
            this.entityCollections[i].billboardHandler.refreshTexCoordsArr();
        }

        var readyCollections = {};
        for (var i = 0; i < this.layers.length; i++) {
            var li = this.layers[i];
            if (li instanceof _layer_Vector_js__WEBPACK_IMPORTED_MODULE_12__["Vector"]) {
                li.each(function (e) {
                    if (e._entityCollection && !readyCollections[e._entityCollection.id]) {
                        e._entityCollection.billboardHandler.refreshTexCoordsArr();
                        readyCollections[e._entityCollection.id] = true;
                    }
                });
            }
        }
    }
};




/***/ }),

/***/ "./src/og/scene/RenderNode.js":
/*!************************************!*\
  !*** ./src/og/scene/RenderNode.js ***!
  \************************************/
/*! exports provided: RenderNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderNode", function() { return RenderNode; });
/* harmony import */ var _BaseNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseNode.js */ "./src/og/scene/BaseNode.js");
/* harmony import */ var _Events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Events.js */ "./src/og/Events.js");
/* harmony import */ var _utils_FontAtlas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/FontAtlas.js */ "./src/og/utils/FontAtlas.js");
/* harmony import */ var _utils_TextureAtlas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/TextureAtlas.js */ "./src/og/utils/TextureAtlas.js");
/**
 * @module og/scene/RenderNode
 */








/**
 * Render node is a logical part of a render mechanism. Represents scene rendering.
 * Forexample one scene node for rendering the Earth, another one for rendering the Moon, another node for rendering stars etc.
 * Each render node has own model view space defined with matrices(scale, rotation, translation, transformation).
 * There are collections of ligh sources, entities and so on in the node.
 * Access to the node is renderer.renderNodes["Earth"]
 * @class
 * @extends {og.scene.Node}
 * @param {string} name - Node name.
 */
class RenderNode extends _BaseNode_js__WEBPACK_IMPORTED_MODULE_0__["BaseNode"] {
    constructor(name) {
        super(name);

        /**
         * Renderer that calls frame() callback.
         * @public
         * @type {og.Renderer}
         */
        this.renderer = null;

        this.drawMode = null;

        /** Show rendering.
         * @public
         */
        this.show = true;

        this._isActive = true;

        /**
         * Lighting calculations.
         * @public
         * @type {boolean}
         */
        this.lightEnabled = false;

        /**
         * Point light array.
         * @private
         * @type {Array.<og.LightSource>}
         */
        this._lights = [];
        this._lightsTransformedPositions = [];
        this._lightsParamsv = [];
        this._lightsParamsf = [];
        this._lightsNames = [];

        /**
         * Entity collection array.
         * @public
         * @type {Array.<og.EntityCollection>}
         */
        this.entityCollections = [];

        /**
         * Texture atlas for the billboards images. One atlas per node.
         * @protected
         * @type {og.utils.TextureAtlas}
         */
        this.billboardsTextureAtlas = new _utils_TextureAtlas_js__WEBPACK_IMPORTED_MODULE_3__["TextureAtlas"]();

        /**
         * Texture font atlas for the font families and styles. One atlas per node.
         * @public
         * @type {og.utils.FontAtlas}
         */
        this.fontAtlas = new _utils_FontAtlas_js__WEBPACK_IMPORTED_MODULE_2__["FontAtlas"]();

        /**
         * Render node events.
         * @public
         * @type {og.Events}
         */
        this.events = new _Events_js__WEBPACK_IMPORTED_MODULE_1__["Events"]();
    }

    /**
     * Assign render node with renderer.
     * @public
     * @param {og.Renderer} renderer - Redner node's renderer.
     */
    assignRenderer(renderer) {
        this.renderer = renderer;
        this.billboardsTextureAtlas.assignHandler(renderer.handler);
        this.fontAtlas.assignHandler(renderer.handler);
        renderer.addPickingCallback(this, this._entityCollectionPickingCallback);

        for (var i = 0; i < this.entityCollections.length; i++) {
            this.entityCollections[i].setRenderer(renderer);
        }

        this.initialization && this.initialization();
    }

    /**
     * Adds entity collection.
     * @public
     * @param {og.EntityCollection} entityCollection - Entity collection.
     * @param {boolean} [isHidden] - If it's true that this collection has specific rendering.
     * @returns {og.scene.RenderNode}
     */
    addEntityCollection(entityCollection, isHidden) {
        entityCollection.addTo(this, isHidden);
        return this;
    }

    /**
     * Removes entity collection.
     * @public
     * @param {og.EntityCollection} entityCollection - Entity collection for remove.
     */
    removeEntityCollection(entityCollection) {
        entityCollection.remove();
    }

    /**
     * Adds point light source.
     * @public
     * @param {og.LightSource} light - Light source.
     * @returns {og.scene.RenderNode}
     */
    addLight(light) {
        light.addTo(this);
        return this;
    }

    /**
     * Gets light object by its name.
     * @public
     * @param {string} name - Point light name.
     * @returns {og.LightSource}
     */
    getLightByName(name) {
        var li = this._lightsNames.indexOf(name);
        return this._lights[li];
    }

    /**
     * Removes light source.
     * @public
     * @param {og.LightSource} light - Light source object.
     */
    removeLight(light) {
        light.remove();
    }

    /**
     * Calls render frame node's callback. Used in renderer.
     * @public
     */
    drawNode() {
        this._isActive && this._drawNodes();
    }

    /**
     * Gets render node activity.
     * @public
     * @returns {boolean}
     */
    isActive() {
        return this._isActive;
    }

    /**
     * Rendering activation.
     * @public
     * @param {boolean} isActive - Activation flag.
     */
    setActive(isActive) {
        this._isActive = isActive;
        for (var i = 0; i < this.childNodes.length; i++) {
            this.childNodes[i].setActive(isActive);
        }
    }

    /**
     * @public
     */
    setDrawMode(mode) {
        this.drawMode = mode;
        for (var i = 0; i < this.childNodes.length; i++) {
            this.childNodes[i].setDrawMode(mode);
        }
    }

    /**
     * IMPORTANT: This function have to be called manualy in each render node frame callback, before drawing scene geometry.
     * @public
     */
    transformLights() {
        var r = this.renderer;
        for (var i = 0; i < this._lights.length; i++) {
            var ii = i * 4;
            var tp;
            if (this._lights[i].directional) {
                tp = r.activeCamera._normalMatrix.mulVec(this._lights[i]._position);
                this._lightsTransformedPositions[ii + 3] = 0;
            } else {
                tp = r.activeCamera._viewMatrix.mulVec3(this._lights[i]._position);
                this._lightsTransformedPositions[ii + 3] = 1;
            }
            this._lightsTransformedPositions[ii] = tp.x;
            this._lightsTransformedPositions[ii + 1] = tp.y;
            this._lightsTransformedPositions[ii + 2] = tp.z;
        }
    }

    updateBillboardsTexCoords() {
        for (var i = 0; i < this.entityCollections.length; i++) {
            this.entityCollections[i].billboardHandler.refreshTexCoordsArr();
        }
    }

    /**
     * @private
     */
    _drawNodes() {
        for (var i = 0; i < this.childNodes.length; i++) {
            if (this.childNodes[i]._isActive)
                this.childNodes[i]._drawNodes();
        }

        if (this.show) {
            if (this.frame) {
                //this.lightEnabled && this.transformLights();
                this.frame();
            }
            this.drawEntityCollections(this.entityCollections);
        }
    }

    /**
     * @public
     */
    drawEntityCollections(ec) {
        if (ec.length) {
            var gl = this.renderer.handler.gl;

            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
            gl.disable(gl.CULL_FACE);

            //Z-buffer offset
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(0, -637000);

            //billboards pass
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.billboardsTextureAtlas.texture);

            var i = ec.length;
            while (i--) {
                var eci = ec[i];
                if (eci._animatedOpacity) {
                    //first begin draw event
                    eci.events.dispatch(eci.events.draw, eci);
                    eci.billboardHandler.draw();
                }
            }

            //labels pass
            var fa = this.fontAtlas.atlasesArr;
            for (i = 0; i < fa.length; i++) {
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, fa[i].texture);
            }

            i = ec.length;
            while (i--) {
                ec[i]._animatedOpacity && ec[i].labelHandler.draw();
            }

            //polyline pass
            i = ec.length;
            while (i--) {
                ec[i]._animatedOpacity && ec[i].polylineHandler.draw();
            }

            //Z-buffer offset
            gl.polygonOffset(0, 0);

            gl.disable(gl.POLYGON_OFFSET_FILL);
            gl.enable(gl.CULL_FACE);

            //shapes pass
            i = ec.length;
            while (i--) {
                var eci = ec[i];
                if (eci._animatedOpacity) {
                    eci.shapeHandler.draw();
                    //post draw event
                    eci.events.dispatch(eci.events.drawend, eci);
                }
            }

            //pointClouds pass
            i = ec.length;
            while (i--) {
                ec[i]._animatedOpacity && ec[i].pointCloudHandler.draw();
            }

        }
    }

    /**
     * @public
     */
    drawPickingEntityCollections(ec) {
        if (ec.length) {

            var gl = this.renderer.handler.gl;

            gl.disable(gl.CULL_FACE);

            //Z-buffer offset
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(0, -637000);

            //billoard pass
            var i = ec.length;
            while (i--) {
                ec[i]._visibility && ec[i].billboardHandler.drawPicking();
            }

            //label pass
            i = ec.length;
            while (i--) {
                ec[i]._visibility && ec[i].labelHandler.drawPicking();
            }

            gl.polygonOffset(0, 0);

            gl.disable(gl.POLYGON_OFFSET_FILL);
            gl.enable(gl.CULL_FACE);

            ////polylines pass
            //i = ec.length;
            //while (i--) {
            //    ec[i]._visibility && ec[i].polylineHandler.drawPicking();
            //}

            ////shapes pass
            //i = ec.length;
            //while (i--) {
            //    ec[i]._visibility && ec[i].shapeHandler.drawPicking();
            //}

            ////pointClouds pass
            //i = ec.length;
            //while (i--) {
            //    ec[i]._visibility && ec[i].pointCloudHandler.drawPicking();
            //}
        }
    }

    /**
     * Picking entity frame callback
     * @private
     */
    _entityCollectionPickingCallback() {
        this.drawPickingEntityCollections(this.entityCollections);
    }
};



/***/ }),

/***/ "./src/og/segment/Segment.js":
/*!***********************************!*\
  !*** ./src/og/segment/Segment.js ***!
  \***********************************/
/*! exports provided: Segment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Segment", function() { return Segment; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _bv_Box_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bv/Box.js */ "./src/og/bv/Box.js");
/* harmony import */ var _proj_EPSG3857_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj/EPSG3857.js */ "./src/og/proj/EPSG3857.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./src/og/layer/Layer.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _segmentHelper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./segmentHelper.js */ "./src/og/segment/segmentHelper.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Ray.js */ "./src/og/math/Ray.js");
/* harmony import */ var _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../bv/Sphere.js */ "./src/og/bv/Sphere.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/**
 * @module og/segment/Segment
 */

'use sctrict';














var _RenderingSlice = function (p) {
    this.layers = [];
    this.tileOffsetArr = new Float32Array(p.SLICE_SIZE_4);
    this.visibleExtentOffsetArr = new Float32Array(p.SLICE_SIZE_4);
    this.transparentColorArr = new Float32Array(p.SLICE_SIZE_4);

    this.clear = function () {
        this.layers.length = 0;
        this.tileOffsetArr.length = 0;
        this.visibleExtentOffsetArr.length = 0;
        this.transparentColorArr.length = 0;

        this.layers = null;
        this.tileOffsetArr = null;
        this.visibleExtentOffsetArr = null;
        this.transparentColorArr = null;
    };
};

/**
 * Planet segment Web Mercator tile class that stored and rendered with quad tree.
 * @class
 * @param {og.quadTree.Node} node - Segment node.
 * @param {og.scene.Planet} planet - Current planet scene.
 * @param {Number} tileZoom - Zoom index.
 * @param {og.Extent} extent - Segment extent.
 */
const Segment = function (node, planet, tileZoom, extent) {

    /**
     * Quad tree node of the segment.
     * @type {og.quadTree.Node}
     */
    this.node = node;

    /**
     * Planet pointer.
     * @type {pg.node.RenderNode}
     */
    this.planet = planet;

    /**
     * WebGl handler pointer.
     * @type {og.webgl.Handler}
     */
    this.handler = planet.renderer.handler;

    /**
     * Segment bounding box.
     * @type {og.bv.Box}
     */
    this.bbox = new _bv_Box_js__WEBPACK_IMPORTED_MODULE_3__["Box"]();

    /**
     * Segment bounding box.
     * @type {og.bv.Sphere}
     */
    this.bsphere = new _bv_Sphere_js__WEBPACK_IMPORTED_MODULE_10__["Sphere"]();

    /**
     * Geographical extent.
     * @type {og.Extent}
     */
    this._extent = extent;

    /**
     * Vertices grid size.
     * @type {number}
     */
    this.gridSize = planet.terrain.gridSizeByZoom[tileZoom];

    /**
     * Tile zoom index.
     * @type {number}
     */
    this.tileZoom = tileZoom;

    /**
     * Horizontal tile index.
     * @type {number}
     */
    this.tileX = null;

    /**
     * Vertical tile index.
     * @type {number}
     */
    this.tileY = null;

    this.tileIndex = "";

    this._assignTileIndexes();

    /**
     * Texture materials array.
     * @type {Array.<og.planetSegment.Material>}
     */
    this.materials = [];

    /**
     * Segment is ready for rendering.
     * @type {boolean}
     */
    this.ready = false;

    /**
     * Segment is ready to create plain vertices.
     * @type {boolean}
     */
    this.initialized = false;

    /**
     * Normal map is allready made.
     * @type {boolean}
     */
    this.normalMapReady = false;

    /**
     * Parent normal map is made allready(optimization parameter).
     * @type {boolean}
     */
    this.parentNormalMapReady = false;

    /**
     * Terrain is allready applied flag.
     * @type {boolean}
     */
    this.terrainReady = false;

    /**
     * Terrain is loading now flag.
     * @type {boolean}
     */
    this.terrainIsLoading = false;

    /**
     * Terrain existing flag.
     * @type {boolean}
     */
    this.terrainExists = false;

    this.plainIndexes = null;
    this.plainVertices = null;
    this.plainNormals = null;
    this.terrainVertices = null;
    this.tempVertices = null;

    this.normalMapTexture = null;
    this.normalMapTextureBias = new Float32Array(3);
    this.normalMapVertices = null;
    this.normalMapNormals = null;

    this.vertexNormalBuffer = null;
    this.vertexPositionBuffer = null;
    this.vertexTextureCoordBuffer = null;

    this._globalTextureCoordinates = new Float32Array(4);
    this._projection = _proj_EPSG3857_js__WEBPACK_IMPORTED_MODULE_4__["EPSG3857"];
    this._inTheQueue = false;
    this._appliedNeighborsZoom = [0, 0, 0, 0];

    this._renderingSlices = [];

    this._indexBuffer = null;
};

/**
 * Returns that segment good for rendering with camera by current RATIO_LOD.
 * @public
 * @param {og.Camera} camera - Camera object.
 * @returns {boolean} -
 */
Segment.prototype.acceptForRendering = function (camera) {
    return camera.projectedSize(this.bsphere.center, this.bsphere.radius) < 256 / this.planet.RATIO_LOD;
};


/**
 * Returns entity terrain point.
 * @public
 * @param {og.Entity} entity - Entity.
 * @returns {og.math.Vector3}
 */
Segment.prototype.getEntityTerrainPoint = function (entity, res) {
    return this.getTerrainPoint(res, entity._cartesian, entity._lonlatMerc);
};

Segment.prototype.isEntityInside = function (e) {
    return this._extent.isInside(e._lonlatMerc);
};

/**
 * Returns distance from object to terrain coordinates and terrain point that calculates out in the res parameter.
 * @public
 * @param {og.math.Vector3} res - Result cartesian coordiantes on the terrain.
 * @param {og.math.Vector3} xyz - Cartesian object position.
 * @param {og.LonLat} insideSegmentPosition - Geodetic object position.
 * @returns {number} -
 */
Segment.prototype.getTerrainPoint = function (res, xyz, insideSegmentPosition) {
    var ne = this._extent.northEast,
        sw = this._extent.southWest,
        size = this.gridSize;

    var xmax = ne.lon,
        ymax = ne.lat,
        xmin = sw.lon,
        ymin = sw.lat,
        x = insideSegmentPosition.lon,
        y = insideSegmentPosition.lat;

    var sxn = xmax - xmin,
        syn = ymax - ymin;

    var qx = sxn / size,
        qy = syn / size;

    var xn = x - xmin,
        yn = y - ymin;

    var indX = Math.floor(xn / qx),
        indY = Math.floor(size - yn / qy);

    var verts = this.terrainReady ? this.terrainVertices : this.tempVertices,
        ray = new _math_Ray_js__WEBPACK_IMPORTED_MODULE_9__["Ray"](xyz, xyz.negateTo());

    if (verts && verts.length) {
        var ind_v0 = ((size + 1) * indY + indX) * 3;
        var ind_v2 = ((size + 1) * (indY + 1) + indX) * 3;

        var v0 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__["Vec3"](verts[ind_v0], verts[ind_v0 + 1], verts[ind_v0 + 2]),
            v1 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__["Vec3"](verts[ind_v0 + 3], verts[ind_v0 + 4], verts[ind_v0 + 5]),
            v2 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__["Vec3"](verts[ind_v2], verts[ind_v2 + 1], verts[ind_v2 + 2]);

        var d = ray.hitTriangle(v0, v1, v2, res);
        if (d === _math_Ray_js__WEBPACK_IMPORTED_MODULE_9__["Ray"].INSIDE) {
            return xyz.distance(res);
        }

        var v3 = new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_11__["Vec3"](verts[ind_v2 + 3], verts[ind_v2 + 4], verts[ind_v2 + 5]);

        d = ray.hitTriangle(v1, v3, v2, res);
        if (d === _math_Ray_js__WEBPACK_IMPORTED_MODULE_9__["Ray"].INSIDE) {
            return xyz.distance(res);
        }

        if (d === _math_Ray_js__WEBPACK_IMPORTED_MODULE_9__["Ray"].AWAY) {
            return -xyz.distance(res);
        }

        return xyz.distance(res);
    }

    res.copy(this.planet.ellipsoid.hitRay(ray.origin, ray.direction));
    return xyz.distance(res);
};

/**
 * Project wgs86 to segment native projection.
 * @public
 * @param {og.LonLat} lonlat - Coordinates to project.
 * @returns {og.LonLat} -
 */
Segment.prototype.projectNative = function (lonlat) {
    return lonlat.forwardMercator();
};

Segment.prototype.loadTerrain = function () {
    if (this.tileZoom >= this.planet.terrain.minZoom) {
        if (!this.terrainIsLoading && !this.terrainReady) {
            this.planet.terrain.handleSegmentTerrain(this);
        }
    } else {
        this.terrainReady = true;
        if (!this._inTheQueue) {
            this.planet._normalMapCreator.queue(this);
        }
    }
};

/**
 * Terrain obtained from server.
 * @param {Float32Array} elevations - Elevation data.
 */
Segment.prototype.elevationsExists = function (elevations) {
    //terrain exists
    if (this.ready && this.terrainIsLoading) {
        this.planet._terrainWorker.make(this, elevations);
    }
};

Segment.prototype._terrainWorkerCallback = function (data) {
    if (this.ready) {
        this.normalMapNormals = null;
        this.normalMapVertices = null;
        this.terrainVertices = null;
        this.tempVertices = null;

        this.normalMapNormals = data.normalMapNormals;
        this.normalMapVertices = data.normalMapVertices;
        this.terrainVertices = data.terrainVertices;
        this.tempVertices = data.terrainVertices;

        this.terrainReady = true;
        this.terrainIsLoading = false;
        this.parentNormalMapReady = true;

        if (!this.normalMapTexturePtr) {
            var nmc = this.planet._normalMapCreator;
            this.normalMapTexturePtr = this.planet.renderer.handler.createEmptyTexture_l(nmc._width, nmc._height);
        }

        if (this.planet.lightEnabled) {
            this.planet._normalMapCreator.queue(this);
        }

        var tgs = this.planet.terrain.gridSizeByZoom[this.tileZoom];
        this.createCoordsBuffers(this.terrainVertices, tgs);
        this.bsphere.setFromBounds(data.bounds);
        this.gridSize = tgs;
        this.terrainExists = true;
        this.node.appliedTerrainNodeId = this.node.nodeId;
    }
};

/**
 * Terrain is not obtained or not exists on the server.
 */
Segment.prototype.elevationsNotExists = function () {
    if (this.tileZoom <= this.planet.terrain.maxZoom) {
        if (this.ready && this.terrainIsLoading) {
            this.terrainIsLoading = false;
            this.terrainReady = true;
            this.terrainExists = false;
            this.node.appliedTerrainNodeId = this.node.nodeId;
            this.gridSize = this.planet.terrain.gridSizeByZoom[this.tileZoom];

            if (this.planet.lightEnabled && !this._inTheQueue) {
                this.planet._normalMapCreator.queue(this);
            }

            this.createCoordsBuffers(this.terrainVertices, this.gridSize);
        }

        var xmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], xmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"], ymin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], ymax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"], zmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], zmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];
        var v = this.terrainVertices;
        for (var i = 0; i < v.length; i += 3) {
            var x = v[i], y = v[i + 1], z = v[i + 2];
            if (x < xmin) xmin = x; if (x > xmax) xmax = x;
            if (y < ymin) ymin = y; if (y > ymax) ymax = y;
            if (z < zmin) zmin = z; if (z > zmax) zmax = z;
        }

        this.bsphere.setFromBounds([xmin, xmax, ymin, ymax, zmin, zmax]);
    }
};

Segment.prototype._normalMapEdgeEqualize = function (side, i_a, vert) {

    var nn = this.node.neighbors;
    var n = nn[side];
    var maxZ = this.planet.terrain.maxZoom;

    if (this.tileZoom === maxZ) {
        if (!(nn[0] || nn[1] || nn[2] || nn[3])) {
            n = this.node.getEqualNeighbor(side);
        }
    }

    var ns = n && n.segment;

    if (n && ns && ns.terrainReady && ns.terrainExists &&
        ns.tileZoom <= maxZ &&
        this._appliedNeighborsZoom[side] !== ns.tileZoom) {

        var s = this, b = ns;

        s._appliedNeighborsZoom[side] = b.tileZoom;

        var seg_a = s.normalMapNormals,
            seg_b = b.normalMapNormals;

        if (!(seg_a && seg_b)) return;

        var s_gs = Math.sqrt(s.normalMapNormals.length / 3),
            b_gs = Math.sqrt(b.normalMapNormals.length / 3),
            s_gs1 = s_gs - 1,
            b_gs1 = b_gs - 1;

        i_a *= s_gs1;

        var nx, ny, nz, q;

        if (s.tileZoom === b.tileZoom) {

            var i_b = s_gs1 - i_a;

            if (vert) {
                for (var k = 0; k < s_gs; k++) {
                    var vInd_a = (k * s_gs + i_a) * 3,
                        vInd_b = (k * s_gs + i_b) * 3;

                    nx = seg_a[vInd_a] + seg_b[vInd_b];
                    ny = seg_a[vInd_a + 1] + seg_b[vInd_b + 1];
                    nz = seg_a[vInd_a + 2] + seg_b[vInd_b + 2];

                    q = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);

                    seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                    seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                    seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                }
            } else {
                for (var k = 0; k < s_gs; k++) {
                    var vInd_a = (i_a * s_gs + k) * 3,
                        vInd_b = (i_b * s_gs + k) * 3;

                    nx = seg_a[vInd_a] + seg_b[vInd_b];
                    ny = seg_a[vInd_a + 1] + seg_b[vInd_b + 1];
                    nz = seg_a[vInd_a + 2] + seg_b[vInd_b + 2];

                    q = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);

                    seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                    seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                    seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                }
            }

            if (!b._inTheQueue && b._appliedNeighborsZoom[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][side]] !== s.tileZoom) {
                this.planet._normalMapCreator.queue(b);
            }
            b._appliedNeighborsZoom[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][side]] = s.tileZoom;

        } else {
            var s_edge, b_edge;

            if (i_a) {
                s_edge = 1;
                b_edge = 0;
            } else {
                s_edge = 0;
                b_edge = 1;
            }

            if (s.tileZoom < b.tileZoom) {
                if (!b._inTheQueue && b._appliedNeighborsZoom[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][side]] !== s.tileZoom) {
                    this.planet._normalMapCreator.queue(b);
                }
                b._appliedNeighborsZoom[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][side]] = s.tileZoom;
                side = _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["OPSIDE"][side];
                var t = b;
                t = s;
                s = b;
                b = t;
                s_edge ^= 1;
                b_edge ^= 1;
            }

            var s_nm = s.normalMapNormals,
                b_nm = b.normalMapNormals;

            var dZ2 = 1.0 / (2 << (s.tileZoom - b.tileZoom - 1));

            if (vert) {
                var offsetY = s.tileY * dZ2 - b.tileY;

                for (var k = 0; k < s_gs; k++) {
                    var s_ind = (s_gs * k + s_gs1 * s_edge) * 3;
                    var kk = Math.round(k * dZ2);
                    var b_ind = (b_gs * (kk + offsetY * b_gs1) + b_gs1 * b_edge) * 3;

                    nx = seg_a[vInd_a] + seg_b[vInd_b];
                    ny = seg_a[vInd_a + 1] + seg_b[vInd_b + 1];
                    nz = seg_a[vInd_a + 2] + seg_b[vInd_b + 2];

                    q = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);

                    seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                    seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                    seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                }
            } else {
                var offsetX = s.tileX * dZ2 - b.tileX;

                for (var k = 0; k < s_gs; k++) {
                    var s_ind = (s_gs * s_gs1 * s_edge + k) * 3;
                    var kk = Math.round(k * dZ2);
                    var b_ind = (b_gs * b_gs1 * b_edge + (kk + offsetX * b_gs1)) * 3;

                    nx = seg_a[vInd_a] + seg_b[vInd_b];
                    ny = seg_a[vInd_a + 1] + seg_b[vInd_b + 1];
                    nz = seg_a[vInd_a + 2] + seg_b[vInd_b + 2];

                    q = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);

                    seg_b[vInd_b] = seg_a[vInd_a] = nx * q;
                    seg_b[vInd_b + 1] = seg_a[vInd_a + 1] = ny * q;
                    seg_b[vInd_b + 2] = seg_a[vInd_a + 2] = nz * q;
                }
            }
        }
    }
};

Segment.prototype.applyTerrain = function (elevations) {
    if (this.ready) {
        if (elevations.length) {
            this.elevationsExists(elevations);
        } else {
            this.elevationsNotExists();
        }
    }
};

/**
 * Delete segment gl buffers.
 */
Segment.prototype.deleteBuffers = function () {
    var gl = this.handler.gl;
    gl.deleteBuffer(this.vertexNormalBuffer);
    gl.deleteBuffer(this.vertexPositionBuffer);
    gl.deleteBuffer(this.vertexTextureCoordBuffer);

    this.vertexNormalBuffer = null;
    this.vertexPositionBuffer = null;
    this.vertexTextureCoordBuffer = null;
};

/**
 * Delete materials.
 */
Segment.prototype.deleteMaterials = function () {
    var m = this.materials;
    for (var i = 0; i < m.length; i++) {
        var mi = m[i];
        if (mi) {
            mi.clear();
        }
    }
    this.materials.length = 0;
};

/**
 * Delete elevation data.
 */
Segment.prototype.deleteElevations = function () {
    this.terrainExists = false;
    this.terrainReady = false;
    this.terrainIsLoading = false;

    this.normalMapVertices = null;
    this.normalMapNormals = null;
    this.tempVertices = null;
    this.terrainVertices = null;
    this.plainVertices = null;
    this.plainNormals = null;

    if (this.normalMapReady) {
        this.handler.gl.deleteTexture(this.normalMapTexture);
    }
    this.normalMapReady = false;
    this.parentNormalMapReady = false;
    this._appliedNeighborsZoom = [0, 0, 0, 0];
    this.normalMapTextureBias[0] = 0;
    this.normalMapTextureBias[1] = 0;
    this.normalMapTextureBias[2] = 1;
    this._inTheQueue = false;
};

/**
 * Clear but not destroy segment data.
 */
Segment.prototype.clearSegment = function () {
    this.ready = false;
    this.initialized = false;
    this.deleteBuffers();
    this.deleteMaterials();
    this.deleteElevations();
};

/**
 * Removes cache record.
 */
Segment.prototype._freeCache = function () {
    this.planet._quadTreeNodesCacheMerc[this.tileIndex] = null;
    delete this.planet._quadTreeNodesCacheMerc[this.tileIndex];
};

/**
 * Clear and destroy all segment data.
 */
Segment.prototype.destroySegment = function () {

    this._freeCache();

    this.clearSegment();

    var i = this._renderingSlices.length;
    while (i--) {
        this._renderingSlices[i].clear();
    }

    this._renderingSlices = null;

    this.node = null;

    this.planet = null;
    this.handler = null;
    this.bbox = null;
    this.bsphere = null;
    this._extent = null;

    this.materials = null;

    this.plainIndexes = null;
    this.plainVertices = null;
    this.plainNormals = null;
    this.terrainVertices = null;
    this.tempVertices = null;

    this.normalMapTexture = null;
    this.normalMapTextureBias = null;
    this.normalMapVertices = null;
    this.normalMapNormals = null;

    this.vertexNormalBuffer = null;
    this.vertexPositionBuffer = null;
    this.vertexTextureCoordBuffer = null;

    this._tileOffsetArr = null;
    this._visibleExtentOffsetArr = null;

    this._projection = null;
    this._appliedNeighborsZoom = null;

    this._globalTextureCoordinates = null;
};

/**
 * Creates bound volumes by segment geographical extent.
 */
Segment.prototype.createBoundsByExtent = function () {
    var ellipsoid = this.planet.ellipsoid,
        extent = this._extent;

    var xmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], xmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"], ymin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], ymax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"], zmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"], zmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];
    var v = [_LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"].inverseMercator(extent.southWest.lon, extent.southWest.lat),
    _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"].inverseMercator(extent.southWest.lon, extent.northEast.lat),
    _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"].inverseMercator(extent.northEast.lon, extent.northEast.lat),
    _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"].inverseMercator(extent.northEast.lon, extent.southWest.lat)];

    for (var i = 0; i < v.length; i++) {
        var coord = ellipsoid.lonLatToCartesian(v[i]);
        var x = coord.x, y = coord.y, z = coord.z;
        if (x < xmin) xmin = x;
        if (x > xmax) xmax = x;
        if (y < ymin) ymin = y;
        if (y > ymax) ymax = y;
        if (z < zmin) zmin = z;
        if (z > zmax) zmax = z;
    }

    this.bsphere.setFromBounds([xmin, xmax, ymin, ymax, zmin, zmax]);
};

Segment.prototype.createCoordsBuffers = function (vertices, gridSize) {
    var gsgs = (gridSize + 1) * (gridSize + 1);
    var h = this.handler;
    h.gl.deleteBuffer(this.vertexPositionBuffer);
    h.gl.deleteBuffer(this.vertexTextureCoordBuffer);
    this.vertexTextureCoordBuffer = h.createArrayBuffer(_segmentHelper_js__WEBPACK_IMPORTED_MODULE_8__["textureCoordsTable"][gridSize], 2, gsgs);
    this.vertexPositionBuffer = h.createArrayBuffer(vertices, 3, gsgs);
};

Segment.prototype._addViewExtent = function () {

    var ext = this._extent;
    if (!this.planet._viewExtentMerc) {
        this.planet._viewExtentMerc = new _Extent_js__WEBPACK_IMPORTED_MODULE_5__["Extent"](
            new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](ext.southWest.lon, ext.southWest.lat),
            new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](ext.northEast.lon, ext.northEast.lat));
        return;
    }

    var viewExt = this.planet._viewExtentMerc;

    if (ext.southWest.lon < viewExt.southWest.lon) {
        viewExt.southWest.lon = ext.southWest.lon;
    }

    if (ext.northEast.lon > viewExt.northEast.lon) {
        viewExt.northEast.lon = ext.northEast.lon;
    }

    if (ext.southWest.lat < viewExt.southWest.lat) {
        viewExt.southWest.lat = ext.southWest.lat;
    }

    if (ext.northEast.lat > viewExt.northEast.lat) {
        viewExt.northEast.lat = ext.northEast.lat;
    }
};

Segment.prototype._assignTileIndexes = function () {
    var tileZoom = this.tileZoom;
    var extent = this._extent;
    var pole = _mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE"];
    this.tileX = Math.round(Math.abs(-pole - extent.southWest.lon) / (extent.northEast.lon - extent.southWest.lon));
    this.tileY = Math.round(Math.abs(pole - extent.northEast.lat) / (extent.northEast.lat - extent.southWest.lat));
    this.tileIndex = _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["Layer"].getTileIndex(this.tileX, this.tileY, tileZoom);
    this.planet._quadTreeNodesCacheMerc[this.tileIndex] = this.node;
};

Segment.prototype.initializePlainSegment = function () {
    var p = this.planet;
    var n = this.node;
    n.sideSize[0] = n.sideSize[1] =
        n.sideSize[2] = n.sideSize[3] =
        this.gridSize = p.terrain.gridSizeByZoom[this.tileZoom];
    this.initialized = true;

    if (this.tileZoom <= p.terrain.maxZoom) {
        var nmc = this.planet._normalMapCreator;
        this.normalMapTexturePtr = p.renderer.handler.createEmptyTexture_l(nmc._width, nmc._height);
    }
};

Segment.prototype.createPlainSegment = function () {
    this.initializePlainSegment();
    this.createPlainVertices(this.gridSize);
    this.createCoordsBuffers(this.plainVertices, this.gridSize);
    this.ready = true;
};

Segment.prototype.createPlainVertices = function (gridSize) {

    var e = this._extent,
        fgs = this.planet.terrain.fileGridSize;
    var lonSize = e.getWidth();
    var llStep = lonSize / Math.max(fgs, gridSize);
    var esw_lon = e.southWest.lon,
        ene_lat = e.northEast.lat;
    var dg = Math.max(fgs / gridSize, 1),
        gs = Math.max(fgs, gridSize) + 1;
    var r2 = this.planet.ellipsoid._invRadii2;
    var ind = 0,
        nmInd = 0;

    var gridSize3 = (gridSize + 1) * (gridSize + 1) * 3;
    this.plainNormals = new Float32Array(gridSize3);
    this.plainVertices = new Float32Array(gridSize3);

    var gs3 = gs * gs * 3;
    this.normalMapNormals = new Float32Array(gs3);
    this.normalMapVertices = new Float32Array(gs3);

    var verts = this.plainVertices,
        norms = this.plainNormals,
        nmVerts = this.normalMapVertices,
        nmNorms = this.normalMapNormals;

    for (var i = 0; i < gs; i++) {
        for (var j = 0; j < gs; j++) {
            var v = this.planet.ellipsoid.lonLatToCartesian(_LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"].inverseMercator(esw_lon + j * llStep, ene_lat - i * llStep));
            var nx = v.x * r2.x, ny = v.y * r2.y, nz = v.z * r2.z;
            var l = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
            var nxl = nx * l, nyl = ny * l, nzl = nz * l;

            nmVerts[nmInd] = v.x;
            nmNorms[nmInd++] = nxl;

            nmVerts[nmInd] = v.y;
            nmNorms[nmInd++] = nyl;

            nmVerts[nmInd] = v.z;
            nmNorms[nmInd++] = nzl;

            if (i % dg === 0 && j % dg === 0) {
                verts[ind] = v.x;
                norms[ind++] = nxl;

                verts[ind] = v.y;
                norms[ind++] = nyl;

                verts[ind] = v.z;
                norms[ind++] = nzl;
            }
        }
    }

    this.normalMapTexture = this.planet.transparentTexture;
    this.terrainVertices = verts;
    this.tempVertices = verts;

    this._globalTextureCoordinates[0] = (e.southWest.lon + _mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE"]) * _mercator_js__WEBPACK_IMPORTED_MODULE_1__["ONE_BY_POLE_DOUBLE"];
    this._globalTextureCoordinates[1] = (_mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE"] - e.northEast.lat) * _mercator_js__WEBPACK_IMPORTED_MODULE_1__["ONE_BY_POLE_DOUBLE"];
    this._globalTextureCoordinates[2] = (e.northEast.lon + _mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE"]) * _mercator_js__WEBPACK_IMPORTED_MODULE_1__["ONE_BY_POLE_DOUBLE"];
    this._globalTextureCoordinates[3] = (_mercator_js__WEBPACK_IMPORTED_MODULE_1__["POLE"] - e.southWest.lat) * _mercator_js__WEBPACK_IMPORTED_MODULE_1__["ONE_BY_POLE_DOUBLE"];
};

/**
 * Gets specific layer material.
 * @public
 * @param {og.layer.Layer} layer - Layer object.
 * @returns {og.planetSegment.Material} - Segment material.
 */
Segment.prototype.getMaterialByLayer = function (layer) {
    return this.materials[layer._id];
};

Segment.prototype._getLayerExtentOffset = function (layer) {
    var v0s = layer._extentMerc;
    var v0t = this._extent;
    var sSize_x = v0s.northEast.lon - v0s.southWest.lon;
    var sSize_y = v0s.northEast.lat - v0s.southWest.lat;
    var dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
    var dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
    var dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
    var dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
    return [dV0s_x, dV0s_y, dSize_x, dSize_y];
};

Segment.prototype._multiRendering = function (sh, layerSlice, defaultTexture, isOverlay) {
    if (this.ready) {
        var gl = this.handler.gl;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var pm = this.materials,
            p = this.planet;

        //First always draw whole planet base layer segment with solid texture.
        gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE * 2 + 2);
        gl.bindTexture(gl.TEXTURE_2D, defaultTexture || this._getDefaultTexture());
        gl.uniform1i(shu.defaultTexture._pName, p.SLICE_SIZE * 2 + 2);

        var currHeight, li;
        if (layerSlice) {
            li = layerSlice[0];
            currHeight = li._height;
        } else {
            currHeight = 0;
        }

        var n = 0,
            i = 0;

        var notEmpty = false;

        //gl.activeTexture(gl.TEXTURE0);
        //gl.bindTexture(gl.TEXTURE_2D, this.planet.transparentTexture);

        while (li) {
            if (this.layerOverlap(li) && li.minZoom <= p.minCurrZoom && li.maxZoom >= p.maxCurrZoom) {
                notEmpty = true;
                var m = pm[li._id];

                if (!m) {
                    m = pm[li._id] = li.createMaterial(this);
                }

                var n4 = n * 4,
                    n3 = n * 3;

                var arr = li.applyMaterial(m);
                p._tileOffsetArr[n4] = arr[0];
                p._tileOffsetArr[n4 + 1] = arr[1];
                p._tileOffsetArr[n4 + 2] = arr[2];
                p._tileOffsetArr[n4 + 3] = arr[3];

                arr = this._getLayerExtentOffset(li);
                p._visibleExtentOffsetArr[n4] = arr[0];
                p._visibleExtentOffsetArr[n4 + 1] = arr[1];
                p._visibleExtentOffsetArr[n4 + 2] = arr[2];
                p._visibleExtentOffsetArr[n4 + 3] = arr[3];

                p._transparentColorArr[n4] = li.transparentColor[0];
                p._transparentColorArr[n4 + 1] = li.transparentColor[1];
                p._transparentColorArr[n4 + 2] = li.transparentColor[2];
                p._transparentColorArr[n4 + 3] = li.opacity;

                p._pickingColorArr[n3] = li._pickingColor.x / 255.0;
                p._pickingColorArr[n3 + 1] = li._pickingColor.y / 255.0;
                p._pickingColorArr[n3 + 2] = li._pickingColor.z / 255.0;

                p._diffuseMaterialArr[n3 + 3] = li.diffuse.x;
                p._diffuseMaterialArr[n3 + 1 + 3] = li.diffuse.y;
                p._diffuseMaterialArr[n3 + 2 + 3] = li.diffuse.z;

                p._ambientMaterialArr[n3 + 3] = li.ambient.x;
                p._ambientMaterialArr[n3 + 1 + 3] = li.ambient.y;
                p._ambientMaterialArr[n3 + 2 + 3] = li.ambient.z;

                p._specularMaterialArr[n4 + 4] = li.specular.x;
                p._specularMaterialArr[n4 + 1 + 4] = li.specular.y;
                p._specularMaterialArr[n4 + 2 + 4] = li.specular.z;
                p._specularMaterialArr[n4 + 3 + 4] = li.shininess;

                p._samplerArr[n] = n;
                gl.activeTexture(gl.TEXTURE0 + n);
                gl.bindTexture(gl.TEXTURE_2D, m.texture && gl.isTexture(m.texture) && m.texture || this.planet.transparentTexture);


                p._pickingMaskArr[n] = n + p.SLICE_SIZE;
                gl.activeTexture(gl.TEXTURE0 + n + p.SLICE_SIZE);
                gl.bindTexture(gl.TEXTURE_2D, m.pickingMask && gl.isTexture(m.pickingMask) && m.pickingMask || this.planet.transparentTexture);

                n++;
            }
            i++;
            li = layerSlice[i];
        }

        if (notEmpty || !isOverlay) {

            //bind normalmap texture
            if (p.lightEnabled) {
                gl.uniform3fv(shu.uNormalMapBias._pName, this.normalMapTextureBias);
                gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE * 2 + 3);
                gl.bindTexture(gl.TEXTURE_2D, this.normalMapTexture || this.planet.transparentTexture);
                gl.uniform1i(shu.uNormalMap._pName, p.SLICE_SIZE * 2 + 3);

                //bind segment specular and night material texture coordinates
                gl.uniform4fv(shu.uGlobalTextureCoord._pName, this._globalTextureCoordinates);

                gl.uniform3fv(shu.diffuseMaterial._pName, p._diffuseMaterialArr);
                gl.uniform3fv(shu.ambientMaterial._pName, p._ambientMaterialArr);
                gl.uniform4fv(shu.specularMaterial._pName, p._specularMaterialArr);
            }

            gl.uniform1i(shu.samplerCount._pName, n);
            gl.uniform1f(shu.height._pName, currHeight);
            gl.uniform1iv(shu.samplerArr._pName, p._samplerArr);
            gl.uniform1iv(shu.pickingMaskArr._pName, p._pickingMaskArr);
            gl.uniform4fv(shu.tileOffsetArr._pName, p._tileOffsetArr);
            gl.uniform4fv(shu.visibleExtentOffsetArr._pName, p._visibleExtentOffsetArr);
            gl.uniform4fv(shu.transparentColorArr._pName, p._transparentColorArr);
            gl.uniform3fv(shu.pickingColorArr._pName, p._pickingColorArr);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
            gl.vertexAttribPointer(sha.aVertexPosition._pName, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(sha.aTextureCoord._pName, this.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            var _indexBuffer = this._getIndexBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBuffer);
            gl.drawElements(p.drawMode, _indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }
    }

    this.node.hasNeighbor[0] = false;
    this.node.hasNeighbor[1] = false;
    this.node.hasNeighbor[2] = false;
    this.node.hasNeighbor[3] = false;
};

Segment.prototype._screenRendering = function (sh, layerSlice, sliceIndex, defaultTexture, isOverlay) {
    if (this.ready) {
        var gl = this.handler.gl;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var pm = this.materials,
            p = this.planet;

        var currHeight, li;
        if (layerSlice) {
            li = layerSlice[0];
            currHeight = li._height;
        } else {
            currHeight = 0;
        }

        //First always draw whole planet base layer segment with solid texture.
        gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE + 2);
        gl.bindTexture(gl.TEXTURE_2D, defaultTexture || this._getDefaultTexture());
        gl.uniform1i(shu.defaultTexture._pName, p.SLICE_SIZE + 2);

        var n = 0,
            i = 0;

        var notEmpty = false;

        var slice = this._renderingSlices[sliceIndex];

        if (!slice) {
            slice = this._renderingSlices[sliceIndex] = new _RenderingSlice(p);
        } else {
            slice.layers = [];
        }

        this._indexBuffer = this._getIndexBuffer();

        while (li) {
            if (this.layerOverlap(li) && li.minZoom <= p.minCurrZoom && li.maxZoom >= p.maxCurrZoom) {
                notEmpty = true;
                var m = pm[li._id];
                if (!m) {
                    m = pm[li._id] = li.createMaterial(this);
                }

                slice.layers.push(li);

                var n4 = n * 4,
                    n3 = n * 3;

                var arr = li.applyMaterial(m);
                slice.tileOffsetArr[n4] = arr[0];
                slice.tileOffsetArr[n4 + 1] = arr[1];
                slice.tileOffsetArr[n4 + 2] = arr[2];
                slice.tileOffsetArr[n4 + 3] = arr[3];

                arr = this._getLayerExtentOffset(li);
                slice.visibleExtentOffsetArr[n4] = arr[0];
                slice.visibleExtentOffsetArr[n4 + 1] = arr[1];
                slice.visibleExtentOffsetArr[n4 + 2] = arr[2];
                slice.visibleExtentOffsetArr[n4 + 3] = arr[3];

                slice.transparentColorArr[n4] = li.transparentColor[0];
                slice.transparentColorArr[n4 + 1] = li.transparentColor[1];
                slice.transparentColorArr[n4 + 2] = li.transparentColor[2];
                slice.transparentColorArr[n4 + 3] = li.opacity;

                p._diffuseMaterialArr[n3 + 3] = li.diffuse.x;
                p._diffuseMaterialArr[n3 + 1 + 3] = li.diffuse.y;
                p._diffuseMaterialArr[n3 + 2 + 3] = li.diffuse.z;

                p._ambientMaterialArr[n3 + 3] = li.ambient.x;
                p._ambientMaterialArr[n3 + 1 + 3] = li.ambient.y;
                p._ambientMaterialArr[n3 + 2 + 3] = li.ambient.z;

                p._specularMaterialArr[n4 + 4] = li.specular.x;
                p._specularMaterialArr[n4 + 1 + 4] = li.specular.y;
                p._specularMaterialArr[n4 + 2 + 4] = li.specular.z;
                p._specularMaterialArr[n4 + 3 + 4] = li.shininess;

                p._samplerArr[n] = n;

                gl.activeTexture(gl.TEXTURE0 + n);
                gl.bindTexture(gl.TEXTURE_2D, m.texture || p.transparentTexture);

                n++;
            }
            i++;
            li = layerSlice[i];
        }

        if (notEmpty || !isOverlay) {
            gl.uniform1i(shu.samplerCount._pName, n);
            gl.uniform1f(shu.height._pName, currHeight);
            gl.uniform1iv(shu.samplerArr._pName, p._samplerArr);
            gl.uniform4fv(shu.tileOffsetArr._pName, slice.tileOffsetArr);
            gl.uniform4fv(shu.visibleExtentOffsetArr._pName, slice.visibleExtentOffsetArr);
            gl.uniform4fv(shu.transparentColorArr._pName, slice.transparentColorArr);

            //bind normalmap texture
            if (p.lightEnabled) {
                gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE + 3);
                gl.bindTexture(gl.TEXTURE_2D, this.normalMapTexture || p.transparentTexture);
                gl.uniform1i(shu.uNormalMap._pName, p.SLICE_SIZE + 3);

                gl.uniform3fv(shu.uNormalMapBias._pName, this.normalMapTextureBias);

                //bind segment specular and night material texture coordinates
                gl.uniform4fv(shu.uGlobalTextureCoord._pName, this._globalTextureCoordinates);

                gl.uniform3fv(shu.diffuseMaterial._pName, p._diffuseMaterialArr);
                gl.uniform3fv(shu.ambientMaterial._pName, p._ambientMaterialArr);
                gl.uniform4fv(shu.specularMaterial._pName, p._specularMaterialArr);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
            gl.vertexAttribPointer(sha.aVertexPosition._pName, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(sha.aTextureCoord._pName, this.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(p.drawMode, this._indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }
    }

    this.node.hasNeighbor[0] = false;
    this.node.hasNeighbor[1] = false;
    this.node.hasNeighbor[2] = false;
    this.node.hasNeighbor[3] = false;
};

Segment.prototype._colorPickingRendering = function (sh, layerSlice, sliceIndex, defaultTexture, isOverlay) {
    if (this.ready) {
        var gl = this.handler.gl;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var pm = this.materials,
            p = this.planet;

        var currHeight;
        if (layerSlice) {
            currHeight = layerSlice[0]._height;
        } else {
            currHeight = 0;
        }

        var notEmpty = false;

        var slice = this._renderingSlices[sliceIndex];

        for (var n = 0; n < slice.layers.length; n++) {
            notEmpty = true;

            var li = slice.layers[n];
            var n3 = n * 3;

            p._pickingColorArr[n3] = li._pickingColor.x / 255.0;
            p._pickingColorArr[n3 + 1] = li._pickingColor.y / 255.0;
            p._pickingColorArr[n3 + 2] = li._pickingColor.z / 255.0;

            p._samplerArr[n] = n;
            gl.activeTexture(gl.TEXTURE0 + n);
            gl.bindTexture(gl.TEXTURE_2D, pm[li._id].texture || this.planet.transparentTexture);

            p._pickingMaskArr[n] = n + p.SLICE_SIZE;
            gl.activeTexture(gl.TEXTURE0 + n + p.SLICE_SIZE);
            gl.bindTexture(gl.TEXTURE_2D, pm[li._id].pickingMask || this.planet.transparentTexture);
        }

        if (notEmpty || !isOverlay) {
            gl.uniform1i(shu.samplerCount._pName, n);
            gl.uniform1f(shu.height._pName, currHeight);
            gl.uniform1iv(shu.samplerArr._pName, p._samplerArr);
            gl.uniform1iv(shu.pickingMaskArr._pName, p._pickingMaskArr);
            gl.uniform4fv(shu.tileOffsetArr._pName, slice.tileOffsetArr);
            gl.uniform4fv(shu.visibleExtentOffsetArr._pName, slice.visibleExtentOffsetArr);
            gl.uniform4fv(shu.transparentColorArr._pName, slice.transparentColorArr);
            gl.uniform3fv(shu.pickingColorArr._pName, p._pickingColorArr);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
            gl.vertexAttribPointer(sha.aVertexPosition._pName, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(sha.aTextureCoord._pName, this.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(p.drawMode, this._indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }
    }
};

Segment.prototype._heightPickingRendering = function (sh, layerSlice, sliceIndex, defaultTexture, isOverlay) {
    if (this.ready) {
        var gl = this.handler.gl;
        var sha = sh.attributes,
            shu = sh.uniforms;

        var pm = this.materials,
            p = this.planet;

        //First always draw whole planet base layer segment with solid texture.
        gl.activeTexture(gl.TEXTURE0 + p.SLICE_SIZE);
        gl.bindTexture(gl.TEXTURE_2D, defaultTexture || p.solidTextureOne);
        gl.uniform1i(shu.defaultTexture._pName, p.SLICE_SIZE);

        var currHeight;
        if (layerSlice) {
            currHeight = layerSlice[0]._height;
        } else {
            currHeight = 0;
        }

        var n = 0;

        var slice = this._renderingSlices[sliceIndex];

        var notEmpty = false;

        for (n = 0; n < slice.layers.length; n++) {
            notEmpty = true;
            p._samplerArr[n] = n;
            gl.activeTexture(gl.TEXTURE0 + n);
            gl.bindTexture(gl.TEXTURE_2D, pm[slice.layers[n]._id].texture || p.transparentTexture);
        }

        if (notEmpty || !isOverlay) {
            gl.uniform1i(shu.samplerCount._pName, n);
            gl.uniform1f(shu.height._pName, currHeight);
            gl.uniform1iv(shu.samplerArr._pName, p._samplerArr);
            gl.uniform4fv(shu.tileOffsetArr._pName, slice.tileOffsetArr);
            gl.uniform4fv(shu.visibleExtentOffsetArr._pName, slice.visibleExtentOffsetArr);
            gl.uniform4fv(shu.transparentColorArr._pName, slice.transparentColorArr);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
            gl.vertexAttribPointer(sha.aVertexPosition._pName, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
            gl.vertexAttribPointer(sha.aTextureCoord._pName, this.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            gl.drawElements(p.drawMode, this._indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        }
    }
};


Segment.prototype._getIndexBuffer = function () {
    var s = this.node.sideSize;
    var cache = this.planet._indexesCache[this.gridSize][s[0]][s[1]][s[2]][s[3]];
    if (!cache.buffer) {
        cache.buffer = this.planet.renderer.handler.createElementArrayBuffer(cache.indexes, 1);
    }
    return cache.buffer;
};

Segment.prototype._collectRenderNodes = function () {
    this.planet._visibleNodes[this.node.nodeId] = this.node;
};

Segment.prototype.layerOverlap = function (layer) {
    return this._extent.overlaps(layer._extentMerc);
};

Segment.prototype._getDefaultTexture = function () {
    return this.planet.solidTextureOne;
};

Segment.prototype.getExtentLonLat = function () {
    return this._extent.inverseMercator();
};

Segment.prototype.getExtentMerc = function () {
    return this._extent;
};

Segment.prototype.getExtent = function () {
    return this._extent;
};

Segment.prototype.getNodeState = function () {
    var vn = this.planet._visibleNodes[this.node.nodeId];
    return vn && vn.state || _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];
};

Segment.prototype.getTileIndex = function () {
    return this.tileZoom + "_" + this.tileX + "_" + this.tileY;
};



/***/ }),

/***/ "./src/og/segment/SegmentLonLat.js":
/*!*****************************************!*\
  !*** ./src/og/segment/SegmentLonLat.js ***!
  \*****************************************/
/*! exports provided: SegmentLonLat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentLonLat", function() { return SegmentLonLat; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./src/og/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mercator.js */ "./src/og/mercator.js");
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _proj_EPSG4326_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proj/EPSG4326.js */ "./src/og/proj/EPSG4326.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _inherits_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../inherits.js */ "./src/og/inherits.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./src/og/layer/Layer.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _Segment_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Segment.js */ "./src/og/segment/Segment.js");
/**
 * @module og/segment/SegmentLonLat
 */

'use sctrict';












const _heightLat = 90.0 - _mercator_js__WEBPACK_IMPORTED_MODULE_1__["MAX_LAT"];
const _maxPoleZoom = 7;
const _pieceSize = _heightLat / Math.pow(2, _maxPoleZoom);


/**
 * Planet segment Web Mercator tile class that stored and rendered with quad tree.
 * @class
 * @extends {og.planetSegment.Segment}
 * @param {og.quadNode.Node} node - Quad tree segment node.
 * @param {og.scene.Planet} planet - Scene planet.
 * @param {Number} tileZoom - Segment tile zoom index.
 * @param {og.Extent} extent - Segment WGS84 extent.
 */
const SegmentLonLat = function (node, planet, tileZoom, extent) {
    this._isNorth = false;
    _Segment_js__WEBPACK_IMPORTED_MODULE_8__["Segment"].call(this, node, planet, tileZoom, extent);
    this._projection = _proj_EPSG4326_js__WEBPACK_IMPORTED_MODULE_3__["EPSG4326"];
    this._extentMerc = new _Extent_js__WEBPACK_IMPORTED_MODULE_4__["Extent"](extent.southWest.forwardMercatorEPS01(), extent.northEast.forwardMercatorEPS01());
};

Object(_inherits_js__WEBPACK_IMPORTED_MODULE_5__["inherits"])(SegmentLonLat, _Segment_js__WEBPACK_IMPORTED_MODULE_8__["Segment"]);

SegmentLonLat.prototype.projectNative = function (coords) {
    return coords;
};

SegmentLonLat.prototype.getTerrainPoint = function (res, xyz) {
    res.copy(this.planet.ellipsoid.hitRay(xyz, xyz.negateTo().normalize()));
    return xyz.distance(res);
};

SegmentLonLat.prototype.acceptForRendering = function (camera) {
    var maxPoleZoom;
    var lat = this._extent.northEast.lat;
    if (this._isNorth) {
        //north pole limits
        var Yz = Math.floor((90.0 - lat) / _pieceSize);
        maxPoleZoom = Math.floor(Yz / 16) + 7;
    } else {
        //south pole limits
        var Yz = Math.floor((_mercator_js__WEBPACK_IMPORTED_MODULE_1__["MIN_LAT"] - lat) / _pieceSize);
        maxPoleZoom = 12 - Math.floor(Yz / 16);
    }
    return _Segment_js__WEBPACK_IMPORTED_MODULE_8__["Segment"].prototype.acceptForRendering.call(this, camera) || this.tileZoom >= maxPoleZoom;
};

SegmentLonLat.prototype._assignTileIndexes = function () {
    var tileZoom = this.tileZoom;
    var extent = this._extent;

    this.tileX = Math.round(Math.abs(-180.0 - extent.southWest.lon) / (extent.northEast.lon - extent.southWest.lon));

    var lat = extent.northEast.lat;
    if (lat > 0) {
        //north pole
        this._isNorth = true;
        this.tileY = Math.round((90.0 - lat) / (extent.northEast.lat - extent.southWest.lat));
    } else {
        //south pole
        this.tileY = Math.round((_mercator_js__WEBPACK_IMPORTED_MODULE_1__["MIN_LAT"] - lat) / (extent.northEast.lat - extent.southWest.lat));
    }

    this.tileIndex = _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["Layer"].getTileIndex(this.tileX, this.tileY, tileZoom);
};

SegmentLonLat.prototype._addViewExtent = function () {

    var ext = this._extent;
    if (!this.planet._viewExtentWGS84) {
        this.planet._viewExtentWGS84 = new _Extent_js__WEBPACK_IMPORTED_MODULE_4__["Extent"](
            new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](ext.southWest.lon, ext.southWest.lat),
            new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](ext.northEast.lon, ext.northEast.lat));
        return;
    }

    var viewExt = this.planet._viewExtentWGS84;

    if (ext.southWest.lon < viewExt.southWest.lon) {
        viewExt.southWest.lon = ext.southWest.lon;
    }

    if (ext.northEast.lon > viewExt.northEast.lon) {
        viewExt.northEast.lon = ext.northEast.lon;
    }

    if (ext.southWest.lat < viewExt.southWest.lat) {
        viewExt.southWest.lat = ext.southWest.lat;
    }

    if (ext.northEast.lat > viewExt.northEast.lat) {
        viewExt.northEast.lat = ext.northEast.lat;
    }
};

SegmentLonLat.prototype.createPlainVertices = function (gridSize) {
    var ind = 0;
    var e = this._extent;
    var lonSize = e.getWidth();
    var latSize = e.getHeight();
    var llStep = lonSize / gridSize;
    var ltStep = latSize / gridSize;
    var esw_lon = e.southWest.lon,
        ene_lat = e.northEast.lat;

    var r2 = this.planet.ellipsoid._invRadii2;

    this.plainNormals = new Float32Array((gridSize + 1) * (gridSize + 1) * 3);
    this.plainVertices = new Float32Array((gridSize + 1) * (gridSize + 1) * 3);

    var norms = this.plainNormals;
    var verts = this.plainVertices;

    for (var i = 0; i <= gridSize; i++) {
        for (var j = 0; j <= gridSize; j++) {
            var v = this.planet.ellipsoid.lonLatToCartesian(new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](esw_lon + j * llStep, ene_lat - i * ltStep));
            var nx = v.x * r2.x,
                ny = v.y * r2.y,
                nz = v.z * r2.z;
            var l = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
            verts[ind] = v.x;
            norms[ind++] = nx * l;

            verts[ind] = v.y;
            norms[ind++] = ny * l;

            verts[ind] = v.z;
            norms[ind++] = nz * l;
        }
    }
    this.normalMapVertices = verts;
    this.normalMapNormals = norms;
    this.terrainVertices = verts;
    this.tempVertices = verts;

    this.normalMapTexture = this.planet.transparentTexture;

    this._globalTextureCoordinates[0] = (e.southWest.lon + 180.0) / 360.0;
    this._globalTextureCoordinates[1] = (90 - e.northEast.lat) / 180.0;
    this._globalTextureCoordinates[2] = (e.northEast.lon + 180.0) / 360.0;
    this._globalTextureCoordinates[3] = (90 - e.southWest.lat) / 180.0;
};

SegmentLonLat.prototype.createBoundsByExtent = function () {
    var ellipsoid = this.planet.ellipsoid,
        extent = this._extent;

    var xmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"],
        xmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"],
        ymin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"],
        ymax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"],
        zmin = _math_js__WEBPACK_IMPORTED_MODULE_0__["MAX"],
        zmax = _math_js__WEBPACK_IMPORTED_MODULE_0__["MIN"];

    var v = [new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](extent.southWest.lon, extent.southWest.lat),
    new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](extent.southWest.lon, extent.northEast.lat),
    new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](extent.northEast.lon, extent.northEast.lat),
    new _LonLat_js__WEBPACK_IMPORTED_MODULE_7__["LonLat"](extent.northEast.lon, extent.southWest.lat)
    ];

    for (var i = 0; i < v.length; i++) {
        var coord = ellipsoid.lonLatToCartesian(v[i]);
        var x = coord.x,
            y = coord.y,
            z = coord.z;
        if (x < xmin) xmin = x;
        if (x > xmax) xmax = x;
        if (y < ymin) ymin = y;
        if (y > ymax) ymax = y;
        if (z < zmin) zmin = z;
        if (z > zmax) zmax = z;
    }

    this.bsphere.setFromBounds([xmin, xmax, ymin, ymax, zmin, zmax]);
};

SegmentLonLat.prototype._collectRenderNodes = function () {
    if (this._isNorth) {
        this.planet._visibleNodesNorth[this.node.nodeId] = this.node;
    } else {
        this.planet._visibleNodesSouth[this.node.nodeId] = this.node;
    }
};

SegmentLonLat.prototype.isEntityInside = function (e) {
    return this._extent.isInside(e._lonlat);
};

SegmentLonLat.prototype._getLayerExtentOffset = function (layer) {
    var v0s = layer._extent;
    var v0t = this._extent;
    var sSize_x = v0s.northEast.lon - v0s.southWest.lon;
    var sSize_y = v0s.northEast.lat - v0s.southWest.lat;
    var dV0s_x = (v0t.southWest.lon - v0s.southWest.lon) / sSize_x;
    var dV0s_y = (v0s.northEast.lat - v0t.northEast.lat) / sSize_y;
    var dSize_x = (v0t.northEast.lon - v0t.southWest.lon) / sSize_x;
    var dSize_y = (v0t.northEast.lat - v0t.southWest.lat) / sSize_y;
    return [dV0s_x, dV0s_y, dSize_x, dSize_y];
};

SegmentLonLat.prototype.layerOverlap = function (layer) {
    return this._extent.overlaps(layer._extent);
};

SegmentLonLat.prototype._getDefaultTexture = function () {
    return this.planet.solidTextureTwo;
};

SegmentLonLat.prototype.getExtentLonLat = function () {
    return this._extent;
};

SegmentLonLat.prototype.getExtentMerc = function () {
    return this._extentMerc;
};

SegmentLonLat.prototype.getNodeState = function () {
    var vn;
    if (this._isNorth) {
        vn = this.planet._visibleNodesNorth[this.node.nodeId];
    } else {
        vn = this.planet._visibleNodesSouth[this.node.nodeId];
    }
    return vn && vn.state || _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_2__["NOTRENDERING"];
};


SegmentLonLat.prototype._freeCache = function () {
    //empty for a time
};



/***/ }),

/***/ "./src/og/segment/segmentHelper.js":
/*!*****************************************!*\
  !*** ./src/og/segment/segmentHelper.js ***!
  \*****************************************/
/*! exports provided: TABLESIZE, textureCoordsTable, createSegmentIndexes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TABLESIZE", function() { return TABLESIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textureCoordsTable", function() { return textureCoordsTable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSegmentIndexes", function() { return createSegmentIndexes; });
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/**
 * @module og/segment/segmentHelper
 */

'use sctrict';



const TABLESIZE = 6;

const centerIndexesTable = initIndexBodiesTable(TABLESIZE);
const skirtsIndexesTable = initIndexesBodySkirts(TABLESIZE);

const textureCoordsTable = initTextureCoordsTable(TABLESIZE);

function createSegmentIndexes(size, sidesSizes) {
    if (size != 1) {
        var c = centerIndexesTable[size],
            w = skirtsIndexesTable[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]][size][sidesSizes[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]]],
            n = skirtsIndexesTable[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]][size][sidesSizes[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]]],
            e = skirtsIndexesTable[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]][size][sidesSizes[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]]],
            s = skirtsIndexesTable[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]][size][sidesSizes[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]]];
        var indexes = new Uint16Array(c.length + w.length + n.length + e.length + s.length);
        var k = 0, i = 0;
        for (k = 0; k < c.length; k++) {
            indexes[i++] = c[k];
        }
        for (k = 0; k < w.length; k++) {
            indexes[i++] = w[k];
        }
        for (k = 0; k < n.length; k++) {
            indexes[i++] = n[k];
        }
        for (k = 0; k < e.length; k++) {
            indexes[i++] = e[k];
        }
        for (k = 0; k < s.length; k++) {
            indexes[i++] = s[k];
        }
        return indexes;
    } else {
        return new Uint16Array([0, 2, 1, 3]);
    }
};

function createCenterBodyIndexes(size, indexes) {

    var i0 = 1,
        j0 = 1;

    var i1 = 1,
        j1 = 1;

    var ind1, ind2, nr;
    for (var i = i0; i < size - 1 - i1; i++) {
        for (var j = j0; j < size - j1; j++) {
            ind1 = i * size + j;
            nr = (i + 1) * size;
            ind2 = nr + j;
            indexes.push(ind1, ind2);
        }
        indexes.push(ind2, nr + j0);
    }
    indexes.push(indexes[indexes.length - 1], size * size - size);
};

function createWestNeighborSkirt(size, deltaGr, indexes) {
    var grCount = (size - 1) / deltaGr;
    var b = size * size - size;
    var k = 0;
    for (var i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        var rind = b - size * i - size + 1,
            lind = b - size * k;
        indexes.push(lind, rind);
    }

    if (deltaGr === (size - 1)) {
        indexes.push(size);
        indexes.push(0);
    }
};

function createNorthNeighborSkirt(size, deltaGr, indexes) {
    var grCount = (size - 1) / deltaGr;
    var k = 0;
    for (var i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        var rind = size + i + 1,
            lind = k;
        indexes.push(lind, rind);
    }

    if (deltaGr === (size - 1)) {
        indexes.push(size - 2);
        indexes.push(size - 1);
    }
};

function createEastNeighborSkirt(size, deltaGr, indexes) {
    var grCount = (size - 1) / deltaGr;
    var k = 0;
    for (var i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        var rind = size * (i + 1) + size - 2,
            lind = size + size * k - 1;
        indexes.push(lind, rind);
    }

    if (deltaGr === (size - 1)) {
        indexes.push(size * (size - 1) - 1);
        indexes.push(size * size - 1);
    }
};

function createSouthNeighborSkirt(size, deltaGr, indexes) {
    var grCount = (size - 1) / deltaGr;
    var k = 0;
    var rb = size * (size - 1) - 2;
    var lb = size * size - 1;
    for (var i = 0; i < size - 2; i++) {
        if (i % grCount === 0) {
            k = i;
        }
        var rind = rb - i,
            lind = lb - k;
        indexes.push(lind, rind);
    }

    if (deltaGr === (size - 1)) {
        indexes.push(size * size - size + 1);
    }
    indexes.push(size * size - size);
};

function initIndexesBodySkirts(pow) {
    var table = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]] = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]] = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]] = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]] = [];

    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]][0] = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]][0] = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]][0] = [];
    table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]][0] = [];

    for (var i = 0; i <= pow; i++) {
        var d = Math.pow(2, i);
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]][d] = [];
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]][d] = [];
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]][d] = [];
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]][d] = [];

        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]][d][0] = [];
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]][d][0] = [];
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]][d][0] = [];
        table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]][d][0] = [];

        for (var j = 0; j <= pow; j++) {
            var dd = Math.pow(2, j);
            var nt = table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"]][d][dd] = [];
            var wt = table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"]][d][dd] = [];
            var st = table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"]][d][dd] = [];
            var et = table[_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"]][d][dd] = [];
            createWestNeighborSkirt(d + 1, dd, wt);
            createNorthNeighborSkirt(d + 1, dd, nt);
            createEastNeighborSkirt(d + 1, dd, et);
            createSouthNeighborSkirt(d + 1, dd, st);
        }
    }
    return table;
};

function initTextureCoordsTable(pow) {
    var table = [];
    for (var i = 0; i <= pow; i++) {
        var d = Math.pow(2, i);
        table[d] = createTextureCoords(d);
    }
    table[0] = [];
    return table;
};

function initIndexBodiesTable(pow) {
    var table = [];
    for (var i = 0; i <= pow; i++) {
        var d = Math.pow(2, i);
        var t = table[d] = [];
        createCenterBodyIndexes(d + 1, t);
    }
    table[0] = [];
    return table;
};

function createTextureCoords(size) {
    var texCoords = [];
    for (var i = 0; i <= size; i++) {
        for (var j = 0; j <= size; j++) {
            texCoords.push(j / size, i / size);
        }
    }
    return new Float32Array(texCoords);
};

/***/ }),

/***/ "./src/og/shaders/billboard.js":
/*!*************************************!*\
  !*** ./src/og/shaders/billboard.js ***!
  \*************************************/
/*! exports provided: billboard, billboardPicking */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "billboard", function() { return billboard; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "billboardPicking", function() { return billboardPicking; });
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/shaders/billboard
 */

'use sctrict';




function billboard(isSingleBuffer) {

    var strFragment;
    if (isSingleBuffer) {
        strFragment = 'precision highp float;\n\
            uniform sampler2D u_texture;\
            varying vec2 v_texCoords;\
            varying vec4 v_rgba;\
            void main () {\
                vec4 color = texture2D(u_texture, v_texCoords);\
                if(color.a < 0.1)\
                    discard;\
                gl_FragColor = color * v_rgba;\
            }';
    } else {
        strFragment = '#extension GL_EXT_draw_buffers : require\n\
            precision highp float;\n\
            uniform sampler2D u_texture;\
            varying vec2 v_texCoords;\
            varying vec4 v_rgba;\
            void main () {\
                vec4 color = texture2D(u_texture, v_texCoords);\
                if(color.a < 0.1)\
                    discard;\
                gl_FragData[0] = color * v_rgba;\
                gl_FragData[1] = vec4(0.0);\
            }';
    }

    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("billboard", {
        uniforms: {
            u_texture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            uCamPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uFloatParams: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
            uScaleByDistance: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uOpacity: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            a_vertices: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_texCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_positions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_size: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_offset: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_rgba: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_rotation: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_alignedAxis: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true }
        },
        vertexShader:
        'precision highp float;\n\
            attribute vec2 a_vertices;\
            attribute vec2 a_texCoord;\
            attribute vec4 a_positions;\
            attribute vec3 a_offset;\
            attribute vec2 a_size;\
            attribute float a_rotation;\
            attribute vec4 a_rgba;\
            attribute vec3 a_alignedAxis;\
            varying vec2 v_texCoords;\
            varying vec4 v_rgba;\
            uniform mat4 viewMatrix;\
            uniform mat4 projectionMatrix;\
            uniform vec3 uCamPos;\
            uniform vec2 uFloatParams;\
            uniform vec3 uScaleByDistance;\
            uniform float uOpacity;\
            const vec3 ZERO3 = vec3(0.0);\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main() {\
                v_texCoords = a_texCoord;\
                vec3 look = a_positions.xyz - uCamPos;\
                float lookLength = length(look);\
                v_rgba = a_rgba;\
                /*v_rgba.a *= uOpacity * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions.xyz,a_positions.xyz) - uFloatParams[0]));*/\
                if(uOpacity * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions.xyz,a_positions.xyz) - uFloatParams[0])) == 0.0){\
                    return;\
                }\
                vec3 right, up;\
                if(a_alignedAxis == ZERO3){\
                    up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );\
                    right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );\
                }else{\
                    up = normalize(a_alignedAxis);\
                    right = normalize(cross(look,up));\
                    look = cross(up,right);\
                }\
                float dist = dot(uCamPos - a_positions.xyz, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));\
                float focalSize = 2.0 * dist * uFloatParams[1];\
                vec2 offset = a_offset.xy * focalSize;\
                float scd = a_positions.w * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookLength)) * (1.0 - step(uScaleByDistance[2], lookLength));\
                vec2 scale = a_size * focalSize * scd;\
                float cosRot = cos(a_rotation);\
                float sinRot = sin(a_rotation);\
                vec3 rr = (right * cosRot - up * sinRot) * (scale.x * a_vertices.x + scd * offset.x) + (right * sinRot + up * cosRot) * (scale.y * a_vertices.y + scd * offset.y) + a_positions.xyz;\
                gl_Position = projectionMatrix * viewMatrix * vec4(rr, 1);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                gl_Position.z += a_offset.z;\
            }',
        fragmentShader:
        strFragment
    });
};

function billboardPicking() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("billboardPicking", {
        uniforms: {
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            uCamPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uFloatParams: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
            uScaleByDistance: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uOpacity: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            a_vertices: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_positions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_size: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_offset: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_pickingColor: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_rotation: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_alignedAxis: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true }
        },
        vertexShader:
        'precision highp float;\n\
            attribute vec2 a_vertices;\
            attribute vec4 a_positions;\
            attribute vec3 a_offset;\
            attribute vec2 a_size;\
            attribute float a_rotation;\
            attribute vec3 a_pickingColor;\
            attribute vec3 a_alignedAxis;\
            varying vec4 v_color;\
            uniform mat4 viewMatrix;\
            uniform mat4 projectionMatrix;\
            uniform vec3 uCamPos;\
            uniform vec2 uFloatParams;\
            uniform vec3 uScaleByDistance;\
            uniform float uOpacity;\
            const vec3 ZERO3 = vec3(0.0);\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main() {\
                vec3 look = a_positions.xyz - uCamPos;\
                float lookLength = length(look);\
                if( uOpacity == 0.0 ) {\
                    gl_Position = vec4(0.0);\
                    return;\
                }\
                v_color = vec4(a_pickingColor.rgb, 1.0) * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions.xyz, a_positions.xyz) - uFloatParams[0]));\
                vec3 right, up;\
                if(a_alignedAxis == ZERO3){\
                    up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );\
                    right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );\
                }else{\
                    up = normalize(a_alignedAxis);\
                    right = normalize(cross(look,up));\
                    look = cross(up,right);\
                }\
                float dist = dot(uCamPos - a_positions.xyz, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));\
                float focalSize = 2.0 * dist * uFloatParams[1];\
                vec2 offset = a_offset.xy * focalSize;\
                float scd = a_positions.w * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookLength)) *(1.0 - step(uScaleByDistance[2], lookLength));\
                vec2 scale = a_size * focalSize * scd;\
                float cosRot = cos(a_rotation);\
                float sinRot = sin(a_rotation);\
                vec3 rr = (right * cosRot - up * sinRot) * (scale.x * a_vertices.x + scd * offset.x) + (right * sinRot + up * cosRot) * (scale.y * a_vertices.y + scd * offset.y) + a_positions.xyz;\
                gl_Position = projectionMatrix * viewMatrix * vec4(rr, 1);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                gl_Position.z += a_offset.z;\
            }',
        fragmentShader:
        'precision highp float;\n\
            varying vec4 v_color;\
            void main () {\
                gl_FragColor = v_color;\
            }'
    });
};

/***/ }),

/***/ "./src/og/shaders/drawnode.js":
/*!************************************!*\
  !*** ./src/og/shaders/drawnode.js ***!
  \************************************/
/*! exports provided: drawnode_nl, drawnode_screen_nl, drawnode_colorPicking, drawnode_heightPicking, drawnode_wl, drawnode_screen_wl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawnode_nl", function() { return drawnode_nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawnode_screen_nl", function() { return drawnode_screen_nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawnode_colorPicking", function() { return drawnode_colorPicking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawnode_heightPicking", function() { return drawnode_heightPicking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawnode_wl", function() { return drawnode_wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawnode_screen_wl", function() { return drawnode_screen_wl; });
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/shaders/drawnode
 */

'use sctrict';





function drawnode_nl() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("drawnode_nl", {
        uniforms: {
            projectionViewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            samplerCount: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].INT },
            tileOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            visibleExtentOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            samplerArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            pickingMaskArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            transparentColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            pickingColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            defaultTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            height: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
            cameraPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionViewMatrix;\
            uniform float height;\
            uniform vec3 cameraPosition;\
            varying vec2 vTextureCoord;\
            varying float range;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                range = distance(cameraPosition, aVertexPosition + normalize(aVertexPosition) * height);\
                vTextureCoord = aTextureCoord;\
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + normalize(aVertexPosition) * height, 1.0);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        '#extension GL_EXT_draw_buffers : require\n\
            precision highp float;\n\
            uniform vec4 tileOffsetArr[5];\
            uniform vec4 visibleExtentOffsetArr[5];\
            uniform vec4 transparentColorArr[5];\
            uniform vec3 pickingColorArr[5];\
            uniform sampler2D defaultTexture;\
            uniform sampler2D samplerArr[5];\
            uniform sampler2D pickingMaskArr[5];\
            uniform int samplerCount;\
            varying vec2 vTextureCoord;\
            varying float range;\
            const float oneBy255 = 1.0 / 255.0;\
            /* return 1 if v inside the box, return 0 otherwise */\
            float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\
                vec2 s = step(bottomLeft, v) - step(topRight, v);\
                return s.x * s.y;\
            }\
            vec3 encode24(highp float f) {\
                float F = abs(f);\
                float s = step( 0.0, -f );\
                float e = floor( log2(F) );\
                float m = exp2(- e) * F;\
                e = floor( log2(F) + 127.0 ) + floor( log2(m) );\
                return vec3(\
                    ( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,\
                    ( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,\
                    floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);\
            }\
            const vec2 BOTTOMLEFT = vec2(0.0);\
            const vec2 TOPRIGHT = vec2(1.0);\
            void main(void) {\
                gl_FragData[0] = texture2D( defaultTexture, vTextureCoord );\
                gl_FragData[1] = vec4(0.0);\
                gl_FragData[2] = vec4(encode24(range), gl_FragData[0].a);\
                if( samplerCount == 0 ) return;\
\
                vec2 tc = tileOffsetArr[0].xy + vTextureCoord.xy * tileOffsetArr[0].zw;\
                float ins = insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord.xy * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);\
                vec4 t = texture2D( samplerArr[0], tc ) * ins;\
                vec4 p = texture2D( pickingMaskArr[0], tc ) * ins;\
                float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb, 1.0), transparentColorArr[0].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = vec4(max(pickingColorArr[0], p.rgb), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(encode24(range), 1.0), emptiness);\
                if( samplerCount == 1 ) return;\
\
                tc = tileOffsetArr[1].xy + vTextureCoord.xy * tileOffsetArr[1].zw;\
                ins = insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord.xy * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[1], tc ) * ins;\
                p = texture2D( pickingMaskArr[1], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb, 1.0), transparentColorArr[1].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[1], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(encode24(range), 1.0), emptiness);\
                if( samplerCount == 2 ) return;\
\
                tc = tileOffsetArr[2].xy + vTextureCoord.xy * tileOffsetArr[2].zw;\
                ins = insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord.xy * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[2], tc ) * ins;\
                p = texture2D( pickingMaskArr[2], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb, 1.0), transparentColorArr[2].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[2], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(encode24(range), 1.0), emptiness);\
                if( samplerCount == 3 ) return;\
\
                tc = tileOffsetArr[3].xy + vTextureCoord.xy * tileOffsetArr[3].zw;\
                ins = insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord.xy * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[3], tc ) * ins;\
                p = texture2D( pickingMaskArr[3], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb, 1.0), transparentColorArr[3].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[3], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(encode24(range), 1.0), emptiness);\
                if( samplerCount == 4 ) return;\
\
                tc = tileOffsetArr[4].xy + vTextureCoord.xy * tileOffsetArr[4].zw;\
                ins = insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord.xy * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[4], tc ) * ins;\
                p = texture2D( pickingMaskArr[4], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb, 1.0), transparentColorArr[4].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[4], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(encode24(range), 1.0), emptiness);\
            }'
    });
};

function drawnode_screen_nl() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("drawnode_screen_nl", {
        uniforms: {
            projectionViewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            samplerCount: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].INT },
            tileOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            visibleExtentOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            samplerArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            transparentColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            defaultTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            height: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionViewMatrix;\
            uniform float height;\
            varying vec2 vTextureCoord;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                vTextureCoord = aTextureCoord;\
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + normalize(aVertexPosition) * height, 1.0);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        'precision highp float;\n\
            uniform vec4 tileOffsetArr[5];\
            uniform vec4 visibleExtentOffsetArr[5];\
            uniform vec4 transparentColorArr[5];\
            uniform sampler2D defaultTexture;\
            uniform sampler2D samplerArr[5];\
            uniform int samplerCount;\
            varying vec2 vTextureCoord;\
            /* return 1 if v inside the box, return 0 otherwise */\
            float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\
                vec2 s = step(bottomLeft, v) - step(topRight, v);\
                return s.x * s.y;\
            }\
            const vec2 BOTTOMLEFT = vec2(0.0);\
            const vec2 TOPRIGHT = vec2(1.0);\
            void main(void) {\
                gl_FragColor = texture2D( defaultTexture, vTextureCoord );\
                if( samplerCount == 0 ) return;\
\
                vec4 t = texture2D( samplerArr[0], tileOffsetArr[0].xy + vTextureCoord * tileOffsetArr[0].zw ) * insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);\
                float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb, 1.0), transparentColorArr[0].a * t.a * emptiness);\
                if( samplerCount == 1 ) return;\
\
                t = texture2D( samplerArr[1], tileOffsetArr[1].xy + vTextureCoord * tileOffsetArr[1].zw ) * insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb, 1.0), transparentColorArr[1].a * t.a * emptiness);\
                if( samplerCount == 2 ) return;\
\
                t = texture2D( samplerArr[2], tileOffsetArr[2].xy + vTextureCoord * tileOffsetArr[2].zw ) * insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb, 1.0), transparentColorArr[2].a * t.a * emptiness);\
                if( samplerCount == 3 ) return;\
\
                t = texture2D( samplerArr[3], tileOffsetArr[3].xy + vTextureCoord * tileOffsetArr[3].zw ) * insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb, 1.0), transparentColorArr[3].a * t.a * emptiness);\
                if( samplerCount == 4 ) return;\
\
                t = texture2D( samplerArr[4], tileOffsetArr[4].xy + vTextureCoord * tileOffsetArr[4].zw ) * insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb, 1.0), transparentColorArr[4].a * t.a * emptiness);\
            }'
    });
};

function drawnode_colorPicking() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("drawnode_colorPicking", {
        uniforms: {
            projectionViewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            samplerCount: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].INT },
            tileOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            visibleExtentOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            samplerArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            pickingMaskArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            transparentColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            pickingColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            height: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionViewMatrix;\
            uniform float height;\
            varying vec2 vTextureCoord;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                vTextureCoord = aTextureCoord;\
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + normalize(aVertexPosition) * height, 1.0);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        'precision highp float;\n\
            uniform vec4 tileOffsetArr[5];\
            uniform vec4 visibleExtentOffsetArr[5];\
            uniform vec4 transparentColorArr[5];\
            uniform vec3 pickingColorArr[5];\
            uniform sampler2D samplerArr[5];\
            uniform sampler2D pickingMaskArr[5];\
            uniform int samplerCount;\
            varying vec2 vTextureCoord;\
            /* return 1 if v inside the box, return 0 otherwise */\
            float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\
                vec2 s = step(bottomLeft, v) - step(topRight, v);\
                return s.x * s.y;\
            }\
            const vec2 BOTTOMLEFT = vec2(0.0);\
            const vec2 TOPRIGHT = vec2(1.0);\
            void main(void) {\
                gl_FragColor = vec4(0.0);\
                if( samplerCount == 0 ) return;\
\
                vec2 tc = tileOffsetArr[0].xy + vTextureCoord.xy * tileOffsetArr[0].zw;\
                float ins = insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord.xy * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);\
                vec4 t = texture2D( samplerArr[0], tc ) * ins;\
                vec4 p = texture2D( pickingMaskArr[0], tc ) * ins;\
                float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));\
                gl_FragColor = vec4(max(pickingColorArr[0], p.rgb), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 1 ) return;\
\
                tc = tileOffsetArr[1].xy + vTextureCoord.xy * tileOffsetArr[1].zw;\
                ins = insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord.xy * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[1], tc ) * ins;\
                p = texture2D( pickingMaskArr[1], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(max(pickingColorArr[1], p.rgb), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 2 ) return;\
\
                tc = tileOffsetArr[2].xy + vTextureCoord.xy * tileOffsetArr[2].zw;\
                ins = insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord.xy * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[2], tc ) * ins;\
                p = texture2D( pickingMaskArr[2], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(max(pickingColorArr[2], p.rgb), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 3 ) return;\
\
                tc = tileOffsetArr[3].xy + vTextureCoord.xy * tileOffsetArr[3].zw;\
                ins = insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord.xy * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[3], tc ) * ins;\
                p = texture2D( pickingMaskArr[3], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(max(pickingColorArr[3], p.rgb), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 4 ) return;\
\
                tc = tileOffsetArr[4].xy + vTextureCoord.xy * tileOffsetArr[4].zw;\
                ins = insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord.xy * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[4], tc ) * ins;\
                p = texture2D( pickingMaskArr[4], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(max(pickingColorArr[4], p.rgb), 1.0), 1.0 - step(0.0, -emptiness));\
            }'
    });
};

function drawnode_heightPicking() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("drawnode_heightPicking", {
        uniforms: {
            projectionViewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            samplerCount: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].INT },
            tileOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            visibleExtentOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            samplerArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            transparentColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            defaultTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            height: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
            cameraPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionViewMatrix;\
            uniform float height;\
            uniform vec3 cameraPosition;\
            varying vec2 vTextureCoord;\
            varying float range;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                range = distance(cameraPosition, aVertexPosition + normalize(aVertexPosition) * height);\
                vTextureCoord = aTextureCoord;\
                gl_Position = projectionViewMatrix * vec4(aVertexPosition + normalize(aVertexPosition) * height, 1.0);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        'precision highp float;\n\
            uniform sampler2D defaultTexture;\
            uniform vec4 tileOffsetArr[5];\
            uniform vec4 visibleExtentOffsetArr[5];\
            uniform vec4 transparentColorArr[5];\
            uniform sampler2D samplerArr[5];\
            uniform int samplerCount;\
            varying vec2 vTextureCoord;\
            varying float range;\
            const float oneBy255 = 1.0 / 255.0;\
            /* return 1 if v inside the box, return 0 otherwise */\
            float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\
                vec2 s = step(bottomLeft, v) - step(topRight, v);\
                return s.x * s.y;\
            }\
            vec3 encode24(highp float f) {\
                float F = abs(f);\
                float s = step( 0.0, -f );\
                float e = floor( log2(F) );\
                float m = exp2(- e) * F;\
                e = floor( log2(F) + 127.0 ) + floor( log2(m) );\
                return vec3(\
                    ( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,\
                    ( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,\
                    floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);\
            }\
            const vec2 BOTTOMLEFT = vec2(0.0);\
            const vec2 TOPRIGHT = vec2(1.0);\
            void main(void) {\
                gl_FragColor = vec4(encode24(range), texture2D( defaultTexture, vTextureCoord ).a);\
                if( samplerCount == 0 ) return;\
\
                vec4 t = texture2D( samplerArr[0], tileOffsetArr[0].xy + vTextureCoord * tileOffsetArr[0].zw ) * insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);\
                float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(encode24(range), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 1 ) return;\
\
                t = texture2D( samplerArr[1], tileOffsetArr[1].xy + vTextureCoord * tileOffsetArr[1].zw ) * insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(encode24(range), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 2 ) return;\
\
                t = texture2D( samplerArr[2], tileOffsetArr[2].xy + vTextureCoord * tileOffsetArr[2].zw ) * insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(encode24(range), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 3 ) return;\
\
                t = texture2D( samplerArr[3], tileOffsetArr[3].xy + vTextureCoord * tileOffsetArr[3].zw ) * insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(encode24(range), 1.0), 1.0 - step(0.0, -emptiness));\
                if( samplerCount == 4 ) return;\
\
                t = texture2D( samplerArr[4], tileOffsetArr[4].xy + vTextureCoord * tileOffsetArr[4].zw ) * insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(encode24(range), 1.0), 1.0 - step(0.0, -emptiness));\
            }'
    });
};



function drawnode_wl() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("drawnode_wl", {
        uniforms: {
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            samplerCount: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].INT },
            tileOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            visibleExtentOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            samplerArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            pickingMaskArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            transparentColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            pickingColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            defaultTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            height: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
            cameraPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uGlobalTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            normalMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT3 },
            uNormalMap: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            uNormalMapBias: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            nightTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            specularTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            lightsPositions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            diffuseMaterial: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            ambientMaterial: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            specularMaterial: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionMatrix;\
            uniform mat4 viewMatrix;\
            uniform float height;\
            uniform vec3 cameraPosition;\
            uniform vec4 uGlobalTextureCoord;\
            uniform vec3 uNormalMapBias;\
            varying vec4 vTextureCoord;\
            varying float range;\
            varying vec2 vGlobalTextureCoord;\
            varying vec4 v_vertex;\
            varying float v_height;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                v_height = height;\
                vec3 heightVertex = aVertexPosition + normalize(aVertexPosition) * height;\
                v_vertex = viewMatrix * vec4(heightVertex, 1.0);\
                range = distance(cameraPosition, heightVertex);\
                vTextureCoord.xy = aTextureCoord;\
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;\
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );\
                gl_Position = projectionMatrix * v_vertex;\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        '#extension GL_EXT_draw_buffers : require\n\
            precision highp float;\n\
\n\
            #define MAX_POINT_LIGHTS 1\n\
            #define MAX_OVERLAYS 5\n\
            #define MAX_OVERLAYS_PLUS_ONE 6\n\
\
            uniform vec3 diffuseMaterial[MAX_OVERLAYS_PLUS_ONE];\
            uniform vec3 ambientMaterial[MAX_OVERLAYS_PLUS_ONE];\
            uniform vec4 specularMaterial[MAX_OVERLAYS_PLUS_ONE];\
\
            uniform sampler2D uNormalMap;\
            uniform vec4 lightsPositions[MAX_POINT_LIGHTS];\
            uniform mat3 normalMatrix;\
            uniform sampler2D nightTexture;\
            uniform sampler2D specularTexture;\
\
            uniform vec4 tileOffsetArr[MAX_OVERLAYS];\
            uniform vec4 visibleExtentOffsetArr[MAX_OVERLAYS];\
            uniform vec4 transparentColorArr[MAX_OVERLAYS];\
            uniform vec3 pickingColorArr[MAX_OVERLAYS];\
\
            uniform sampler2D defaultTexture;\
            uniform sampler2D samplerArr[MAX_OVERLAYS];\
            uniform sampler2D pickingMaskArr[MAX_OVERLAYS];\
            uniform int samplerCount;\
\
            varying vec4 vTextureCoord;\
            varying float range;\
            varying vec2 vGlobalTextureCoord;\
            varying vec4 v_vertex;\
            varying float v_height;\
\
            /* return 1 if v inside the box, return 0 otherwise */\
            float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\
                vec2 s = step(bottomLeft, v) - step(topRight, v);\
                return s.x * s.y;\
            }\
\
            vec3 encode24(highp float f) {\
                float F = abs(f);\
                float s = step( 0.0, -f );\
                float e = floor( log2(F) );\
                float m = exp2(- e) * F;\
                e = floor( log2(F) + 127.0 ) + floor( log2(m) );\
                return vec3(\
                    ( 128.0 * s + floor( e * exp2(-1.0) ) ) / 255.0,\
                    ( 128.0 * mod( e, 2.0 ) + mod( floor( m * 128.0 ), 128.0 ) ) / 255.0,\
                    floor( mod( floor( m * exp2( 23.0 - 8.0) ), exp2(8.0) ) ) / 255.0);\
            }\
\
            const vec2 BOTTOMLEFT = vec2(0.0);\
            const vec2 TOPRIGHT = vec2(1.0);\
            const vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\
\
            void main(void) {\
\
                vec3 range24 = encode24(range);\
                float overGround = 1.0 - step(0.1, v_height);\
                vec3 normal = normalize(normalMatrix * ((texture2D(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));\
                vec3 lightDirection = normalize(lightsPositions[0].xyz - v_vertex.xyz * lightsPositions[0].w);\
                vec3 eyeDirection = normalize(-v_vertex.xyz);\
                vec3 reflectionDirection = reflect(-lightDirection, normal);\
                vec4 nightImageColor = texture2D( nightTexture, vGlobalTextureCoord );\
                float shininess = texture2D( specularTexture, vGlobalTextureCoord ).r * 255.0 * overGround;\
                float reflection = max( dot(reflectionDirection, eyeDirection), 0.0);\
                float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\
                vec3 night = nightStep * (0.3 - diffuseLightWeighting) * nightImageColor.rgb;\
                night *= overGround * step(0.0, night);\
\
\
\
                vec3 spec = specularMaterial[0].rgb * pow( reflection, specularMaterial[0].w) * shininess;\
                vec3 lightWeighting = ambientMaterial[0] + diffuseMaterial[0] * diffuseLightWeighting + spec;\
\
                vec4 t = texture2D( defaultTexture, vTextureCoord.xy );\
                gl_FragData[0] = vec4(t.rgb * lightWeighting + night + spec, t.a);\
                gl_FragData[1] = vec4(0.0);\
                gl_FragData[2] = vec4(range24, gl_FragData[0].a);\
                if( samplerCount == 0 ) return;\
\
\
\
                spec = specularMaterial[1].rgb * pow( reflection, specularMaterial[1].w) * (1.0 + shininess);\
                lightWeighting = ambientMaterial[1] + diffuseMaterial[1] * diffuseLightWeighting + spec;\
\
                vec2 tc = tileOffsetArr[0].xy + vTextureCoord.xy * tileOffsetArr[0].zw;\
                float ins = insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord.xy * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[0], tc ) * ins;\
                vec4 p = texture2D( pickingMaskArr[0], tc ) * ins;\
                float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[0].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = vec4(max(pickingColorArr[0], p.rgb), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);\
                if( samplerCount == 1 ) return;\
\
\
\
                spec = specularMaterial[2].rgb * pow( reflection, specularMaterial[2].w);\
                lightWeighting = ambientMaterial[2] + diffuseMaterial[2] * diffuseLightWeighting + spec;\
\
                tc = tileOffsetArr[1].xy + vTextureCoord.xy * tileOffsetArr[1].zw;\
                ins = insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord.xy * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[1], tc ) * ins;\
                p = texture2D( pickingMaskArr[1], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[1].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[1], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);\
                if( samplerCount == 2 ) return;\
\
\
\
                spec = specularMaterial[3].rgb * pow( reflection, specularMaterial[3].w);\
                lightWeighting = ambientMaterial[3] + diffuseMaterial[3] * diffuseLightWeighting + spec;\
\
                tc = tileOffsetArr[2].xy + vTextureCoord.xy * tileOffsetArr[2].zw;\
                ins = insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord.xy * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[2], tc ) * ins;\
                p = texture2D( pickingMaskArr[2], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[2].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[2], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);\
                if( samplerCount == 3 ) return;\
\
\
\
                spec = specularMaterial[4].rgb * pow( reflection, specularMaterial[4].w);\
                lightWeighting = ambientMaterial[4] + diffuseMaterial[4] * diffuseLightWeighting + spec;\
\
                tc = tileOffsetArr[3].xy + vTextureCoord.xy * tileOffsetArr[3].zw;\
                ins = insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord.xy * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[3], tc ) * ins;\
                p = texture2D( pickingMaskArr[3], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[3].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[3], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);\
                if( samplerCount == 4 ) return;\
\
\
\
                spec = specularMaterial[5].rgb * pow( reflection, specularMaterial[5].w);\
                lightWeighting = ambientMaterial[5] + diffuseMaterial[5] * diffuseLightWeighting + spec;\
\
                tc = tileOffsetArr[4].xy + vTextureCoord.xy * tileOffsetArr[4].zw;\
                ins = insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord.xy * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);\
                t = texture2D( samplerArr[4], tc ) * ins;\
                p = texture2D( pickingMaskArr[4], tc ) * ins;\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));\
                gl_FragData[0] = mix( gl_FragData[0], vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[4].a * t.a * emptiness);\
                emptiness = 1.0 - step(0.0, -emptiness);\
                gl_FragData[1] = mix( gl_FragData[1], vec4(max(pickingColorArr[4], p.rgb), 1.0), emptiness);\
                gl_FragData[2] = mix( gl_FragData[2], vec4(range24, 1.0), emptiness);\
            }'
    });
};

function drawnode_screen_wl() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("drawnode_screen_wl", {
        uniforms: {
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            samplerCount: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].INT },
            tileOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            visibleExtentOffsetArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            samplerArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            transparentColorArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            defaultTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            height: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
            normalMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT3 },
            uNormalMap: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            uNormalMapBias: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uGlobalTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            nightTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            specularTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D },
            lightsPositions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            diffuseMaterial: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            ambientMaterial: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            specularMaterial: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionMatrix;\
            uniform mat4 viewMatrix;\
            uniform float height;\
            uniform vec4 uGlobalTextureCoord;\
            uniform vec3 uNormalMapBias;\
            varying vec4 vTextureCoord;\
            varying vec2 vGlobalTextureCoord;\
            varying vec4 v_vertex;\
            varying float v_height;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                v_height = height;\
                vec3 heightVertex = aVertexPosition + normalize(aVertexPosition) * height;\
                v_vertex = viewMatrix * vec4(heightVertex, 1.0);\
                vTextureCoord.xy = aTextureCoord;\
                vGlobalTextureCoord = uGlobalTextureCoord.xy + (uGlobalTextureCoord.zw - uGlobalTextureCoord.xy) * aTextureCoord;\
                vTextureCoord.zw = uNormalMapBias.z * ( aTextureCoord + uNormalMapBias.xy );\
                gl_Position = projectionMatrix * v_vertex;\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        'precision highp float;\n\
\n\
            #define MAX_POINT_LIGHTS 1\n\
            #define MAX_OVERLAYS 5\n\
            #define MAX_OVERLAYS_PLUS_ONE 6\n\
\
            uniform vec3 diffuseMaterial[MAX_OVERLAYS_PLUS_ONE];\
            uniform vec3 ambientMaterial[MAX_OVERLAYS_PLUS_ONE];\
            uniform vec4 specularMaterial[MAX_OVERLAYS_PLUS_ONE];\
\
            uniform sampler2D uNormalMap;\
            uniform vec4 lightsPositions[MAX_POINT_LIGHTS];\
            uniform mat3 normalMatrix;\
            uniform sampler2D nightTexture;\
            uniform sampler2D specularTexture;\
\
            uniform vec4 tileOffsetArr[MAX_OVERLAYS];\
            uniform vec4 visibleExtentOffsetArr[MAX_OVERLAYS];\
            uniform vec4 transparentColorArr[MAX_OVERLAYS];\
\
            uniform sampler2D defaultTexture;\
            uniform sampler2D samplerArr[MAX_OVERLAYS];\
            uniform int samplerCount;\
\
            varying vec4 vTextureCoord;\
            varying vec2 vGlobalTextureCoord;\
            varying vec4 v_vertex;\
            varying float v_height;\
\
            /* return 1 if v inside the box, return 0 otherwise */\
            float insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\
                vec2 s = step(bottomLeft, v) - step(topRight, v);\
                return s.x * s.y;\
            }\
\
            const vec2 BOTTOMLEFT = vec2(0.0);\
            const vec2 TOPRIGHT = vec2(1.0);\
            const vec3 nightStep = 10.0 * vec3(0.58, 0.48, 0.25);\
\
            void main(void) {\
\
                float overGround = 1.0 - step(0.1, v_height);\
                vec3 normal = normalize(normalMatrix * ((texture2D(uNormalMap, vTextureCoord.zw).rgb - 0.5) * 2.0));\
                vec3 lightDirection = normalize(lightsPositions[0].xyz - v_vertex.xyz * lightsPositions[0].w);\
                vec3 eyeDirection = normalize(-v_vertex.xyz);\
                vec3 reflectionDirection = reflect(-lightDirection, normal);\
                vec4 nightImageColor = texture2D( nightTexture, vGlobalTextureCoord.st );\
                float shininess = texture2D( specularTexture, vGlobalTextureCoord.st ).r * 255.0 * overGround;\
                float reflection = max( dot(reflectionDirection, eyeDirection), 0.0);\
                float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\
                vec3 night = nightStep * (0.3 - diffuseLightWeighting) * nightImageColor.rgb;\
                night *= overGround * step(0.0, night);\
\
\
\
                vec3 spec = specularMaterial[0].rgb * pow( reflection, specularMaterial[0].w) * shininess;\
                vec3 lightWeighting = ambientMaterial[0] + diffuseMaterial[0] * diffuseLightWeighting + spec;\
\
                vec4 t = texture2D( defaultTexture, vTextureCoord.xy );\
                gl_FragColor = vec4(t.rgb * lightWeighting + night + spec, t.a);\
                if( samplerCount == 0 ) return;\
\
\
\
                spec = specularMaterial[1].rgb * pow( reflection, specularMaterial[1].w) * (1.0 + shininess);\
                lightWeighting = ambientMaterial[1] + diffuseMaterial[1] * diffuseLightWeighting + spec;\
\
                t = texture2D( samplerArr[0], tileOffsetArr[0].xy + vTextureCoord.xy * tileOffsetArr[0].zw ) * insideBox(visibleExtentOffsetArr[0].xy + vTextureCoord.xy * visibleExtentOffsetArr[0].zw, BOTTOMLEFT, TOPRIGHT);\
                float emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[0].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[0].a * t.a * emptiness);\
                if( samplerCount == 1 ) return;\
\
\
\
                spec = specularMaterial[2].rgb * pow( reflection, specularMaterial[2].w);\
                lightWeighting = ambientMaterial[2] + diffuseMaterial[2] * diffuseLightWeighting + spec;\
\
                t = texture2D( samplerArr[1], tileOffsetArr[1].xy + vTextureCoord.xy * tileOffsetArr[1].zw ) * insideBox(visibleExtentOffsetArr[1].xy + vTextureCoord.xy * visibleExtentOffsetArr[1].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[1].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[1].a * t.a * emptiness);\
                if( samplerCount == 2 ) return;\
\
\
\
                spec = specularMaterial[3].rgb * pow( reflection, specularMaterial[3].w);\
                lightWeighting = ambientMaterial[3] + diffuseMaterial[3] * diffuseLightWeighting + spec;\
\
                t = texture2D( samplerArr[2], tileOffsetArr[2].xy + vTextureCoord.xy * tileOffsetArr[2].zw ) * insideBox(visibleExtentOffsetArr[2].xy + vTextureCoord.xy * visibleExtentOffsetArr[2].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[2].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[2].a * t.a * emptiness);\
                if( samplerCount == 3 ) return;\
\
\
\
                spec = specularMaterial[4].rgb * pow( reflection, specularMaterial[4].w);\
                lightWeighting = ambientMaterial[4] + diffuseMaterial[4] * diffuseLightWeighting + spec;\
\
                t = texture2D( samplerArr[3], tileOffsetArr[3].xy + vTextureCoord.xy * tileOffsetArr[3].zw ) * insideBox(visibleExtentOffsetArr[3].xy + vTextureCoord.xy * visibleExtentOffsetArr[3].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[3].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[3].a * t.a * emptiness);\
                if( samplerCount == 4 ) return;\
\
\
\
                spec = specularMaterial[5].rgb * pow( reflection, specularMaterial[5].w);\
                lightWeighting = ambientMaterial[5] + diffuseMaterial[5] * diffuseLightWeighting + spec;\
\
                t = texture2D( samplerArr[4], tileOffsetArr[4].xy + vTextureCoord.xy * tileOffsetArr[4].zw ) * insideBox(visibleExtentOffsetArr[4].xy + vTextureCoord.xy * visibleExtentOffsetArr[4].zw, BOTTOMLEFT, TOPRIGHT);\
                emptiness = t.a * smoothstep(0.35, 0.5, distance( t.rgb, transparentColorArr[4].rgb ));\
                gl_FragColor = mix( gl_FragColor, vec4(t.rgb * lightWeighting + night + spec, 1.0), transparentColorArr[4].a * t.a * emptiness);\
            }'
    });
};

/***/ }),

/***/ "./src/og/shaders/label.js":
/*!*********************************!*\
  !*** ./src/og/shaders/label.js ***!
  \*********************************/
/*! exports provided: label, labelPicking */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "label", function() { return label; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelPicking", function() { return labelPicking; });
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/shaders/label
 */

'use sctrict';




function label(isSingleBuffer) {

    var strFragment;

    if (isSingleBuffer) {
        strFragment = '#extension GL_OES_standard_derivatives : enable\n\
            precision highp float;\n\
            const int MAX_SIZE = 12;\
            uniform sampler2D u_fontTextureArr[MAX_SIZE];\
            varying float v_fontIndex;\
            varying vec2 v_texCoords;\
            varying vec4 v_rgba;\
            varying vec3 v_bufferAA;\
            varying vec3 v_pickingColor;\
            void main () {\
                int fi = int(v_fontIndex);\
                vec4 color;\
                if (fi == 0) {\
                    color = texture2D(u_fontTextureArr[0], v_texCoords);\
                } else if (fi == 1) {\
                    color = texture2D(u_fontTextureArr[1], v_texCoords);\
                } else if (fi == 2) {\
                    color = texture2D(u_fontTextureArr[2], v_texCoords);\
                } else if (fi == 3) {\
                    color = texture2D(u_fontTextureArr[3], v_texCoords);\
                } else if (fi == 4) {\
                    color = texture2D(u_fontTextureArr[4], v_texCoords);\
                } else if (fi == 5) {\
                    color = texture2D(u_fontTextureArr[5], v_texCoords);\
                } else if (fi == 6) {\
                    color = texture2D(u_fontTextureArr[6], v_texCoords);\
                } else if (fi == 7) {\
                    color = texture2D(u_fontTextureArr[7], v_texCoords);\
                } else if (fi == 8) {\
                    color = texture2D(u_fontTextureArr[8], v_texCoords);\
                } else if (fi == 9) {\
                    color = texture2D(u_fontTextureArr[9], v_texCoords);\
                }else{\
                    color = texture2D(u_fontTextureArr[10], v_texCoords);\
                }\
                float afwidth = step(0.5, v_bufferAA.x) * (1.0 - v_bufferAA.y) * v_bufferAA.x * fwidth( color.r );\
                float alpha = smoothstep ( v_bufferAA.x - afwidth - v_bufferAA.z, v_bufferAA.x + afwidth + v_bufferAA.z, color.r );\
                if( alpha < 0.2 )\
                    discard;\
                gl_FragColor = vec4(v_rgba.rgb, alpha * v_rgba.a);\
            }';
    } else {
        strFragment = '#extension GL_OES_standard_derivatives : enable\n\
            #extension GL_EXT_draw_buffers : require\n\
            precision highp float;\n\
            const int MAX_SIZE = 12;\
            uniform sampler2D u_fontTextureArr[MAX_SIZE];\
            varying float v_fontIndex;\
            varying vec2 v_texCoords;\
            varying vec4 v_rgba;\
            varying vec3 v_bufferAA;\
            varying vec3 v_pickingColor;\
            void main () {\
                int fi = int(v_fontIndex);\
                vec4 color;\
                if (fi == 0) {\
                    color = texture2D(u_fontTextureArr[0], v_texCoords);\
                } else if (fi == 1) {\
                    color = texture2D(u_fontTextureArr[1], v_texCoords);\
                } else if (fi == 2) {\
                    color = texture2D(u_fontTextureArr[2], v_texCoords);\
                } else if (fi == 3) {\
                    color = texture2D(u_fontTextureArr[3], v_texCoords);\
                } else if (fi == 4) {\
                    color = texture2D(u_fontTextureArr[4], v_texCoords);\
                } else if (fi == 5) {\
                    color = texture2D(u_fontTextureArr[5], v_texCoords);\
                } else if (fi == 6) {\
                    color = texture2D(u_fontTextureArr[6], v_texCoords);\
                } else if (fi == 7) {\
                    color = texture2D(u_fontTextureArr[7], v_texCoords);\
                } else if (fi == 8) {\
                    color = texture2D(u_fontTextureArr[8], v_texCoords);\
                } else if (fi == 9) {\
                    color = texture2D(u_fontTextureArr[9], v_texCoords);\
                }else{\
                    color = texture2D(u_fontTextureArr[10], v_texCoords);\
                }\
                float afwidth = step(0.5, v_bufferAA.x) * (1.0 - v_bufferAA.y) * v_bufferAA.x * fwidth( color.r );\
                float alpha = smoothstep ( v_bufferAA.x - afwidth - v_bufferAA.z, v_bufferAA.x + afwidth + v_bufferAA.z, color.r );\
                if( alpha < 0.2 )\
                    discard;\
                gl_FragData[0] = vec4(v_rgba.rgb, alpha * v_rgba.a);\
                gl_FragData[1] = vec4(0.0);\
            }';
    }

    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("label", {
        uniforms: {
            u_fontTextureArr: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2DXX },
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            uCamPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uFloatParams: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
            uZ: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
            uScaleByDistance: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uOpacity: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            a_vertices: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_texCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_positions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_size: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_offset: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_rgba: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_rotation: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_alignedAxis: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_fontIndex: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_bufferAA: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec2 a_vertices;\
            attribute vec4 a_texCoord;\
            attribute vec4 a_positions;\
            attribute vec3 a_offset;\
            attribute float a_size;\
            attribute float a_rotation;\
            attribute vec4 a_rgba;\
            attribute vec3 a_alignedAxis;\
            attribute float a_fontIndex;\
            attribute vec2 a_bufferAA;\
            varying vec2 v_texCoords;\
            varying vec4 v_rgba;\
            varying float v_fontIndex;\
            varying vec3 v_bufferAA;\
            uniform mat4 viewMatrix;\
            uniform mat4 projectionMatrix;\
            uniform vec3 uCamPos;\
            /*0 - planetRadius^2, 1 - tan(fov), 2 - screen ratio*/\
            uniform vec2 uFloatParams;\
            uniform float uZ;\
            uniform vec3 uScaleByDistance;\
            uniform float uOpacity;\
            const vec3 ZERO3 = vec3(0.0);\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main() {\
                if(a_texCoord.z == -1.0 || a_bufferAA.x == 1.0){\
                    gl_Position = vec4(0.0);\
                    return;\
                }\
                v_fontIndex = a_fontIndex;\
                v_texCoords = vec2(a_texCoord.xy);\
                vec3 look = a_positions.xyz - uCamPos;\
                float lookDist = length(look);\
                v_rgba = a_rgba;\
                /*v_rgba.a *= uOpacity * step(lookDist, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions.xyz,a_positions.xyz) - uFloatParams[0]));*/\
                if(uOpacity * step(lookDist, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions.xyz,a_positions.xyz) - uFloatParams[0]))==0.0){\
                    return;\
                }\
                vec3 right, up;\
                if(a_alignedAxis == ZERO3){\
                    up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );\
                    right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );\
                }else{\
                    up = normalize(a_alignedAxis);\
                    right = normalize(cross(look,up));\
                    look = cross(up,right);\
                }\
                v_bufferAA = vec3(a_bufferAA, 8.0 * a_bufferAA.y / a_size);\
                float dist = dot(uCamPos - a_positions.xyz, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));\
                float focalSize = 2.0 * dist * uFloatParams[1];\
                vec2 offset = a_offset.xy * focalSize;\
                float scd = a_positions.w * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookDist)) * (1.0 - step(uScaleByDistance[2], lookDist));\
                float scale = a_size * focalSize * scd;\
                float cosRot = cos(a_rotation);\
                float sinRot = sin(a_rotation);\
                vec3 rr = (right * cosRot - up * sinRot) * (scale * (a_vertices.x + a_texCoord.z + a_texCoord.w) + scd * offset.x) + (right * sinRot + up * cosRot) * (scale * a_vertices.y + scd * offset.y) + a_positions.xyz;\
                gl_Position = projectionMatrix * viewMatrix * vec4(rr, 1);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                gl_Position.z += a_offset.z + uZ;\
            }',
        fragmentShader:
        strFragment
    });
};

function labelPicking() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("labelPicking", {
        uniforms: {
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            uCamPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uFloatParams: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
            uScaleByDistance: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            uOpacity: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            a_vertices: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true },
            a_texCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_positions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4, enableArray: true },
            a_size: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_offset: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_pickingColor: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            a_rotation: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT, enableArray: true },
            a_alignedAxis: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true }
        },
        vertexShader:
        'precision highp float;\n\
            attribute vec2 a_vertices;\
            attribute vec4 a_texCoord;\
            attribute vec4 a_positions;\
            attribute vec3 a_offset;\
            attribute float a_size;\
            attribute float a_rotation;\
            attribute vec3 a_pickingColor;\
            attribute vec3 a_alignedAxis;\
            varying vec4 v_color;\
            uniform mat4 viewMatrix;\
            uniform mat4 projectionMatrix;\
            uniform vec3 uCamPos;\
            /*0 - planetRadius^2, 1 - tan(fov), 2 - screen ratio*/\
            uniform vec2 uFloatParams;\
            uniform vec3 uScaleByDistance;\
            uniform float uOpacity;\
            const vec3 ZERO3 = vec3(0.0);\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main() {\
                if( uOpacity == 0.0 ){\
                    gl_Position = vec4(0.0);\
                    return;\
                }\
                if(a_texCoord.z == -1.0){\
                    gl_Position = vec4(0.0);\
                    return;\
                }\
                vec3 look = a_positions.xyz - uCamPos;\
                float lookLength = length(look);\
                v_color = vec4(a_pickingColor.rgb, 1.0) * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(a_positions.xyz, a_positions.xyz) - uFloatParams[0]));\
                vec3 right, up;\
                if(a_alignedAxis == ZERO3){\
                    up = vec3( viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1] );\
                    right = vec3( viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0] );\
                }else{\
                    up = normalize(a_alignedAxis);\
                    right = normalize(cross(look,up));\
                    look = cross(up,right);\
                }\
                float dist = dot(uCamPos - a_positions.xyz, vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]));\
                float focalSize = 2.0 * dist * uFloatParams[1];\
                vec2 offset = a_offset.xy * focalSize;\
                float scd = a_positions.w * (1.0 - smoothstep(uScaleByDistance[0], uScaleByDistance[1], lookLength)) *(1.0 - step(uScaleByDistance[2], lookLength));\
                float scale = a_size * focalSize * scd;\
                float cosRot = cos(a_rotation);\
                float sinRot = sin(a_rotation);\
                vec3 rr = (right * cosRot - up * sinRot) * (scale * (a_vertices.x + a_texCoord.z + a_texCoord.w) + scd * offset.x) + (right * sinRot + up * cosRot) * (scale * a_vertices.y + scd * offset.y) + a_positions.xyz;\
                gl_Position = projectionMatrix * viewMatrix * vec4(rr, 1);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                gl_Position.z += a_offset.z;\
            }',
        fragmentShader:
        'precision highp float;\n\
            varying vec4 v_color;\
            void main () {\
                gl_FragColor = v_color;\
            }'
    });
};

/***/ }),

/***/ "./src/og/shaders/pointCloud.js":
/*!**************************************!*\
  !*** ./src/og/shaders/pointCloud.js ***!
  \**************************************/
/*! exports provided: pointCloud */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointCloud", function() { return pointCloud; });
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/shaders/pointCloud
 */

'use sctrict';





//Picking is the same
function pointCloud() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("pointCloud", {
        uniforms: {
            projectionViewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            opacity: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
            pointSize: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
        },
        attributes: {
            coordinates: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            colors: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true }
        },
        vertexShader:
        'attribute vec3 coordinates;\
            attribute vec4 colors;\
            uniform mat4 projectionViewMatrix;\
            uniform float opacity;\
            uniform float pointSize;\
            varying vec4 color;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main() {\
                color = colors;\
                color.a *= opacity;\
                gl_Position = projectionViewMatrix * vec4(coordinates, 1.0);\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                gl_PointSize = pointSize;\
            }',
        fragmentShader:
        'precision highp float;\n\
            varying vec4 color;\
            void main(void) {\
                gl_FragColor = color;\
            }'
    });
};

/***/ }),

/***/ "./src/og/shaders/polyline.js":
/*!************************************!*\
  !*** ./src/og/shaders/polyline.js ***!
  \************************************/
/*! exports provided: polyline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyline", function() { return polyline; });
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/shaders/polyline
 */

'use sctrict';




function polyline(isDrawBuffersExtension) {
    if (isDrawBuffersExtension) {
        return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("polyline", {
            uniforms: {
                'viewport': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
                'proj': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
                'view': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
                'viewport': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
                'uCamPos': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'uFloatParams': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
                'color': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
                'thickness': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },
                'pickingColor': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 }
            },
            attributes: {
                'prev': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'current': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'next': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'order': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
            },
            vertexShader: 'attribute vec3 prev;\
                attribute vec3 current;\
                attribute vec3 next;\
                attribute float order;\
                uniform float thickness;\
                uniform vec4 color;\
                uniform mat4 proj;\
                uniform mat4 view;\
                uniform vec2 viewport;\
                varying vec4 vColor;\
                varying vec3 vPos;\
                \
                const float C = 0.1;\
                const float far = 149.6e+9;\
                float logc = 2.0 / log( C * far + 1.0 );\
                \
                const float NEAR = -1.0;\
                \
                vec2 project(vec4 p){\
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\
                }\
                \
                void main(){\
                    vColor = color;\
                    vPos = current;\
                    \
                    vec4 vCurrent = view * vec4(current, 1.0);\
                    vec4 vPrev = view * vec4(prev, 1.0);\
                    vec4 vNext = view * vec4(next, 1.0);\
                    \
                    /*Clip near plane*/\
                    if(vCurrent.z > NEAR) {\
                        if(vPrev.z < NEAR){\
                            /*to the begining path view*/\
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\
                        }else if(vNext.z < NEAR){\
                            /*to the end path view*/\
                            vPrev = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);\
                        }\
                    } else if( vPrev.z > NEAR) {\
                        /*to the end path view*/\
                        vPrev = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\
                    } else if( vNext.z > NEAR) {\
                        /*to the begining path view*/\
                        vNext = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);\
                    }\
                    \
                    vec4 dCurrent = proj * vCurrent;\
                    vec2 _next = project(proj * vNext);\
                    vec2 _prev = project(proj * vPrev);\
                    vec2 _current = project(dCurrent);\
                    if(_prev == _current){\
                        if(_next == _current){\
                            _next = _current + vec2(1.0, 0.0);\
                            _prev = _current - _next;\
                        }else{\
                            _prev = _current + normalize(_current - _next);\
                        }\
                    }\
                    if(_next == _current){\
                        _next = _current + normalize(_current - _prev);\
                    }\
                    \
                    vec2 sNext = _next,\
                         sCurrent = _current,\
                         sPrev = _prev;\
                    vec2 dirNext = normalize(sNext - sCurrent);\
                    vec2 dirPrev = normalize(sPrev - sCurrent);\
                    float dotNP = dot(dirNext, dirPrev);\
                    \
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));\
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));\
                    \
                    float d = thickness * sign(order);\
                    \
                    vec2 m;\
                    if(dotNP >= 0.99991){\
                        m = sCurrent - normalPrev * d;\
                    }else{\
                        vec2 dir = normalPrev + normalNext;\
                        m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);\
                        \
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){\
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);\
                            if(occw == -1.0){\
                                m = sCurrent + normalPrev * d;\
                            }else if(occw == 1.0){\
                                m = sCurrent + normalNext * d;\
                            }else if(occw == -2.0){\
                                m = sCurrent + normalNext * d;\
                            }else if(occw == 2.0){\
                                m = sCurrent + normalPrev * d;\
                            }\
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){\
                            m = sCurrent + normalNext * d;\
                        }\
                    }\
                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z, dCurrent.w);\
                    gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                }',
            fragmentShader:
            '#extension GL_EXT_draw_buffers : require\n\
                precision highp float;\n\
                uniform vec3 pickingColor;\
                uniform vec2 uFloatParams;\
                uniform vec3 uCamPos;\
                varying vec4 vColor;\
                varying vec3 vPos;\
                void main() {\
                    vec3 look = vPos - uCamPos;\
                    float lookLength = length(look);\
                    float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));\
                    gl_FragData[0] = vec4(vColor.rgb, a);\
                    gl_FragData[1] = vec4(pickingColor, 1.0);\
                }'
        });
    } else {
        return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("polyline", {
            uniforms: {
                'viewport': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
                'proj': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
                'view': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
                'viewport': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
                'uCamPos': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'uFloatParams': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2 },
                'color': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
                'thickness': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
            },
            attributes: {
                'prev': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'current': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'next': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
                'order': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT }
            },
            vertexShader: 'attribute vec3 prev;\
                attribute vec3 current;\
                attribute vec3 next;\
                attribute float order;\
                uniform float thickness;\
                uniform vec4 color;\
                uniform mat4 proj;\
                uniform mat4 view;\
                uniform vec2 viewport;\
                varying vec4 vColor;\
                varying vec3 vPos;\
                \
                const float C = 0.1;\
                const float far = 149.6e+9;\
                float logc = 2.0 / log( C * far + 1.0 );\
                \
                const float NEAR = -1.0;\
                \
                vec2 getIntersection(vec2 start1, vec2 end1, vec2 start2, vec2 end2){\
                    vec2 dir = end2 - start2;\
                    vec2 perp = vec2(-dir.y, dir.x);\
                    float d2 = dot(perp, start2);\
                    float seg = dot(perp, start1) - d2;\
                    float prl = seg - dot(perp, end1) + d2;\
                    if(prl > -1.0 && prl < 1.0){\
                        return start1;\
                    }\
                    float u = seg / prl;\
                    return start1 + u * (end1 - start1);\
                }\
                \
                vec2 project(vec4 p){\
                    return (0.5 * p.xyz / p.w + 0.5).xy * viewport;\
                }\
                \
                void main(){\
                    vColor = color;\
                    vPos = current;\
                    \
                    vec4 vCurrent = view * vec4(current, 1.0);\
                    vec4 vPrev = view * vec4(prev, 1.0);\
                    vec4 vNext = view * vec4(next, 1.0);\
                    \
                    /*Clip near plane*/\
                    if(vCurrent.z > NEAR) {\
                        if(vPrev.z < NEAR){\
                            /*to the begining path view*/\
                            vCurrent = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\
                        }else if(vNext.z < NEAR){\
                            /*to the end path view*/\
                            vPrev = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\
                            vCurrent = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);\
                        }\
                    } else if( vPrev.z > NEAR) {\
                        /*to the end path view*/\
                        vPrev = vPrev + (vCurrent - vPrev) * (NEAR - vPrev.z) / (vCurrent.z - vPrev.z);\
                    } else if( vNext.z > NEAR) {\
                        /*to the begining path view*/\
                        vNext = vNext + (vCurrent - vNext) * (NEAR - vNext.z) / (vCurrent.z - vNext.z);\
                    }\
                    \
                    vec4 dCurrent = proj * vCurrent;\
                    vec2 _next = project(proj * vNext);\
                    vec2 _prev = project(proj * vPrev);\
                    vec2 _current = project(dCurrent);\
                    if(_prev == _current){\
                        if(_next == _current){\
                            _next = _current + vec2(1.0, 0.0);\
                            _prev = _current - _next;\
                        }else{\
                            _prev = _current + normalize(_current - _next);\
                        }\
                    }\
                    if(_next == _current){\
                        _next = _current + normalize(_current - _prev);\
                    }\
                    \
                    vec2 sNext = _next,\
                         sCurrent = _current,\
                         sPrev = _prev;\
                    vec2 dirNext = normalize(sNext - sCurrent);\
                    vec2 dirPrev = normalize(sPrev - sCurrent);\
                    float dotNP = dot(dirNext, dirPrev);\
                    \
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));\
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));\
                    \
                    float d = thickness * sign(order);\
                    \
                    vec2 m;\
                    if(dotNP >= 0.99991){\
                        m = sCurrent - normalPrev * d;\
                    }else{\
                        m = getIntersection( sCurrent + normalPrev * d, sPrev + normalPrev * d,\
                            sCurrent + normalNext * d, sNext + normalNext * d );\
                        \
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){\
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);\
                            if(occw == -1.0){\
                                m = sCurrent + normalPrev * d;\
                            }else if(occw == 1.0){\
                                m = sCurrent + normalNext * d;\
                            }else if(occw == -2.0){\
                                m = sCurrent + normalNext * d;\
                            }else if(occw == 2.0){\
                                m = sCurrent + normalPrev * d;\
                            }\
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){\
                            m = sCurrent + normalNext * d;\
                        }\
                    }\
                    gl_Position = vec4((2.0 * m / viewport - 1.0) * dCurrent.w, dCurrent.z, dCurrent.w);\
                    gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                }',
            fragmentShader:
            'precision highp float;\
                uniform vec2 uFloatParams;\
                uniform vec3 uCamPos;\
                varying vec4 vColor;\
                varying vec3 vPos;\
                void main() {\
                    vec3 look = vPos - uCamPos;\
                    float lookLength = length(look);\
                    float a = vColor.a * step(lookLength, sqrt(dot(uCamPos,uCamPos) - uFloatParams[0]) + sqrt(dot(vPos,vPos) - uFloatParams[0]));\
                    gl_FragColor = vec4(vColor.rgb, a);\
                }'
        });
    }
};

/***/ }),

/***/ "./src/og/shaders/shape.js":
/*!*********************************!*\
  !*** ./src/og/shaders/shape.js ***!
  \*********************************/
/*! exports provided: shape_wl, shape_nl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shape_wl", function() { return shape_wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shape_nl", function() { return shape_nl; });
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/shaders/shape
 */

'use sctrict';




function shape_wl() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("shape_wl", {
        uniforms: {
            viewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            projectionMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            modelMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            normalMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },

            lightsPositions: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            lightsParamsv: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3 },
            lightsParamsf: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].FLOAT },

            uColor: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            uSampler: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D }
        },
        attributes: {
            aVertexNormal: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexNormal;\
            attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionMatrix;\
            uniform mat4 viewMatrix;\
            uniform mat4 modelMatrix;\
            uniform mat3 normalMatrix;\
            varying vec2 vTextureCoord;\
            varying vec3 vNormal;\
            varying vec4 vPosition;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                vTextureCoord = aTextureCoord;\
                vNormal = normalMatrix * aVertexNormal;\
                vPosition = viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);\
                gl_Position = projectionMatrix * vPosition;\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
            }',
        fragmentShader:
        'precision highp float;\n\
            varying vec2 vTextureCoord;\
            varying vec3 vNormal;\
            varying vec4 vPosition;\
            uniform vec4 uColor;\
            uniform sampler2D uSampler;\n\
            #define MAX_POINT_LIGHTS 1\n\
            uniform int lightsQuantity;\
            uniform vec4 lightsPositions[MAX_POINT_LIGHTS];\
            uniform vec3 lightsParamsv[MAX_POINT_LIGHTS * 3];\
            uniform float lightsParamsf[MAX_POINT_LIGHTS];\
            void main(void) {\
                vec3 lightWeighting;\
                vec3 lightDirection;\
                vec3 normal;\
                vec3 eyeDirection;\
                vec3 reflectionDirection;\
                float specularLightWeighting;\
                float diffuseLightWeighting;\
                lightDirection = normalize(lightsPositions[0].xyz - vPosition.xyz * lightsPositions[0].w);\
                normal = normalize(vNormal);\
                eyeDirection = normalize(-vPosition.xyz);\
                reflectionDirection = reflect(-lightDirection, normal);\
                specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), lightsParamsf[0]);\
                diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\
                lightWeighting = lightsParamsv[0] + lightsParamsv[1] * diffuseLightWeighting + lightsParamsv[2] * specularLightWeighting;\
                vec4 cc = texture2D( uSampler, vTextureCoord.st );\
                gl_FragColor = vec4(lightWeighting, uColor.a) * cc * uColor;\
            }'
    });
};

function shape_nl() {
    return new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_0__["ShaderProgram"]("shape_nl", {
        uniforms: {
            projectionViewMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            modelMatrix: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].MAT4 },
            uColor: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC4 },
            uSampler: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].SAMPLER2D }
        },
        attributes: {
            aVertexPosition: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC3, enableArray: true },
            aTextureCoord: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_1__["types"].VEC2, enableArray: true }
        },
        vertexShader:
        'attribute vec3 aVertexPosition;\
            attribute vec2 aTextureCoord;\
            uniform mat4 projectionViewMatrix;\
            uniform mat4 modelMatrix;\
            varying vec2 vTextureCoord;\
            const float C = 0.1;\
            const float far = 149.6e+9;\
            float logc = 2.0 / log( C * far + 1.0 );\
            void main(void) {\
                gl_Position = projectionViewMatrix * (modelMatrix * vec4(aVertexPosition, 1.0));\
                gl_Position.z = ( log( C * gl_Position.w + 1.0 ) * logc - 1.0 ) * gl_Position.w;\
                vTextureCoord = aTextureCoord;\
            }',
        fragmentShader:
        'precision highp float;\n\
            uniform vec4 uColor;\
            uniform sampler2D uSampler;\
            varying vec2 vTextureCoord;\
            void main(void) {\
                gl_FragColor = uColor*texture2D( uSampler, vTextureCoord.st );\
            }'
    });
};

/***/ }),

/***/ "./src/og/terrain/EmptyTerrain.js":
/*!****************************************!*\
  !*** ./src/og/terrain/EmptyTerrain.js ***!
  \****************************************/
/*! exports provided: EmptyTerrain */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmptyTerrain", function() { return EmptyTerrain; });
/**
 * @module og/terrainProvider/EmptyTerrain
 */



/**
 * Class represents terrain provider without elevation data.
 * @class
 */
class EmptyTerrain {
    constructor() {
        /**
         * Provider name is "empty"
         * @public
         * @type {string}
         */
        this.name = "empty";

        /**
         * Minimal z-index value for segment elevation data handling.
         * @public
         * @type {number}
         */
        this.minZoom = 50;

        /**
         * Maximal z-index value for segment elevation data handling.
         * @public
         * @type {number}
         */
        this.maxZoom = 50;

        /**
         * @public
         * @type {Array.<number>}
         */
        this.gridSizeByZoom = [32, 16, 16, 8, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];

        /**
         * Elevation grid size. Currend is 2x2 is the smallest grid size.
         * @public
         * @type {number}
         */
        this.fileGridSize = 2;

        /**
         * Planet node.
         * @protected
         * @type {og.scene.Planet}
         */
        this._planet = null;
    }

    /**
     * Loads or creates segment elevation data.
     * @public
     * @virtual
     * @param {og.planetSegment.Segment} segment - Segment to create elevation data.
     */
    handleSegmentTerrain(segment) {
        segment.terrainIsLoading = false;
        segment.terrainReady = true;
        segment.terrainExists = true;
    }

    /**
     * Abstract function
     * @public
     * @abstract
     */
    abortLoading() { }
};



/***/ }),

/***/ "./src/og/utils/FontAtlas.js":
/*!***********************************!*\
  !*** ./src/og/utils/FontAtlas.js ***!
  \***********************************/
/*! exports provided: FontAtlas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontAtlas", function() { return FontAtlas; });
/* harmony import */ var _TextureAtlas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureAtlas.js */ "./src/og/utils/TextureAtlas.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageCanvas.js */ "./src/og/ImageCanvas.js");
/* harmony import */ var _QueueArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../QueueArray.js */ "./src/og/QueueArray.js");
/* harmony import */ var _FontDetector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FontDetector.js */ "./src/og/utils/FontDetector.js");
/* harmony import */ var _SDFCreator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SDFCreator.js */ "./src/og/utils/SDFCreator.js");
/**
 * @module og/utils/FontAtlas
 */









const tokens = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
    '`', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '-', '=', '[', ']', '{', '}', '\\', '|', ';', ':', '"', ',', '.', '/', '<', '>', '?', ' ', '    ', "'"];

class FontAtlas {
    constructor() {
        this.atlasesArr = [];
        this.atlasIndexes = {};
        this.tokenImageSize = 64;
        this.samplerArr = [0];
        this._handler = null;
        this.defaultFace = "arial";

        this._counter = 0;
        this._pendingsQueue = new _QueueArray_js__WEBPACK_IMPORTED_MODULE_2__["QueueArray"]();
        this.fontDetector = new _FontDetector_js__WEBPACK_IMPORTED_MODULE_3__["FontDetector"]();

        this._sdfCreator = new _SDFCreator_js__WEBPACK_IMPORTED_MODULE_4__["SDFCreator"](256, 256);
    }

    assignHandler(handler) {
        this._handler = handler;
    }

    getFontIndex(face, style, weight) {
        return this.atlasIndexes[this.getFullIndex(face, style, weight)];
    }

    getFullIndex(face, style, weight) {
        face = face && face.trim().toLowerCase();
        if (!face || face && !this.fontDetector.detect(face)) {
            face = this.defaultFace;
        }
        return face + " " + ((style && style.toLowerCase()) || "normal") + " " + ((weight && weight.toLowerCase()) || "normal");
    }

    createFont(face, style, weight) {
        var fontIndex = this.getFontIndex(face, style, weight);
        if (fontIndex == undefined) {
            var tis = this.tokenImageSize;
            var atlasSize = 1024;//og.math.nextHighestPowerOfTwo(Math.ceil(Math.sqrt(og.utils.FontAtlas.tokens.length)) / tis + (og.utils.FontAtlas.tokens.length - 1) * og.utils.TextureAtlas.BORDER_SIZE);
            var fontName = this.getFullIndex(face, style, weight);
            fontIndex = this.atlasIndexes[fontName] = this.atlasesArr.length;
            var atlas = new _TextureAtlas_js__WEBPACK_IMPORTED_MODULE_0__["TextureAtlas"](atlasSize, atlasSize);
            atlas.assignHandler(this._handler);
            atlas.borderSize = 6;
            this.samplerArr[this.atlasesArr.length] = this.atlasesArr.length;
            this.atlasesArr.push(atlas);
            atlas.canvas.fillColor("black");

            var t = tokens;

            var sdfSize = 512;
            var sdfCanvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["ImageCanvas"](sdfSize, sdfSize);
            var sc = this._sdfCreator;
            var pT = Math.round(sdfSize * 0.66);
            var tF = (style || "normal") + " " + (weight || "normal") + " " + pT + "px " + (face || this.defaultFace);

            for (var i = 0; i < t.length; i++) {
                var ti = t[i];

                sdfCanvas.fillColor("black");
                sdfCanvas.drawText(ti, 49, pT, tF, "white");
                var res = sc.createSDF(sdfCanvas._canvas, tis, tis);
                res.__nodeIndex = ti;
                var n = atlas.addImage(res, true);

                var tokenWidth = sdfCanvas.getTextWidth(ti);
                n.emptySize = tokenWidth / sdfSize;
            }

            atlas.createTexture();
            sdfCanvas.destroy();
            sdfCanvas = null;
        }

        return fontIndex;
    }

    createFontAsync(face, style, weight, callback) {
        var obj = { "face": face, "style": style, "weight": weight, "callback": callback };
        if (this._counter >= 1) {
            this._pendingsQueue.push(obj);
        } else {
            this._exec(obj);
        }
    }

    _exec(obj) {
        this._counter++;
        var that = this;
        setTimeout(function () {
            var fontIndex = that.createFont(obj.face, obj.style, obj.weight);
            obj.callback(fontIndex);
            that._dequeueRequest();
        }, 0);
    }

    _dequeueRequest() {
        this._counter--;
        if (this._pendingsQueue.length && this._counter < 1) {
            var obj;
            if (obj = this._whilePendings())
                this._exec(obj);
        }
    }

    _whilePendings() {
        while (this._pendingsQueue.length) {
            var f = this._pendingsQueue.pop();
            var fontIndex = this.getFontIndex(f.face, f.style, f.weight);
            if (fontIndex != undefined) {
                f.callback(fontIndex);
                continue;
            }
            return f;
        }
    }
};



/***/ }),

/***/ "./src/og/utils/FontDetector.js":
/*!**************************************!*\
  !*** ./src/og/utils/FontDetector.js ***!
  \**************************************/
/*! exports provided: FontDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontDetector", function() { return FontDetector; });
/**
 * @module og/utils/FontDetector
 */



/**
 * Font detector class.
 * @class
 */
class FontDetector {
    constructor() {
        var baseFonts = ['monospace', 'sans-serif', 'serif'];
        var testString = "mmmmmmmmmmlli";
        var testSize = '72px';
        var h = document.getElementsByTagName("body")[0];
        var s = document.createElement("span");
        s.style.fontSize = testSize;
        s.innerHTML = testString;
        var defaultWidth = {};
        var defaultHeight = {};
        for (var index in baseFonts) {
            s.style.fontFamily = baseFonts[index];
            h.appendChild(s);
            defaultWidth[baseFonts[index]] = s.offsetWidth;
            defaultHeight[baseFonts[index]] = s.offsetHeight;
            h.removeChild(s);
        }

        /**
         * Returns true if font is known.
         * @public
         * @param {string} font - Font name.
         * @returns {boolean}
         */
        this.detect = function (font) {
            var detected = false;
            for (var index in baseFonts) {
                s.style.fontFamily = font + ',' + baseFonts[index];
                h.appendChild(s);
                var matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);
                h.removeChild(s);
                detected = detected || matched;
            }
            return detected;
        }
    }
};



/***/ }),

/***/ "./src/og/utils/GeoImageCreator.js":
/*!*****************************************!*\
  !*** ./src/og/utils/GeoImageCreator.js ***!
  \*****************************************/
/*! exports provided: GeoImageCreator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoImageCreator", function() { return GeoImageCreator; });
/* harmony import */ var _segment_segmentHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../segment/segmentHelper.js */ "./src/og/segment/segmentHelper.js");
/* harmony import */ var _utils_shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/shared.js */ "./src/og/utils/shared.js");
/* harmony import */ var _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/Framebuffer.js */ "./src/og/webgl/Framebuffer.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/utils/GeoImageCreator
 */

'use sctrict';








const GeoImageCreator = function (handler, maxFrames) {
    this._gridSize = 64;
    this._handler = handler;
    this._framebuffer = null;
    this._texCoordsBuffer = null;
    this._indexBuffer = null;
    this.MAX_FRAMES = maxFrames || 5;
    this._currentFrame = 0;
    this._queue = [];
    this._animate = [];
    this._initialize();
};

GeoImageCreator.prototype._initialize = function () {
    this._initShaders();
    this._initBuffers();
};

/**
 * Creates geoImage corners coordinates grid buffer.
 * @public
 * @param{Array.<og.LonLat>} c - GeoImage corners coordinates.
 * @return{WebGLBuffer} Grid coordinates buffer.
 */
GeoImageCreator.prototype.createGridBuffer = function (c, toMerc) {
    var gs = this._gridSize;

    var v03 = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"]((c[3].lon - c[0].lon) / gs, (c[3].lat - c[0].lat) / gs),
        v12 = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"]((c[2].lon - c[1].lon) / gs, (c[2].lat - c[1].lat) / gs),
        v01 = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"]((c[1].lon - c[0].lon) / gs, (c[1].lat - c[0].lat) / gs),
        v32 = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"]((c[2].lon - c[3].lon) / gs, (c[2].lat - c[3].lat) / gs);

    var grid = new Float32Array((gs + 1) * (gs + 1) * 2);
    var k = 0;
    for (var i = 0; i <= gs; i++) {
        var P03i = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](c[0].lon + i * v03.lon, c[0].lat + i * v03.lat),
            P12i = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](c[1].lon + i * v12.lon, c[1].lat + i * v12.lat);
        for (var j = 0; j <= gs; j++) {
            var P01j = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](c[0].lon + j * v01.lon, c[0].lat + j * v01.lat),
                P32j = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](c[3].lon + j * v32.lon, c[3].lat + j * v32.lat);
            var xx = _utils_shared_js__WEBPACK_IMPORTED_MODULE_1__["getLinesIntersectionLonLat"](P03i, P12i, P01j, P32j);
            grid[k++] = xx.lon;
            grid[k++] = xx.lat;
        }
    }

    if (toMerc) {
        for (var i = 0; i < grid.length; i += 2) {
            var c = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](grid[i], grid[i + 1]).forwardMercator();
            grid[i] = c.lon;
            grid[i + 1] = c.lat;
        }
    }
    return this._handler.createArrayBuffer(grid, 2, grid.length / 2);
};

GeoImageCreator.prototype.frame = function () {
    var i = this.MAX_FRAMES;
    while (i-- && this._queue.length) {
        var q = this._queue.shift();
        q._isRendering = false;
        q.rendering();
    }

    i = this._animate.length;
    while (i--) {
        this._animate[i].rendering();
    }
};

GeoImageCreator.prototype.add = function (geoImage) {
    if (!geoImage._isRendering) {
        geoImage._isRendering = true;
        if (geoImage._animate) {
            this._animate.push(geoImage);
        } else {
            this._queue.push(geoImage);
        }
    }
};

GeoImageCreator.prototype.remove = function (geoImage) {
    if (geoImage._isRendering) {
        geoImage._creationProceeding = false;
        geoImage._isRendering = false;
        var arr;
        if (geoImage._animate) {
            arr = this._animate;
        } else {
            arr = this._queue;
        }
        for (var i = 0; i < arr.length; i++) {
            if (arr[i].isEqual(geoImage)) {
                arr.splice(i, 1);
                return;
            }
        }
    }
};

GeoImageCreator.prototype._initBuffers = function () {

    this._framebuffer = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_2__["Framebuffer"](this._handler, { width: 2, height: 2, useDepth: false });
    this._framebuffer.init();

    this._framebufferMercProj = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_2__["Framebuffer"](this._handler, { width: 2, height: 2, useDepth: false });
    this._framebufferMercProj.init();

    var gs = this._gridSize;
    var gs1 = this._gridSize + 1;
    this._texCoordsBuffer = this._handler.createArrayBuffer(_segment_segmentHelper_js__WEBPACK_IMPORTED_MODULE_0__["textureCoordsTable"][gs], 2, gs1 * gs1);

    var indexes = _segment_segmentHelper_js__WEBPACK_IMPORTED_MODULE_0__["createSegmentIndexes"](gs, [gs, gs, gs, gs]);
    this._indexBuffer = this._handler.createElementArrayBuffer(indexes, 1, indexes.length);

    this._quadTexCoordsBuffer = this._handler.createArrayBuffer(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2, 4);
    this._quadVertexBuffer = this._handler.createArrayBuffer(new Float32Array([-1, 1, 1, 1, -1, -1, 1, -1]), 2, 4);
};

GeoImageCreator.prototype._initShaders = function () {
    this._handler.addShaderProgram(new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_4__["ShaderProgram"]("geoImageTransform", {
        uniforms: {
            sourceTexture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_5__["types"].SAMPLER2D },
            extentParams: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_5__["types"].VEC4 }
        },
        attributes: {
            corners: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_5__["types"].VEC2, enableArray: true },
            texCoords: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_5__["types"].VEC2, enableArray: true }
        },
        vertexShader: 'attribute vec2 corners; \
                      attribute vec2 texCoords; \
                      varying vec2 v_texCoords; \
                      uniform vec4 extentParams; \
                      void main() { \
                          v_texCoords = texCoords; \
                          gl_Position = vec4((-1.0 + (corners - extentParams.xy) * extentParams.zw) * vec2(1.0, -1.0), 0.0, 1.0); \
                      }',
        fragmentShader:
        'precision highp float;\n\
                        uniform sampler2D sourceTexture; \
                        varying vec2 v_texCoords; \
                        void main () {  \
                            gl_FragColor = texture2D(sourceTexture, v_texCoords); \
                        }'
    }));
};




/***/ }),

/***/ "./src/og/utils/ImageBitmapLoader.js":
/*!*******************************************!*\
  !*** ./src/og/utils/ImageBitmapLoader.js ***!
  \*******************************************/
/*! exports provided: ImageBitmapLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/**
 * @module og/utils/ImageBitmapLoader
 */



const NUM_WORKERS = 1;
const MAX_REQUESTS = 12;

function program(maxRequests = 12) {
    return `var maxRequests = ${maxRequests};
    var _loading = 0;
    var _queue = [];
    
    var processQueue = function() {
        if (_queue.length > 0 && _loading < maxRequests) {
            
            var q = _queue.shift(),
                src = q.src,
                options = q.options || {};

            _loading++;
            
            return fetch(src, options).then((response) => {
                if (!response.ok) {
                    throw Error("Unable to load '" + src + "'");
                }
                return response.blob();
            })
            .then(createImageBitmap)
            .then((imageBitmap) => {
                _loading--;
                self.postMessage({ 'ok': true, 'imageBitmap': imageBitmap, 'queue': _queue.length }, [imageBitmap]);
            })
            .then(processQueue)
            .catch((err) => {
                _loading--;
                self.postMessage({ 'ok': false, 'error': err.toString(), 'queue': _queue.length });
                processQueue();
            });
        }
    }
    self.onmessage = function (e) {
        var toEnqueue = e.data;
        if (_queue.indexOf(toEnqueue.src) < 0) {
            _queue.push(toEnqueue);
            processQueue();
        }
    }`;
};

class ImageBitmapLoader {
    constructor(options) {
        options = options || {};

        this._workers = new Array(options.numWorkers || NUM_WORKERS);
        this._counter = 0;

        var p = new Blob([program(options.maxRequests || MAX_REQUESTS)], { type: 'application/javascript' });

        for (var i = 0; i < this._workers.length; i++) {
            this._workers[i] = new Worker(URL.createObjectURL(p));
        }
    }

    load(src, callback, options) {
        var _w = this._workers[this._counter++ % this._workers.length];
        _w.onmessage = (e) => callback && callback(e);
        _w.postMessage({ 'src': src, 'options': options });
    }
};



/***/ }),

/***/ "./src/og/utils/ImagesCacheManager.js":
/*!********************************************!*\
  !*** ./src/og/utils/ImagesCacheManager.js ***!
  \********************************************/
/*! exports provided: ImagesCacheManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImagesCacheManager", function() { return ImagesCacheManager; });
/* harmony import */ var _QueueArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../QueueArray.js */ "./src/og/QueueArray.js");
/**
 * @module og/utils/ImagesCacheManager
 */





class ImagesCacheManager {
    constructor() {
        this.imagesCache = {};

        this._counter = 0;
        this._pendingsQueue = new _QueueArray_js__WEBPACK_IMPORTED_MODULE_0__["QueueArray"]();
        this._imageIndexCounter = 0;
    }

    load(src, success) {
        if (this.imagesCache[src]) {
            success(this.imagesCache[src]);
        } else {
            var req = { "src": src, "success": success };
            if (this._counter >= 1) {
                this._pendingsQueue.push(req);
            } else {
                this._exec(req);
            }
        }
    };

    _exec(req) {
        this._counter++;
        var that = this;

        var img = new Image();
        img.crossOrigin = '';
        img.onload = function () {
            that.imagesCache[req.src] = img;
            this.__nodeIndex = that._imageIndexCounter++;
            req.success(this);
            that._dequeueRequest();
        };

        img.onerror = function () {
            that._dequeueRequest();
        };

        img.src = req.src;
    }

    _dequeueRequest() {
        this._counter--;
        if (this._pendingsQueue.length && this._counter < 1) {
            while (this._pendingsQueue.length) {
                var req = this._pendingsQueue.pop();
                if (req) {
                    if (this.imagesCache[req.src]) {
                        if (this._counter <= 0)
                            this._counter = 0;
                        else
                            this._counter--;
                        req.success(this.imagesCache[req.src]);
                    } else {
                        this._exec(req);
                        break;
                    }
                }
            }
        }
    }
};



/***/ }),

/***/ "./src/og/utils/NormalMapCreator.js":
/*!******************************************!*\
  !*** ./src/og/utils/NormalMapCreator.js ***!
  \******************************************/
/*! exports provided: NormalMapCreator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalMapCreator", function() { return NormalMapCreator; });
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Framebuffer.js */ "./src/og/webgl/Framebuffer.js");
/* harmony import */ var _Lock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Lock.js */ "./src/og/Lock.js");
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/* harmony import */ var _QueueArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../QueueArray.js */ "./src/og/QueueArray.js");
/**
 * @module og/utils/NormalMapCreator
 */










const NormalMapCreator = function (planet, width, height, maxFrames) {
    this._planet = planet;
    this._handler = planet.renderer.handler;
    this._verticesBufferArray = [];
    this._indexBufferArray = [];
    this._positionBuffer = null;
    this._framebuffer = null;
    this._normalMapVerticesTexture = null;

    this._width = width || 128;
    this._height = height || 128;

    this.MAX_FRAMES = maxFrames || 5;
    this._currentFrame = 0;
    this._queue = new _QueueArray_js__WEBPACK_IMPORTED_MODULE_5__["QueueArray"](1024);

    this._lock = new _Lock_js__WEBPACK_IMPORTED_MODULE_2__["Lock"]();

    this._init();
};

NormalMapCreator.prototype._init = function () {

    var isWebkit = false;//('WebkitAppearance' in document.documentElement.style) && !/^((?!chrome).)*safari/i.test(navigator.userAgent);

    /*==================================================================================
     * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu
     *=================================================================================*/
    var normalMapBlur = new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__["ShaderProgram"]("normalMapBlur", {
        attributes: {
            a_position: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_4__["types"].VEC2, enableArray: true }
        },
        uniforms: {
            s_texture: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_4__["types"].SAMPLER2D }
        },
        vertexShader: "attribute vec2 a_position; \n\
                       attribute vec2 a_texCoord; \n\
                      \n\
                      varying vec2 blurCoordinates[5]; \n\
                      \n\
                      void main() { \n\
                          vec2 vt = a_position * 0.5 + 0.5;" +
        (isWebkit ? "vt.y = 1.0 - vt.y; " : " ") +
        "gl_Position = vec4(a_position, 0.0, 1.0); \n\
                          blurCoordinates[0] = vt; \n\
                          blurCoordinates[1] = vt + "  + (1.0 / this._width * 1.407333) + ";" +
        "blurCoordinates[2] = vt - " + (1.0 / this._height * 1.407333) + ";" +
        "blurCoordinates[3] = vt + " + (1.0 / this._width * 3.294215) + ";" +
        "blurCoordinates[4] = vt - " + (1.0 / this._height * 3.294215) + ";" +
        "}",
        fragmentShader:
        "precision highp float;\n\
                        uniform sampler2D s_texture; \n\
                        \n\
                        varying vec2 blurCoordinates[5]; \n\
                        \n\
                        void main() { \n\
                            lowp vec4 sum = vec4(0.0); \n\
                            if(blurCoordinates[0].x <= 0.01 || blurCoordinates[0].x >= 0.99 ||\n\
                                blurCoordinates[0].y <= 0.01 || blurCoordinates[0].y >= 0.99){\n\
                                sum = texture2D(s_texture, blurCoordinates[0]);\n\
                            } else {\n\
                                sum += texture2D(s_texture, blurCoordinates[0]) * 0.204164; \n\
                                sum += texture2D(s_texture, blurCoordinates[1]) * 0.304005; \n\
                                sum += texture2D(s_texture, blurCoordinates[2]) * 0.304005; \n\
                                sum += texture2D(s_texture, blurCoordinates[3]) * 0.093913; \n\
                                sum += texture2D(s_texture, blurCoordinates[4]) * 0.093913; \n\
                            }\n\
                            gl_FragColor = sum; \n\
                        }"
    });

    var normalMap = new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_3__["ShaderProgram"]("normalMap", {
        attributes: {
            a_position: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_4__["types"].VEC2, enableArray: true },
            a_normal: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_4__["types"].VEC3, enableArray: true }
        },
        vertexShader: "attribute vec2 a_position; \
                      attribute vec3 a_normal; \
                      \
                      varying vec3 v_color; \
                      \
                      void main() { \
                          gl_PointSize = 1.0; \
                          gl_Position = vec4(a_position, 0, 1); \
                          v_color = normalize(a_normal) * 0.5 + 0.5; \
                      }",
        fragmentShader:
        "precision highp float;\n\
                        \
                        varying vec3 v_color; \
                        \
                        void main () { \
                            gl_FragColor = vec4(v_color, 1.0); \
                        }"
    });

    this._handler.addShaderProgram(normalMapBlur);
    this._handler.addShaderProgram(normalMap);

    //create hidden handler buffer
    this._framebuffer = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__["Framebuffer"](this._handler, {
        width: this._width,
        height: this._height,
        useDepth: false
    });

    this._framebuffer.init();

    this._normalMapVerticesTexture = this._handler.createEmptyTexture_l(this._width, this._height);

    //create vertices hasharray for different grid size segments
    for (var p = 1; p <= 6; p++) {
        var gs = Math.pow(2, p);
        var gs2 = (gs / 2);
        var vertices = [];

        for (var i = 0; i <= gs; i++) {
            for (var j = 0; j <= gs; j++) {
                vertices.push(-1 + j / gs2, -1 + i / gs2);
            }
        }

        this._verticesBufferArray[gs] = this._handler.createArrayBuffer(new Float32Array(vertices), 2, vertices.length / 2);
        this._indexBufferArray[gs] = this._planet._indexesCache[gs][gs][gs][gs][gs].buffer;
    }

    //create 2d screen square buffer
    var positions = new Float32Array([
        -1.0, -1.0,
        1.0, -1.0,
        -1.0, 1.0,
        1.0, 1.0]);

    this._positionBuffer = this._handler.createArrayBuffer(positions, 2, positions.length / 2);
};

NormalMapCreator.prototype._drawNormalMap = function (segment) {
    var normals = segment.normalMapNormals;
    if (segment.node && segment.node.getState() !== _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["NOTRENDERING"]
        && normals && normals.length) {

        segment._normalMapEdgeEqualize(_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["N"], 0);
        segment._normalMapEdgeEqualize(_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["S"], 1);
        segment._normalMapEdgeEqualize(_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["W"], 0, true);
        segment._normalMapEdgeEqualize(_quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["E"], 1, true);

        var outTexture = segment.normalMapTexturePtr;
        var size = normals.length / 3;
        var gridSize = Math.sqrt(size) - 1;

        var h = this._handler;
        var gl = h.gl;

        var _normalsBuffer = h.createArrayBuffer(normals, 3, size, gl.DYNAMIC_DRAW);

        var f = this._framebuffer;
        var p = h.shaderPrograms.normalMap;
        var sha = p._program.attributes;

        f.bindOutputTexture(this._normalMapVerticesTexture);

        p.activate();

        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBufferArray[gridSize]);
        gl.vertexAttribPointer(sha.a_position._pName, this._verticesBufferArray[gridSize].itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _normalsBuffer);
        gl.vertexAttribPointer(sha.a_normal._pName, _normalsBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferArray[gridSize]);
        gl.drawElements(gl.TRIANGLE_STRIP, this._indexBufferArray[gridSize].numItems, gl.UNSIGNED_SHORT, 0);

        gl.deleteBuffer(_normalsBuffer);

        //
        // blur pass
        //
        f.bindOutputTexture(outTexture);

        p = h.shaderPrograms.normalMapBlur;

        p.activate();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);
        gl.vertexAttribPointer(p._program.attributes.a_position._pName, this._positionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._normalMapVerticesTexture);
        gl.uniform1i(p._program.uniforms.s_texture._pName, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this._positionBuffer.numItems);
        return true;
    }
    return false;
};

NormalMapCreator.prototype.drawSingle = function (segment) {
    var h = this._handler,
        gl = h.gl;

    this._framebuffer.activate();

    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);

    if (segment.terrainReady && this._drawNormalMap(segment)) {
        segment.normalMapReady = true;
        segment.normalMapTexture = segment.normalMapTexturePtr;
        segment.normalMapTextureBias[0] = 0;
        segment.normalMapTextureBias[1] = 0;
        segment.normalMapTextureBias[2] = 1;
    }
    segment._inTheQueue = false;

    gl.disable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    this._framebuffer.deactivate();
};

NormalMapCreator.prototype.frame = function () {

    if (this._queue.length) {
        var h = this._handler,
            gl = h.gl;

        this._framebuffer.activate();

        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);

        var deltaTime = 0,
            startTime = window.performance.now();

        var width = this._width,
            height = this._height;

        while (this._lock.isFree() && this._queue.length && deltaTime < 0.25) {
            var segment = this._queue.shift();
            if (segment.terrainReady && this._drawNormalMap(segment)) {
                segment.normalMapReady = true;
                segment.normalMapTexture = segment.normalMapTexturePtr;
                segment.normalMapTextureBias[0] = 0;
                segment.normalMapTextureBias[1] = 0;
                segment.normalMapTextureBias[2] = 1;
            }
            segment._inTheQueue = false;
            deltaTime = window.performance.now() - startTime;
        }

        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        this._framebuffer.deactivate();
    }
};

NormalMapCreator.prototype.queue = function (segment) {
    segment._inTheQueue = true;
    this._queue.push(segment);
};

NormalMapCreator.prototype.unshift = function (segment) {
    segment._inTheQueue = true;
    this._queue.unshift(segment);
};

NormalMapCreator.prototype.remove = function (segment) {
    //...
};

NormalMapCreator.prototype.clear = function () {
    while (this._queue.length) {
        var s = this._queue.pop();
        s._inTheQueue = false;
    }
};

/**
 * Set activity off
 * @public
 */
NormalMapCreator.prototype.lock = function (key) {
    this._lock.lock(key);
};

/**
 * Set activity on
 * @public
 */
NormalMapCreator.prototype.free = function (key) {
    this._lock.free(key);
};



/***/ }),

/***/ "./src/og/utils/SDFCreator.js":
/*!************************************!*\
  !*** ./src/og/utils/SDFCreator.js ***!
  \************************************/
/*! exports provided: SDFCreator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SDFCreator", function() { return SDFCreator; });
/* harmony import */ var _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/Framebuffer.js */ "./src/og/webgl/Framebuffer.js");
/* harmony import */ var _webgl_Handler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Handler.js */ "./src/og/webgl/Handler.js");
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/utils/SDFCreator
 */








class SDFCreator {
    constructor(width, height) {
        this._handler = null;
        this._framebuffer0 = null;
        this._framebuffer1 = null;
        this._framebuffer2 = null;
        this._vertexBuffer = null;

        //default params
        this._width = width || 512;
        this._height = height || 512;
        var s = Math.max(this._width, this._height);
        this._outsideDistance = Math.round(80 * s / 512);
        this._insideDistance = Math.round(10 * s / 512);
        this._outsideMix = 0.710;
        this._insideMix = 0.679;
        this._sourceTexture = null;

        this.initialize();
    }

    initialize() {
        this._initHandler(this._width, this._height);
        this._initShaders();
    }

    _initHandler(width, height) {

        this._handler = new _webgl_Handler_js__WEBPACK_IMPORTED_MODULE_1__["Handler"](null, {
            width: width, height: height,
            context: { alpha: true, depth: false }
        });
        this._handler.initialize();
        this._handler.deactivateFaceCulling();
        this._handler.deactivateDepthTest();

        this._vertexBuffer = this._handler.createArrayBuffer(new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]), 2, 4);

        this._framebuffer0 = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](this._handler, { useDepth: false });
        this._framebuffer1 = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](this._handler, { useDepth: false });
        this._framebuffer2 = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](this._handler, { useDepth: false });

        this._framebuffer0.init();
        this._framebuffer1.init();
        this._framebuffer2.init();
    }
    _initShaders() {
        var vfield = new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__["ShaderProgram"]("vfield", {
            uniforms: {
                uTexSize: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                uTex1: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].SAMPLER2D },
                uDistance: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].INT },
                uNeg: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 }
            },
            attributes: {
                aPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2, enableArray: true }
            },
            vertexShader:
            "precision highp float;\
            attribute vec2 aPos;\
            uniform vec2 uTexSize;\
            varying vec2 TexCoord;\
            varying vec2 vTexSize;\
            void main() {\
                TexCoord = (aPos + 1.0) * 0.5;\
                TexCoord *= uTexSize;\
                vTexSize = uTexSize;\
                gl_Position.xy = aPos;\
                gl_Position.zw = vec2(0.0, 1.0);\
            }",
            fragmentShader:
            "precision highp float;\
            uniform sampler2D uTex1;\
            uniform int uDistance;\
            uniform vec2 uNeg;\
            varying vec2 TexCoord;\
            varying vec2 vTexSize;\
            const int maxDistance = " + this._outsideDistance + ";\
            void main() {\
                if ( uNeg.x - uNeg.y * texture2D(uTex1, TexCoord / vTexSize).r > 0.5 ) {\
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\
                    return;\
                }\
                for ( int i=1; i <= maxDistance; i++ ) {\
                    if(i > uDistance) break;\
                    if ( uNeg.x - uNeg.y * texture2D(uTex1, ( TexCoord + vec2(0.0, i) ) / vTexSize ).r > 0.5 ) {\
                        gl_FragColor = vec4( vec3(float(i)/float(uDistance)), 1.0 );\
                        return;\
                    }\
                    if ( uNeg.x - uNeg.y * texture2D(uTex1, ( TexCoord - vec2(0.0, i)) / vTexSize ).r > 0.5 ) {\
                        gl_FragColor = vec4(vec3(float(i)/float(uDistance)), 1.0);\
                        return;\
                    }\
                }\
                gl_FragColor = vec4(1.0);\
            }"
        });

        var hfield = new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__["ShaderProgram"]("hfield", {
            uniforms: {
                uTexSize: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                uTex1: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].SAMPLER2D },
                uDistance: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].INT }
            },
            attributes: {
                aPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2, enableArray: true }
            },
            vertexShader:
            "precision highp float;\
            attribute vec2 aPos;\
            uniform vec2 uTexSize;\
            varying vec2 TexCoord;\
            varying vec2 vTexSize;\
            void main() {\n\
                TexCoord = (aPos + 1.0) * 0.5;\
                TexCoord *= uTexSize;\
                vTexSize = uTexSize;\
                gl_Position.xy = aPos;\
                gl_Position.zw = vec2(0.0, 1.0);\
            }",
            fragmentShader:
            "precision highp float;\
            uniform sampler2D uTex1;\
            uniform int uDistance;\
            varying vec2 TexCoord;\
            varying vec2 vTexSize;\
            const int maxDistance = " + this._outsideDistance + ";\
            float CalcC(float H, float V) {\
                return ( sqrt( H * H + V * V ) );\
            }\
            void main(){\
                float dist = CalcC( 0.0, texture2D( uTex1, TexCoord / vTexSize ).r );\
                for ( int i = 1; i <= maxDistance; i++ ) {\
                    if(i > uDistance) break;\
                    float H = float(i) / float(uDistance);\
                    dist = min( dist, CalcC( H, texture2D( uTex1, ( TexCoord + vec2( float(i), 0.0) ) / vTexSize ).r ) );\
                    dist = min( dist, CalcC( H, texture2D( uTex1, ( TexCoord - vec2( float(i), 0.0) ) / vTexSize ).r ) );\
                }\
                gl_FragColor = vec4(dist);\
                gl_FragColor.w = 1.0;\
            }"
        });

        var sum = new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__["ShaderProgram"]("sum", {
            uniforms: {
                outside: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].SAMPLER2D },
                inside: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].SAMPLER2D },
                source: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].SAMPLER2D }
            },
            attributes: {
                aPos: { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2, enableArray: true }
            },
            vertexShader: "attribute vec2 aPos;\n\
                        varying vec2 TexCoord;\n\
                        void main(){\n\
                            TexCoord = (aPos * vec2(1.0,-1.0) + 1.0) * 0.5;\n\
                            gl_Position.xy = aPos;\n\
                            gl_Position.zw = vec2(0.0, 1.0);\n\
                        }",
            fragmentShader:
            "precision highp float;\n\
                        uniform sampler2D outside;\n\
                        uniform sampler2D inside;\n\
                        uniform sampler2D source;\n\
                        varying vec2 TexCoord;\n\
                        void main(){\n\
                            float o = texture2D(outside, TexCoord).r;\n\
                            float i = 1.0 - texture2D(inside, TexCoord).r;\n\
                            float s = texture2D(source, TexCoord).r;\n\
                            gl_FragColor = vec4( vec3(1.0 - mix(i, o, step(0.5, s) * " + this._outsideMix + " + (1.0 - step(0.5, s)) * " + this._insideMix + " )), 1.0);\n\
                        }"
        });
        this._handler.addShaderPrograms([vfield, hfield, sum]);
    };

    setSize(width, height) {
        if (width != this._width || height != this._height) {
            this._width = width;
            this._height = height;
            this._handler.setSize(width, height);
            this._framebuffer0.setSize(width, height);
            this._framebuffer1.setSize(width, height);
        }
    }

    createSDF(sourceCanvas, width, height) {

        var h = this._handler,
            gl = h.gl;

        h.setSize(this._width, this._height);

        gl.deleteTexture(this._sourceTexture);

        this._sourceTexture = h.createTexture_l(sourceCanvas);

        h.shaderPrograms.vfield.activate();
        var sh = h.shaderPrograms.vfield._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
        gl.uniform1i(shu.uTex1._pName, 0);
        gl.uniform2fv(shu.uTexSize._pName, [this._width, this._height]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.aPos._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //VERT
        this._framebuffer0.activate();
        gl.uniform1i(shu.uDistance._pName, this._outsideDistance);
        gl.uniform2fv(shu.uNeg._pName, [0.0, -1.0]);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        this._framebuffer0.deactivate();

        //NEG VERT
        this._framebuffer2.activate();
        gl.uniform2fv(shu.uNeg._pName, [1.0, 1.0]);
        gl.uniform1i(shu.uDistance._pName, this._insideDistance);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        this._framebuffer2.deactivate();

        h.shaderPrograms.hfield.activate();
        var sh = h.shaderPrograms.hfield._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        gl.uniform2fv(shu.uTexSize._pName, [this._width, this._height]);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.aPos._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //HORIZ
        this._framebuffer1.activate();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._framebuffer0.texture);
        gl.uniform1i(shu.uTex1._pName, 0);
        gl.uniform1i(shu.uDistance._pName, this._outsideDistance);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        this._framebuffer1.deactivate();

        //NEG HORIZ
        this._framebuffer0.activate();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._framebuffer2.texture);
        gl.uniform1i(shu.uTex1._pName, 0);
        gl.uniform1i(shu.uDistance._pName, this._insideDistance);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        this._framebuffer0.deactivate();

        h.setSize(width || this._width, height || this._height);

        //SUM
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        h.shaderPrograms.sum.activate();
        var sh = h.shaderPrograms.sum._program;
        var sha = sh.attributes,
            shu = sh.uniforms;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._framebuffer1.texture);
        gl.uniform1i(shu.outside._pName, 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this._framebuffer0.texture);
        gl.uniform1i(shu.inside._pName, 1);
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, this._sourceTexture);
        gl.uniform1i(shu.source._pName, 2);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(sha.aPos._pName, this._vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        return h.canvas;
    }
};




/***/ }),

/***/ "./src/og/utils/TerrainWorker.js":
/*!***************************************!*\
  !*** ./src/og/utils/TerrainWorker.js ***!
  \***************************************/
/*! exports provided: TerrainWorker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TerrainWorker", function() { return TerrainWorker; });
/* harmony import */ var _QueueArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../QueueArray.js */ "./src/og/QueueArray.js");
/**
 * @module og/utils/TerrainWorker
 */

'use sctrict';



class TerrainWorker {
    constructor(numWorkers = 2) {
        this._workerQueue = new _QueueArray_js__WEBPACK_IMPORTED_MODULE_0__["QueueArray"](numWorkers);
        var elevationProgramm = new Blob([_programm], { type: 'application/javascript' });

        for (let i = 0; i < numWorkers; i++) {
            this._workerQueue.push(new Worker(URL.createObjectURL(elevationProgramm)));
        }

        this._pendingQueue = new _QueueArray_js__WEBPACK_IMPORTED_MODULE_0__["QueueArray"](512);
    }

    make(segment, elevations) {

        if (segment.ready && segment.terrainIsLoading) {

            var _elevations = new Float32Array(elevations.length);
            _elevations.set(elevations);

            if (this._workerQueue.length) {

                var that = this;

                var w = this._workerQueue.pop();

                w.onmessage = function (e) {
                    segment._terrainWorkerCallback(e.data);
                    that._workerQueue.unshift(this);
                    if (that._pendingQueue.length) {
                        var p = that._pendingQueue.pop();
                        that.make(p.segment, p.elevations)
                    }
                };

                w.postMessage({
                    'elevations': _elevations,
                    'this_plainVertices': segment.plainVertices,
                    'this_plainNormals': segment.plainNormals,
                    'this_normalMapVertices': segment.normalMapVertices,
                    'this_normalMapNormals': segment.normalMapNormals,
                    'heightFactor': segment.planet._heightFactor,
                    'gridSize': segment.planet.terrain.gridSizeByZoom[segment.tileZoom]
                }, [
                        _elevations.buffer,
                        segment.plainVertices.buffer,
                        segment.plainNormals.buffer,
                        segment.normalMapVertices.buffer,
                        segment.normalMapNormals.buffer
                    ]);
            } else {
                this._pendingQueue.push({ 'segment': segment, 'elevations': _elevations });
            }
        }
    }
};

const _programm =
    'self.onmessage = function (e) {\n\
        \n\
        var Vector3 = function(x, y, z) {\n\
            this.x = x;\n\
            this.y = y;\n\
            this.z = z;\n\
        };\n\
        Vector3.prototype.sub = function(v) {\n\
            return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);\n\
        };\n\
        Vector3.prototype.add = function(v) {\n\
            return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);\n\
        };\n\
        Vector3.prototype.cross = function(v) {\n\
            return new Vector3(\n\
                this.y * v.z - this.z * v.y,\n\
                this.z * v.x - this.x * v.z,\n\
                this.x * v.y - this.y * v.x\n\
            );\n\
        };\n\
        Vector3.prototype.normalize = function(v) {\n\
            var x = this.x, y = this.y, z = this.z;\n\
            var length = 1.0 / Math.sqrt(x * x + y * y + z * z);\n\
            this.x = x * length;\n\
            this.y = y * length;\n\
            this.z = z * length;\n\
            return this;\n\
        };\n\
        \n\
        var slice = function (t, h1, h0) {\n\
          return t * (h1 - h0);\n\
        };\n\
        \n\
        var elevations = e.data.elevations,\n\
            this_plainVertices = e.data.this_plainVertices,\n\
            this_plainNormals = e.data.this_plainNormals,\n\
            this_normalMapVertices = e.data.this_normalMapVertices,\n\
            this_normalMapNormals = e.data.this_normalMapNormals,\n\
            heightFactor =  e.data.heightFactor,\n\
            //fileGridSize = e.data.fileGridSize,\n\
            gridSize = e.data.gridSize;\n\
        \n\
        var xmin = 549755748352, xmax = -549755748352, ymin = 549755748352, ymax = -549755748352, zmin = 549755748352, zmax = -549755748352;\n\
\n\
        fileGridSize = Math.sqrt(elevations.length) - 1;\n\
\n\
        var fileGridSize_one = fileGridSize + 1,\n\
            tgs = gridSize,\n\
            dg = fileGridSize / tgs,\n\
            gs = tgs + 1,\n\
            hf = heightFactor;\n\
\n\
        var nmvInd = 0;\n\
        var vInd = 0;\n\
\n\
        var terrainVertices = new Float32Array(gs * gs * 3);\n\
        var normalMapNormals = new Float32Array(fileGridSize_one * fileGridSize_one * 3);\n\
        var normalMapVertices = new Float32Array(fileGridSize_one * fileGridSize_one * 3);\n\
\n\
        var nv = this_normalMapVertices,\n\
            nn = this_normalMapNormals;\n\
\n\
        if (fileGridSize >= tgs) {\n\
            for (var i = 0; i < fileGridSize_one; i++) {\n\
                for (var j = 0; j < fileGridSize_one; j++) {\n\
                    var hInd0 = i * fileGridSize_one + j;\n\
                    var vInd0 = hInd0 * 3;\n\
                    var h0 = hf * elevations[hInd0];\n\
                    var v0 = new Vector3(nv[vInd0] + h0 * nn[vInd0], nv[vInd0 + 1] + h0 * nn[vInd0 + 1], nv[vInd0 + 2] + h0 * nn[vInd0 + 2]);\n\
                    normalMapVertices[vInd0] = v0.x;\n\
                    normalMapVertices[vInd0 + 1] = v0.y;\n\
                    normalMapVertices[vInd0 + 2] = v0.z;\n\
\n\
                    if (i % dg == 0 && j % dg == 0) {\n\
                        terrainVertices[vInd++] = v0.x;\n\
                        terrainVertices[vInd++] = v0.y;\n\
                        terrainVertices[vInd++] = v0.z;\n\
\n\
                        if (v0.x < xmin) xmin = v0.x; if (v0.x > xmax) xmax = v0.x;\n\
                        if (v0.y < ymin) ymin = v0.y; if (v0.y > ymax) ymax = v0.y;\n\
                        if (v0.z < zmin) zmin = v0.z; if (v0.z > zmax) zmax = v0.z;\n\
                    }\n\
\n\
                    if (i != fileGridSize && j != fileGridSize) {\n\
                        var hInd1 = i * fileGridSize_one + j + 1;\n\
                        var vInd1 = hInd1 * 3;\n\
                        var h1 = hf * elevations[hInd1];\n\
                        var v1 = new Vector3(nv[vInd1] + h1 * nn[vInd1], nv[vInd1 + 1] + h1 * nn[vInd1 + 1], nv[vInd1 + 2] + h1 * nn[vInd1 + 2]);\n\
                        normalMapVertices[vInd1] = v1.x;\n\
                        normalMapVertices[vInd1 + 1] = v1.y;\n\
                        normalMapVertices[vInd1 + 2] = v1.z;\n\
\n\
                        var hInd2 = (i + 1) * fileGridSize_one + j;\n\
                        var vInd2 = hInd2 * 3;\n\
                        var h2 = hf * elevations[hInd2];\n\
                        var v2 = new Vector3(\n\
                            nv[vInd2] + h2 * nn[vInd2],\n\
                            nv[vInd2 + 1] + h2 * nn[vInd2 + 1],\n\
                            nv[vInd2 + 2] + h2 * nn[vInd2 + 2]);\n\
                        normalMapVertices[vInd2] = v2.x;\n\
                        normalMapVertices[vInd2 + 1] = v2.y;\n\
                        normalMapVertices[vInd2 + 2] = v2.z;\n\
\n\
                        var hInd3 = (i + 1) * fileGridSize_one + (j + 1);\n\
                        var vInd3 = hInd3 * 3;\n\
                        var h3 = hf * elevations[hInd3];\n\
                        var v3 = new Vector3(nv[vInd3] + h3 * nn[vInd3], nv[vInd3 + 1] + h3 * nn[vInd3 + 1], nv[vInd3 + 2] + h3 * nn[vInd3 + 2]);\n\
                        normalMapVertices[vInd3] = v3.x;\n\
                        normalMapVertices[vInd3 + 1] = v3.y;\n\
                        normalMapVertices[vInd3 + 2] = v3.z;\n\
\n\
                        var e10 = v1.sub(v0),\n\
                            e20 = v2.sub(v0),\n\
                            e30 = v3.sub(v0);\n\
                        var sw = e20.cross(e30).normalize();\n\
                        var ne = e30.cross(e10).normalize();\n\
                        var n0 = ne.add(sw).normalize();\n\
\n\
                        normalMapNormals[vInd0] += n0.x;\n\
                        normalMapNormals[vInd0 + 1] += n0.y;\n\
                        normalMapNormals[vInd0 + 2] += n0.z;\n\
\n\
                        normalMapNormals[vInd1] += ne.x;\n\
                        normalMapNormals[vInd1 + 1] += ne.y;\n\
                        normalMapNormals[vInd1 + 2] += ne.z;\n\
\n\
                        normalMapNormals[vInd2] += sw.x;\n\
                        normalMapNormals[vInd2 + 1] += sw.y;\n\
                        normalMapNormals[vInd2 + 2] += sw.z;\n\
\n\
                        normalMapNormals[vInd3] += n0.x;\n\
                        normalMapNormals[vInd3 + 1] += n0.y;\n\
                        normalMapNormals[vInd3 + 2] += n0.z;\n\
                    }\n\
                }\n\
            }\n\
\n\
        } else {\n\
\n\
            var plain_verts = this_plainVertices;\n\
            var plainNormals = this_plainNormals;\n\
\n\
            var oneSize = tgs / fileGridSize;\n\
            var h, inside_i, inside_j, v_i, v_j;\n\
\n\
            for (var i = 0; i < gs; i++) {\n\
                if (i == gs - 1) {\n\
                    inside_i = oneSize;\n\
                    v_i = Math.floor(i / oneSize) - 1;\n\
                } else {\n\
                    inside_i = i % oneSize;\n\
                    v_i = Math.floor(i / oneSize);\n\
                }\n\
\n\
                for (var j = 0; j < gs; j++) {\n\
                    if (j == gs - 1) {\n\
                        inside_j = oneSize;\n\
                        v_j = Math.floor(j / oneSize) - 1;\n\
                    } else {\n\
                        inside_j = j % oneSize;\n\
                        v_j = Math.floor(j / oneSize);\n\
                    }\n\
\n\
                    var hvlt = elevations[v_i * fileGridSize_one + v_j],\n\
                        hvrt = elevations[v_i * fileGridSize_one + v_j + 1],\n\
                        hvlb = elevations[(v_i + 1) * fileGridSize_one + v_j],\n\
                        hvrb = elevations[(v_i + 1) * fileGridSize_one + v_j + 1];\n\
\n\
                    if (inside_i + inside_j < oneSize) {\n\
                        h = hf * (hvlt + slice(inside_j / oneSize, hvrt, hvlt) + slice(inside_i / oneSize, hvlb, hvlt));\n\
                    } else {\n\
                        h = hf * (hvrb + slice((oneSize - inside_j) / oneSize, hvlb, hvrb) + slice((oneSize - inside_i) / oneSize, hvrt, hvrb));\n\
                    }\n\
\n\
                    var x = plain_verts[vInd] + h * plainNormals[vInd],\n\
                        y = plain_verts[vInd + 1] + h * plainNormals[vInd + 1],\n\
                        z = plain_verts[vInd + 2] + h * plainNormals[vInd + 2];\n\
\n\
                    terrainVertices[vInd] = x;\n\
                    terrainVertices[vInd + 1] = y;\n\
                    terrainVertices[vInd + 2] = z;\n\
\n\
                    vInd += 3;\n\
\n\
                    if (x < xmin) xmin = x; if (x > xmax) xmax = x;\n\
                    if (y < ymin) ymin = y; if (y > ymax) ymax = y;\n\
                    if (z < zmin) zmin = z; if (z > zmax) zmax = z;\n\
\n\
                }\n\
            }\n\
\n\
            normalMapNormals = this_plainNormals;\n\
        }\n\
        self.postMessage({ \n\
                normalMapNormals: normalMapNormals,\n\
                normalMapVertices: normalMapVertices,\n\
                terrainVertices: terrainVertices,\n\
                bounds: [xmin, xmax, ymin, ymax, zmin, zmax],\n\
             }, [normalMapNormals.buffer, normalMapVertices.buffer, terrainVertices.buffer]);\n\
    }';



/***/ }),

/***/ "./src/og/utils/TextureAtlas.js":
/*!**************************************!*\
  !*** ./src/og/utils/TextureAtlas.js ***!
  \**************************************/
/*! exports provided: TextureAtlas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureAtlas", function() { return TextureAtlas; });
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageCanvas.js */ "./src/og/ImageCanvas.js");
/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Rectangle.js */ "./src/og/Rectangle.js");
/* harmony import */ var _ImagesCacheManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImagesCacheManager.js */ "./src/og/utils/ImagesCacheManager.js");
/**
 * @module og/utils/TextureAtlas
 */








/**
 * Border beetween stored images.
 * @type {number}
 * @const
 */
const BORDER_SIZE = 4;

/**
 * Texture atlas stores images in one texture. Each image has texture 
 * coordinates returned with node creation by addImage function.
 * @class
 * @param {number} [width] - Texture atlas width, if it hasn't 1024 default.
 * @param {number} [height] - Texture atlas height, if it hasn't 1024 default..
 */
class TextureAtlas {
    constructor(width, height) {

        /**
         * Atlas nodes where input images store. It can be access by image.__nodeIndex.
         * @public
         * @type {Array.<og.utils.TextureAtlasNode >}
         */
        this.nodes = [];

        /**
         * Created gl texture.
         * @public
         */
        this.texture = null;

        /**
         * Atlas canvas.
         * @public
         * @type {canvas}
         */
        this.canvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__["ImageCanvas"](width || 1024, height || 1024);
        this.clearCanvas();

        this._handler = null;
        this._images = [];
        this._btree = null;
        this._imagesCacheManager = new _ImagesCacheManager_js__WEBPACK_IMPORTED_MODULE_2__["ImagesCacheManager"]();
        this.borderSize = 4;
    }

    /**
     * Returns atlas javascript image object.
     * @public
     * @returns {Object}
     */
    getImage() {
        return this.canvas.getImage();
    }

    /**
     * Returns canvas object.
     * @public
     * @retuns {Object}
     */
    getCanvas() {
        return this.canvas._canvas;
    }

    /**
     * Clear atlas with black.
     * @public
     */
    clearCanvas() {
        this.canvas.fillEmpty("black");
    }

    /**
     * Sets openglobus gl handler that creates gl texture.
     * @public
     * @param {og.webgl.Handler} handler - WebGL handler.
     */
    assignHandler(handler) {
        this._handler = handler;
        this.createTexture();
    }

    /**
     * Returns image diagonal size.
     * @param {Object} image - JavaSript image object.
     * @returns {number}
     */
    getDiagonal(image) {
        var w = image.atlasWidth || image.width,
            h = image.atlasHeight || image.height;
        return Math.sqrt(w * w + h * h);
    }

    /**
     * Adds image to the atlas and returns creted node with texture coordinates of the stored image.
     * @public
     * @param {Object} image - Input javascript image object.
     * @param {boolean} [fastInsert] - If it's true atlas doesnt restore all images again 
     * and store image in the curent atlas sheme.
     * @returns {og.utils.TextureAtlasNode}
     */
    addImage(image, fastInsert) {

        if (!(image.width && image.height)) {
            return;
        }

        this._images.push(image);

        this._makeAtlas(fastInsert);

        return this.nodes[image.__nodeIndex];
    }

    /**
     * Calculate texture coordianates and stores node.
     * @private
     */
    _completeNode(nodes, node) {
        if (node) {
            var w = this.canvas.getWidth(),
                h = this.canvas.getHeight();
            var im = node.image;
            var r = node.rect;
            var bs = Math.round(this.borderSize * 0.5);
            this.canvas.drawImage(im, r.left + bs, r.top + bs, im.atlasWidth, im.atlasHeight);
            var tc = node.texCoords;

            tc[0] = (r.left + bs) / w;
            tc[1] = (r.top + bs) / h;

            tc[2] = (r.left + bs) / w;
            tc[3] = (r.bottom - bs) / h;

            tc[4] = (r.right - bs) / w;
            tc[5] = (r.bottom - bs) / h;

            tc[6] = (r.right - bs) / w;
            tc[7] = (r.bottom - bs) / h;

            tc[8] = (r.right - bs) / w;
            tc[9] = (r.top + bs) / h;

            tc[10] = (r.left + bs) / w;
            tc[11] = (r.top + bs) / h;

            nodes[im.__nodeIndex] = node;
        }
    }

    /**
     * Main atlas making function.
     * @private
     * @param {boolean} [fastInsert] - If it's true atlas doesnt restore all images again 
     * and store image in the curent atlas sheme.
     */
    _makeAtlas(fastInsert) {

        if (fastInsert && this._btree) {
            var im = this._images[this._images.length - 1];
            this._completeNode(this.nodes, this._btree.insert(im));
        } else {
            var im = this._images.slice(0);

            im.sort(function (b, a) {
                return ((a.atlasWidth || a.width) - (b.atlasWidth || b.width)) || ((a.atlasHeight || a.height) - (b.atlasHeight || b.height));
            });

            this._btree = new TextureAtlasNode(new _Rectangle_js__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](0, 0, this.canvas.getWidth(), this.canvas.getHeight()));
            this._btree.atlas = this;

            this.clearCanvas();

            var newNodes = [];
            for (var i = 0; i < im.length; i++) {
                this._completeNode(newNodes, this._btree.insert(im[i]));
            }
            this.nodes = [];
            this.nodes = newNodes;
        }
    }

    /**
     * Creates atlas gl texture.
     * @public
     */
    createTexture() {
        if (this._handler) {
            this._handler.gl.deleteTexture(this.texture);
            this.texture = this._handler.createTexture_l(this.canvas._canvas);
        }
    }

    /**
     * Image handler callback. 
     * @callback Object~successCallback
     * @param {Image} img - Loaded image.
     */

    /**
     * Asynchronous function that loads and creates image to the image cache, and call success callback when it's done.
     * @public
     * @param {string} src - Image object src string.
     * @param {Object~successCallback} success - The callback that handles the image loads done.
     */
    loadImage(src, success) {
        this._imagesCacheManager.load(src, success);
    }
};

/**
 * Atlas binary tree node.
 * @class
 * @prarm {og.Rectangle} rect - Node image rectangle.
 */
class TextureAtlasNode {
    constructor(rect) {
        this.childNodes = null;
        this.image = null;
        this.rect = rect;
        this.texCoords = [];
        this.atlas = null;
    }

    /**
     * This algorithm has got from here:
     * http://www.blackpawn.com/texts/lightmaps/default.html
     */
    insert(img) {

        if (this.childNodes) {

            var newNode = this.childNodes[0].insert(img);

            if (newNode != null)
                return newNode;

            return this.childNodes[1].insert(img);

        } else {

            if (this.image != null)
                return null;

            var rc = this.rect;
            var w = (img.atlasWidth || img.width) + this.atlas.borderSize;
            var h = (img.atlasHeight || img.height) + this.atlas.borderSize;

            if (w > rc.getWidth() || h > rc.getHeight())
                return null;

            if (rc.fit(w, h)) {
                this.image = img;
                return this;
            }

            this.childNodes = new Array(2);
            this.childNodes[0] = new TextureAtlasNode();
            this.childNodes[0].atlas = this.atlas;
            this.childNodes[1] = new TextureAtlasNode();
            this.childNodes[1].atlas = this.atlas;

            var dw = rc.getWidth() - w;
            var dh = rc.getHeight() - h;

            if (dw > dh) {
                this.childNodes[0].rect = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](rc.left, rc.top, rc.left + w, rc.bottom);
                this.childNodes[1].rect = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](rc.left + w, rc.top, rc.right, rc.bottom);
            } else {
                this.childNodes[0].rect = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](rc.left, rc.top, rc.right, rc.top + h);
                this.childNodes[1].rect = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_1__["Rectangle"](rc.left, rc.top + h, rc.right, rc.bottom);
            }

            return this.childNodes[0].insert(img);
        }
    }
};



/***/ }),

/***/ "./src/og/utils/VectorTileCreator.js":
/*!*******************************************!*\
  !*** ./src/og/utils/VectorTileCreator.js ***!
  \*******************************************/
/*! exports provided: VectorTileCreator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorTileCreator", function() { return VectorTileCreator; });
/* harmony import */ var _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../quadTree/quadTree.js */ "./src/og/quadTree/quadTree.js");
/* harmony import */ var _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Framebuffer.js */ "./src/og/webgl/Framebuffer.js");
/* harmony import */ var _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram.js */ "./src/og/webgl/ShaderProgram.js");
/* harmony import */ var _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/types.js */ "./src/og/webgl/types.js");
/**
 * @module og/utils/VectorTileCreator
 */

'use sctrict';






const VectorTileCreator = function (planet, maxFrames, width, height) {

    this._width = width || 256;
    this._height = height || 256;
    this._handler = planet.renderer.handler;
    this._planet = planet;
    this._framebuffer = null;
    this.MAX_FRAMES = maxFrames || 5;
    this._currentFrame = 0;
    this._queue = [];
    this._initialize();
};

VectorTileCreator.prototype._initialize = function () {

    //Line
    if (!this._handler.shaderPrograms.vectorTileLineRasterization) {
        this._handler.addShaderProgram(new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__["ShaderProgram"]("vectorTileLineRasterization", {
            uniforms: {
                'viewport': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                'thicknessOutline': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].FLOAT },
                'alpha': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].FLOAT },
                'extentParams': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC4 }
            },
            attributes: {
                'prev': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                'current': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                'next': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                'order': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].FLOAT },
                'color': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC4 },
                'thickness': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].FLOAT }
            },
            vertexShader: 'attribute vec2 prev;\
                attribute vec2 current;\
                attribute vec2 next;\
                attribute float order;\
                attribute float thickness;\
                attribute vec4 color;\
                uniform float thicknessOutline;\
                uniform vec2 viewport;\
                uniform vec4 extentParams;\
                varying vec4 vColor;\
                \
                vec2 proj(vec2 coordinates){\
                    return vec2(-1.0 + (coordinates - extentParams.xy) * extentParams.zw) * vec2(1.0, -1.0);\
                }\
                \
                void main(){\
                    vColor = color;\
                    vec2 _next = next;\
                    vec2 _prev = prev;\
                    if(prev == current){\
                        if(next == current){\
                            _next = current + vec2(1.0, 0.0);\
                            _prev = current - next;\
                        }else{\
                            _prev = current + normalize(current - next);\
                        }\
                    }\
                    if(next == current){\
                        _next = current + normalize(current - _prev);\
                    }\
                    \
                    vec2 sNext = proj(_next),\
                         sCurrent = proj(current),\
                         sPrev = proj(_prev);\
                    vec2 dirNext = normalize(sNext - sCurrent);\
                    vec2 dirPrev = normalize(sPrev - sCurrent);\
                    float dotNP = dot(dirNext, dirPrev);\
                    \
                    vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));\
                    vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));\
                    vec2 d = (thickness + thicknessOutline) * 0.5 * sign(order) / viewport;\
                    \
                    vec2 m;\
                    if(dotNP >= 0.99991){\
                        m = sCurrent - normalPrev * d;\
                    }else{\
                        vec2 dir = normalPrev + normalNext;\
                        m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);\
                        \
                        if( dotNP > 0.5 && dot(dirNext + dirPrev, m - sCurrent) < 0.0 ){\
                            float occw = order * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x);\
                            if(occw == -1.0){\
                                m = sCurrent + normalPrev * d;\
                            }else if(occw == 1.0){\
                                m = sCurrent + normalNext * d;\
                            }else if(occw == -2.0){\
                                m = sCurrent + normalNext * d;\
                            }else if(occw == 2.0){\
                                m = sCurrent + normalPrev * d;\
                            }\
                        }else if(distance(sCurrent, m) > min(distance(sCurrent, sNext), distance(sCurrent, sPrev))){\
                            m = sCurrent + normalNext * d;\
                        }\
                    }\
                    gl_Position = vec4(m.x, m.y, 0.0, 1.0);\
                }',
            fragmentShader: 'precision highp float;\
                uniform float alpha;\
                varying vec4 vColor;\
                void main() {\
                    gl_FragColor = vec4(vColor.rgb, alpha * vColor.a);\
                }'
        }));
    }

    //Polygon
    if (!this._handler.shaderPrograms.vectorTilePolygonRasterization) {
        this._handler.addShaderProgram(new _webgl_ShaderProgram_js__WEBPACK_IMPORTED_MODULE_2__["ShaderProgram"]("vectorTilePolygonRasterization", {
            uniforms: {
                'extentParams': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC4 }
            },
            attributes: {
                'coordinates': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC2 },
                'colors': { type: _webgl_types_js__WEBPACK_IMPORTED_MODULE_3__["types"].VEC4 }
            },
            vertexShader: 'attribute vec2 coordinates; \
                      attribute vec4 colors; \
                      uniform vec4 extentParams; \
                      varying vec4 color;\
                      void main() { \
                          color = colors;\
                          gl_Position = vec4((-1.0 + (coordinates - extentParams.xy) * extentParams.zw) * vec2(1.0, -1.0), 0.0, 1.0); \
                      }',
            fragmentShader: 'precision highp float;\
                        varying vec4 color;\
                        void main () {  \
                            gl_FragColor = color; \
                        }'
        }));
    }

    this._framebuffer = new _webgl_Framebuffer_js__WEBPACK_IMPORTED_MODULE_1__["Framebuffer"](this._handler, {
        width: this._width,
        height: this._height,
        useDepth: false
    });
    this._framebuffer.init();
};

VectorTileCreator.prototype.frame = function () {
    if (this._planet.layerLock.isFree() && this._queue.length) {
        var h = this._handler,
            gl = h.gl;

        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        var hLine = h.shaderPrograms.vectorTileLineRasterization,
            hPoly = h.shaderPrograms.vectorTilePolygonRasterization;

        var width, height;
        var pickingMask, texture;

        var prevLayerId = -1;

        var extentParams = new Array(4);

        var f = this._framebuffer.activate();

        var width2 = this._width * 2,
            height2 = this._height * 2;

        var deltaTime = 0,
            startTime = window.performance.now();

        while (this._planet.layerLock.isFree() && this._queue.length && deltaTime < 0.25) {
            var material = this._queue.shift();
            if (material.isLoading && material.segment.node.getState() === _quadTree_quadTree_js__WEBPACK_IMPORTED_MODULE_0__["RENDERING"]) {

                if (material.segment.tileZoom <= 3) {
                    width = width2;
                    height = height2;
                } else {
                    width = this._width;
                    height = this._height;
                }

                texture = material._updateTexture && material._updateTexture || h.createEmptyTexture_l(width, height);

                f.setSize(width, height);

                f.bindOutputTexture(texture);

                gl.clearColor(1.0, 1.0, 1.0, 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                var extent = material.segment.getExtentMerc();
                extentParams[0] = extent.southWest.lon;
                extentParams[1] = extent.southWest.lat;
                extentParams[2] = 2.0 / extent.getWidth();
                extentParams[3] = 2.0 / extent.getHeight();

                hPoly.activate();
                var sh = hPoly._program;
                var sha = sh.attributes,
                    shu = sh.uniforms;

                var geomHandler = material.layer._geometryHandler;

                //=========================================
                //Polygon rendering
                //=========================================
                gl.uniform4fv(shu.extentParams._pName, extentParams);

                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyVerticesBufferMerc);
                gl.vertexAttribPointer(sha.coordinates._pName, geomHandler._polyVerticesBufferMerc.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyColorsBuffer);
                gl.vertexAttribPointer(sha.colors._pName, geomHandler._polyColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._polyIndexesBuffer);

                gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);

                //Polygon picking PASS
                if (material.layer._pickingEnabled) {
                    if (!material.pickingReady) {
                        if (material._updatePickingMask) {
                            pickingMask = material._updatePickingMask;
                        } else {
                            pickingMask = h.createEmptyTexture_n(width, height);
                        }

                        f.bindOutputTexture(pickingMask);

                        gl.clearColor(0.0, 0.0, 0.0, 0.0);
                        gl.clear(gl.COLOR_BUFFER_BIT);

                        gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._polyPickingColorsBuffer);
                        gl.vertexAttribPointer(sha.colors._pName, geomHandler._polyPickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.drawElements(gl.TRIANGLES, geomHandler._polyIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                    } else {
                        pickingMask = material.pickingMask;
                    }
                }

                //=========================================
                //Strokes and linestrings rendering
                //=========================================
                f.bindOutputTexture(texture);

                hLine.activate();
                sh = hLine._program;
                sha = sh.attributes;
                shu = sh.uniforms;

                gl.uniform2fv(shu.viewport._pName, [width, height]);

                gl.uniform4fv(shu.extentParams._pName, extentParams);

                //vertex
                var mb = geomHandler._lineVerticesBufferMerc;
                gl.bindBuffer(gl.ARRAY_BUFFER, mb);
                gl.vertexAttribPointer(sha.prev._pName, mb.itemSize, gl.FLOAT, false, 8, 0);
                gl.vertexAttribPointer(sha.current._pName, mb.itemSize, gl.FLOAT, false, 8, 32);
                gl.vertexAttribPointer(sha.next._pName, mb.itemSize, gl.FLOAT, false, 8, 64);

                //order
                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineOrdersBuffer);
                gl.vertexAttribPointer(sha.order._pName, geomHandler._lineOrdersBuffer.itemSize, gl.FLOAT, false, 4, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geomHandler._lineIndexesBuffer);

                //PASS - stroke
                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokesBuffer);
                gl.vertexAttribPointer(sha.thickness._pName, geomHandler._lineStrokesBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineStrokeColorsBuffer);
                gl.vertexAttribPointer(sha.color._pName, geomHandler._lineStrokeColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                //Antialias pass
                gl.uniform1f(shu.thicknessOutline._pName, 2);
                gl.uniform1f(shu.alpha._pName, 0.54);
                gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                //
                //Aliased pass
                gl.uniform1f(shu.thicknessOutline._pName, 1);
                gl.uniform1f(shu.alpha._pName, 1.0);
                gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);

                //PASS - inside line
                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineThicknessBuffer);
                gl.vertexAttribPointer(sha.thickness._pName, geomHandler._lineThicknessBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._lineColorsBuffer);
                gl.vertexAttribPointer(sha.color._pName, geomHandler._lineColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);

                //Antialias pass
                gl.uniform1f(shu.thicknessOutline._pName, 2);
                gl.uniform1f(shu.alpha._pName, 0.54);
                gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                //
                //Aliased pass
                gl.uniform1f(shu.thicknessOutline._pName, 1);
                gl.uniform1f(shu.alpha._pName, 1.0);
                gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);

                if (material.layer._pickingEnabled && !material.pickingReady) {
                    f.bindOutputTexture(pickingMask);
                    gl.uniform1f(shu.thicknessOutline._pName, 8);
                    gl.bindBuffer(gl.ARRAY_BUFFER, geomHandler._linePickingColorsBuffer);
                    gl.vertexAttribPointer(sha.color._pName, geomHandler._linePickingColorsBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    gl.drawElements(gl.TRIANGLE_STRIP, geomHandler._lineIndexesBuffer.numItems, gl.UNSIGNED_INT, 0);
                }

                material.applyTexture(texture, pickingMask);

            } else {
                material.isLoading = false;
            }

            deltaTime = window.performance.now() - startTime;
            prevLayerId = material.layer._id;
        }

        gl.disable(gl.BLEND);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        f.deactivate();
    }
};

VectorTileCreator.prototype.add = function (material) {
    this._queue.push(material);
};

VectorTileCreator.prototype.remove = function (material) {
    //...
};




/***/ }),

/***/ "./src/og/utils/colorTable.js":
/*!************************************!*\
  !*** ./src/og/utils/colorTable.js ***!
  \************************************/
/*! exports provided: colorTable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorTable", function() { return colorTable; });


const colorTable = {
    "aliceblue": "#f0f8ff", "antiquewhite": "#faebd7", "aqua": "#00ffff", "aquamarine": "#7fffd4", "azure": "#f0ffff",
    "beige": "#f5f5dc", "bisque": "#ffe4c4", "black": "#000000", "blanchedalmond": "#ffebcd", "blue": "#0000ff", "blueviolet": "#8a2be2", "brown": "#a52a2a", "burlywood": "#deb887",
    "cadetblue": "#5f9ea0", "chartreuse": "#7fff00", "chocolate": "#d2691e", "coral": "#ff7f50", "cornflowerblue": "#6495ed", "cornsilk": "#fff8dc", "crimson": "#dc143c", "cyan": "#00ffff",
    "darkblue": "#00008b", "darkcyan": "#008b8b", "darkgoldenrod": "#b8860b", "darkgray": "#a9a9a9", "darkgreen": "#006400", "darkkhaki": "#bdb76b", "darkmagenta": "#8b008b", "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00", "darkorchid": "#9932cc", "darkred": "#8b0000", "darksalmon": "#e9967a", "darkseagreen": "#8fbc8f", "darkslateblue": "#483d8b", "darkslategray": "#2f4f4f", "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3", "deeppink": "#ff1493", "deepskyblue": "#00bfff", "dimgray": "#696969", "dodgerblue": "#1e90ff",
    "firebrick": "#b22222", "floralwhite": "#fffaf0", "forestgreen": "#228b22", "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc", "ghostwhite": "#f8f8ff", "gold": "#ffd700", "goldenrod": "#daa520", "gray": "#808080", "green": "#008000", "greenyellow": "#adff2f",
    "honeydew": "#f0fff0", "hotpink": "#ff69b4",
    "indianred ": "#cd5c5c", "indigo": "#4b0082", "ivory": "#fffff0", "khaki": "#f0e68c",
    "lavender": "#e6e6fa", "lavenderblush": "#fff0f5", "lawngreen": "#7cfc00", "lemonchiffon": "#fffacd", "lightblue": "#add8e6", "lightcoral": "#f08080", "lightcyan": "#e0ffff", "lightgoldenrodyellow": "#fafad2",
    "lightgrey": "#d3d3d3", "lightgreen": "#90ee90", "lightpink": "#ffb6c1", "lightsalmon": "#ffa07a", "lightseagreen": "#20b2aa", "lightskyblue": "#87cefa", "lightslategray": "#778899", "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0", "lime": "#00ff00", "limegreen": "#32cd32", "linen": "#faf0e6",
    "magenta": "#ff00ff", "maroon": "#800000", "mediumaquamarine": "#66cdaa", "mediumblue": "#0000cd", "mediumorchid": "#ba55d3", "mediumpurple": "#9370d8", "mediumseagreen": "#3cb371", "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a", "mediumturquoise": "#48d1cc", "mediumvioletred": "#c71585", "midnightblue": "#191970", "mintcream": "#f5fffa", "mistyrose": "#ffe4e1", "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead", "navy": "#000080",
    "oldlace": "#fdf5e6", "olive": "#808000", "olivedrab": "#6b8e23", "orange": "#ffa500", "orangered": "#ff4500", "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa", "palegreen": "#98fb98", "paleturquoise": "#afeeee", "palevioletred": "#d87093", "papayawhip": "#ffefd5", "peachpuff": "#ffdab9", "peru": "#cd853f", "pink": "#ffc0cb", "plum": "#dda0dd", "powderblue": "#b0e0e6", "purple": "#800080",
    "rebeccapurple": "#663399", "red": "#ff0000", "rosybrown": "#bc8f8f", "royalblue": "#4169e1",
    "saddlebrown": "#8b4513", "salmon": "#fa8072", "sandybrown": "#f4a460", "seagreen": "#2e8b57", "seashell": "#fff5ee", "sienna": "#a0522d", "silver": "#c0c0c0", "skyblue": "#87ceeb", "slateblue": "#6a5acd", "slategray": "#708090", "snow": "#fffafa", "springgreen": "#00ff7f", "steelblue": "#4682b4",
    "tan": "#d2b48c", "teal": "#008080", "thistle": "#d8bfd8", "tomato": "#ff6347", "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3", "white": "#ffffff", "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00", "yellowgreen": "#9acd32"
}

/***/ }),

/***/ "./src/og/utils/earcut.js":
/*!********************************!*\
  !*** ./src/og/utils/earcut.js ***!
  \********************************/
/*! exports provided: earcut, flatten */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "earcut", function() { return earcut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/**
 * @module og/utils/earcut
 */

'use sctrict';


// ISC License
//
// Copyright (c) 2016, Mapbox
//
// Permission to use, copy, modify, and/or distribute this software for any purpose
// with or without fee is hereby granted, provided that the above copyright notice
// and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.
//
//https://github.com/mapbox/earcut
function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

                // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

                // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
        locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
        area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
            intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
function deviation(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
function flatten(data) {
    var dim = data[0][0].length,
        result = { vertices: [], holes: [], dimensions: dim },
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
}



/***/ }),

/***/ "./src/og/utils/shared.js":
/*!********************************!*\
  !*** ./src/og/utils/shared.js ***!
  \********************************/
/*! exports provided: stamp, isString, readTextFile, htmlColorToRgba, htmlColorToRgb, stringTemplate, print2d, defaultString, createVector3, createVector4, createColorRGBA, createColorRGB, createExtent, createLonLat, binarySearch, binaryInsert, getLinesIntersection2v, getLinesIntersectionLonLat, xmlToJson, castType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stamp", function() { return stamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readTextFile", function() { return readTextFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "htmlColorToRgba", function() { return htmlColorToRgba; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "htmlColorToRgb", function() { return htmlColorToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringTemplate", function() { return stringTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print2d", function() { return print2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultString", function() { return defaultString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVector3", function() { return createVector3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVector4", function() { return createVector4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createColorRGBA", function() { return createColorRGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createColorRGB", function() { return createColorRGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent", function() { return createExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLonLat", function() { return createLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binaryInsert", function() { return binaryInsert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLinesIntersection2v", function() { return getLinesIntersection2v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLinesIntersectionLonLat", function() { return getLinesIntersectionLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xmlToJson", function() { return xmlToJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castType", function() { return castType; });
/* harmony import */ var _ajax_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ajax.js */ "./src/og/ajax.js");
/* harmony import */ var _colorTable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorTable.js */ "./src/og/utils/colorTable.js");
/* harmony import */ var _Extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Extent.js */ "./src/og/Extent.js");
/* harmony import */ var _LonLat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../LonLat.js */ "./src/og/LonLat.js");
/* harmony import */ var _math_Vec2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vec2.js */ "./src/og/math/Vec2.js");
/* harmony import */ var _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vec3.js */ "./src/og/math/Vec3.js");
/* harmony import */ var _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Vec4.js */ "./src/og/math/Vec4.js");
/**
 * @module og/utils/shared
 */











let _stampCounter = 0;
function stamp(obj) {
    var stamp = obj._openglobus_id;
    if (!stamp) {
        stamp = obj._openglobus_id = ++_stampCounter;
    }
    return stamp;
};

function isString(s) {
    return typeof (s) === 'string' || s instanceof String;
};

/**
 * Synchronous text file loading. Returns file text.
 * @param {string} fileUrl - File name path.
 * @returns {string} -
 */
function readTextFile(fileUrl) {
    var res = "";

    _ajax_js__WEBPACK_IMPORTED_MODULE_0__["ajax"].request(fileUrl, {
        async: false,
        success: function (data) {
            res = data;
        }
    });

    return res;
};

/**
 * Convert html color string to the RGBA number vector.
 * @param {string} htmlColor - HTML string("#C6C6C6" or "#EF5" or "rgb(8,8,8)" or "rgba(8,8,8)") color.
 * @param {number} [opacity] - Opacity for the output vector.
 * @returns {og.math.Vec4} -
 */
function htmlColorToRgba(htmlColor, opacity) {
    var hColor = _colorTable_js__WEBPACK_IMPORTED_MODULE_1__["colorTable"][htmlColor];
    if (hColor) {
        htmlColor = hColor;
    }

    if (htmlColor[0] === "#") {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        var hex = htmlColor.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"](parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255, (opacity == undefined ? 1.0 : opacity));
    } else {
        if (opacity == undefined) {
            opacity = 1.0;
        }
        var m = htmlColor.split(",");
        return new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"](parseInt(m[0].split("(")[1]) / 255, parseInt(m[1]) / 255, parseInt(m[2]) / 255, (parseFloat(m[3]) != undefined ? parseFloat(m[3]) : opacity));
    }
};

/**
 * Convert html color string to the RGB number vector.
 * @param {string} htmlColor - HTML string("#C6C6C6" or "#EF5" or "rgb(8,8,8)" or "rgba(8,8,8)") color.
 * @param {number} [opacity] - Opacity for the output vector.
 * @returns {og.math.Vec3} -
 */
function htmlColorToRgb(htmlColor) {
    var hColor = _colorTable_js__WEBPACK_IMPORTED_MODULE_1__["colorTable"][htmlColor];
    if (hColor) {
        htmlColor = hColor;
    }

    if (htmlColor[0] == "#") {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        var hex = htmlColor.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"](parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255);
    } else {
        var m = htmlColor.split(",");
        return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"](parseInt(m[0].split("(")[1]) / 255, parseInt(m[1]) / 255, parseInt(m[2]) / 255);
    }
};

/**
 * Replace template substrings between '{' and '}' tokens.
 * @param {string} template - String with templates in "{" and "}"
 * @param {Object} params - Template named object with subsrtings.
 * @returns {string} -
 * 
 * @example <caption>Example from og.terrain that replaces tile indexes in url:</caption>
 * var substrings = {
 *       "x": 12,
 *       "y": 15,
 *       "z": 8
 * }
 * og.utils.stringTemplate("http://earth3.openglobus.org/{z}/{y}/{x}.ddm", substrins);
 * //returns http://earth3.openglobus.org/8/15/12.ddm
 */
function stringTemplate(template, params) {
    return template.replace(/{[^{}]+}/g, function (key) {
        return params[key.replace(/[{}]+/g, "")] || "";
    });
};

function print2d(id, text, x, y) {
    var el = document.getElementById(id);
    if (!el) {
        el = document.createElement("div");
        el.id = id;
        el.classList.add("defaultText");
        document.body.appendChild(el);
    }
    el.innerHTML = text;
    el.style.left = x;
    el.style.top = y;
};

function defaultString(str, def) {
    return str ? str.trim().toLowerCase() : def;
};

function createVector3(v, def) {
    if (v) {
        if (v instanceof _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"]) {
            return v.clone();
        } else if (v instanceof Array) {
            return _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"].fromVec(v);
        }
    } else if (def) {
        return def;
    }
    return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"]();
};

function createVector4(v, def) {
    if (v) {
        if (v instanceof _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"]) {
            return v.clone();
        } else if (v instanceof Array) {
            return _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"].fromVec(v);
        }
    } else if (def) {
        return def;
    }
    return new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"]();
};

function createColorRGBA(c, def) {
    if (c) {
        if (isString(c)) {
            return htmlColorToRgba(c);
        } else if (c instanceof Array) {
            return new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"].fromVec(c);
        } else if (c instanceof _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"]) {
            return c.clone();
        }
    } else if (def) {
        return def;
    }
    return new _math_Vec4_js__WEBPACK_IMPORTED_MODULE_6__["Vec4"](1.0, 1.0, 1.0, 1.0);
};

function createColorRGB(c, def) {
    if (c) {
        if (isString(c)) {
            return htmlColorToRgb(c);
        } else if (c instanceof Array) {
            return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"].fromVec(c);
        } else if (c instanceof _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"]) {
            return c.clone();
        }
    } else if (def) {
        return def;
    }
    return new _math_Vec3_js__WEBPACK_IMPORTED_MODULE_5__["Vec3"](1.0, 1.0, 1.0);
};

function createExtent(e, def) {
    if (e) {
        if (e instanceof Array) {
            return new _Extent_js__WEBPACK_IMPORTED_MODULE_2__["Extent"](
                createLonLat(e[0]),
                createLonLat(e[1]));
        } else if (e instanceof _Extent_js__WEBPACK_IMPORTED_MODULE_2__["Extent"]) {
            return e.clone();
        }
    } else if (def) {
        return def;
    }
    return new _Extent_js__WEBPACK_IMPORTED_MODULE_2__["Extent"]();
};

function createLonLat(l, def) {
    if (l) {
        if (l instanceof Array) {
            return new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](l[0], l[1], l[2]);
        } else if (l instanceof _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"]) {
            return l.clone();
        }
    } else if (def) {
        return def;
    }
    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"]();
};


/**
 * Finds an item in a sorted array.
 * @param {Array} ar The sorted array to search.
 * @param {Object} el The item to find in the array.
 * @param {og.utils.binarySearch~compare_fn} compare_fn comparator The function to use to compare the item to
 *        elements in the array.
 * @returns {Number} a negative number  if a is less than b; 0 if a is equal to b;a positive number of a is greater than b.
 *
 * @example
 * // Create a comparator function to search through an array of numbers.
 * function comparator(a, b) {
 *     return a - b;
 * };
 * var numbers = [0, 2, 4, 6, 8];
 * var index = og.utils.binarySearch(numbers, 6, comparator); // 3
 */
function binarySearch(ar, el, compare_fn) {
    var m = 0;
    var n = ar.length - 1;
    while (m <= n) {
        var k = (n + m) >> 1;
        var cmp = compare_fn(el, ar[k], k);
        if (cmp > 0) {
            m = k + 1;
        } else if (cmp < 0) {
            n = k - 1;
        } else {
            return k;
        }
    }
    return -m - 1;
};

/**
 * @todo NEEDS TESTING
 */
function binaryInsert(ar, el, compare_fn) {
    var i = binarySearch(ar, el, compare_fn);
    if (i < 0) {
        i = ~i;
    }
    ar.splice(i, 0, el);
    return i;
};

/**
 * Returns two segment lines intersection coordinate.
 * @static
 * @param {og.math.Vec2} start1 - First line first coordinate.
 * @param {og.math.Vec2} end1 - First line second coordinate.
 * @param {og.math.Vec2} start2 - Second line first coordinate.
 * @param {og.math.Vec2} end2 - Second line second coordinate.
 * @param {boolean} [isSegment] - Lines are segments.
 * @return {og.math.Vec2} - Intersection coordinate.
 */
function getLinesIntersection2v(start1, end1, start2, end2, isSegment) {
    var dir1 = end1.sub(start1);
    var dir2 = end2.sub(start2);

    var a1 = -dir1.y;
    var b1 = +dir1.x;
    var d1 = -(a1 * start1.x + b1 * start1.y);

    var a2 = -dir2.y;
    var b2 = +dir2.x;
    var d2 = -(a2 * start2.x + b2 * start2.y);

    var seg1_line2_start = a2 * start1.x + b2 * start1.y + d2;
    var seg1_line2_end = a2 * end1.x + b2 * end1.y + d2;

    var seg2_line1_start = a1 * start2.x + b1 * start2.y + d1;
    var seg2_line1_end = a1 * end2.x + b1 * end2.y + d1;

    if (isSegment && (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0))
        return null;

    var u = seg1_line2_start / (seg1_line2_start - seg1_line2_end);

    return new _math_Vec2_js__WEBPACK_IMPORTED_MODULE_4__["Vec2"](start1.x + u * dir1.x, start1.y + u * dir1.y);
};

/**
 * Returns two segment lines intersection coordinate.
 * @static
 * @param {og.math.Vec2} start1 - First line first coordinate.
 * @param {og.math.Vec2} end1 - First line second coordinate.
 * @param {og.math.Vec2} start2 - Second line first coordinate.
 * @param {og.math.Vec2} end2 - Second line second coordinate.
 * @param {boolean} [isSegment] - Lines are segments.
 * @return {og.math.Vec2} - Intersection coordinate.
 */
function getLinesIntersectionLonLat(start1, end1, start2, end2, isSegment) {
    var dir1 = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](end1.lon - start1.lon, end1.lat - start1.lat);
    var dir2 = new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](end2.lon - start2.lon, end2.lat - start2.lat);

    var a1 = -dir1.lat;
    var b1 = +dir1.lon;
    var d1 = -(a1 * start1.lon + b1 * start1.lat);

    var a2 = -dir2.lat;
    var b2 = +dir2.lon;
    var d2 = -(a2 * start2.lon + b2 * start2.lat);

    var seg1_line2_start = a2 * start1.lon + b2 * start1.lat + d2;
    var seg1_line2_end = a2 * end1.lon + b2 * end1.lat + d2;

    var seg2_line1_start = a1 * start2.lon + b1 * start2.lat + d1;
    var seg2_line1_end = a1 * end2.lon + b1 * end2.lat + d1;

    if (isSegment && (seg1_line2_start * seg1_line2_end > 0 || seg2_line1_start * seg2_line1_end > 0))
        return null;

    var u = seg1_line2_start / (seg1_line2_start - seg1_line2_end);

    return new _LonLat_js__WEBPACK_IMPORTED_MODULE_3__["LonLat"](start1.lon + u * dir1.lon, start1.lat + u * dir1.lat);
};

/**
 * Converts XML to JSON
 * @static
 * @param {Object} xml - Xml object
 * @return {Object} - Json converted object.
 */
function xmlToJson(xml) {

    // Create the return object
    var obj = {};

    if (xml.nodeType === 1) { // element
        // do attributes
        if (xml.attributes.length > 0) {
            obj["@attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
                var attribute = xml.attributes.item(j);
                obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    } else if (xml.nodeType === 3) { // text
        obj = xml.nodeValue;
    }

    // do children
    if (xml.hasChildNodes()) {
        for (var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName;
            if (typeof (obj[nodeName]) == "undefined") {
                obj[nodeName] = xmlToJson(item);
            } else {
                if (typeof (obj[nodeName].push) == "undefined") {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(xmlToJson(item));
            }
        }
    }
    return obj;
};

const castType = {
    "string": function (v) {
        return v != null ? v.toString() : v;
    },

    "date": function (v) {
        return v != null ? new Date(v * 1000) : v;
    },

    "datetime": function (v) {
        return v != null ? new Date(v * 1000) : v;
    },

    "time": function (v) {
        return v != null ? parseInt(v) : v;
    },

    "integer": function (v) {
        return v != null ? parseInt(v) : v;
    },

    "float": function (v) {
        return v != null ? parseFloat(v) : v;
    },

    "boolean": function (str) {
        if (str === null)
            return str;

        if (typeof str === 'boolean') {
            if (str === true)
                return true;
            return false;
        }
        if (typeof str === 'string') {
            if (str === "")
                return false;
            str = str.replace(/^\s+|\s+$/g, '');
            if (str.toLowerCase() === 'true' || str.toLowerCase() === 'yes')
                return true;
            str = str.replace(/,/g, '.');
            str = str.replace(/^\s*\-\s*/g, '-');
        }
        if (!isNaN(str))
            return parseFloat(str) !== 0;
        return false;
    }
};

/***/ }),

/***/ "./src/og/webgl/Framebuffer.js":
/*!*************************************!*\
  !*** ./src/og/webgl/Framebuffer.js ***!
  \*************************************/
/*! exports provided: Framebuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return Framebuffer; });
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageCanvas.js */ "./src/og/ImageCanvas.js");
/**
 * @module og/webgl/Framebuffer
 */





/**
 * Class represents framebuffer.
 * @class
 * @param {og.webgl.Handler} handler - WebGL handler.
 * @param {number} [width] - Framebuffer width. Default is handler canvas width.
 * @param {number} [height] - Framebuffer height. Default is handler canvas height.
 */
class Framebuffer {
    constructor(handler, options) {
        options = options || {};

        /**
         * WebGL handler.
         * @public
         * @type {og.webgl.Handler}
         */
        this.handler = handler;

        /**
         * Framebuffer object.
         * @private
         * @type {Object}
         */
        this._fbo = null;

        /**
         * Renderbuffer object.
         * @private
         * @type {Object}
         */
        this._rbo = null;

        /**
         * Framebuffer width.
         * @private
         * @type {number}
         */
        this._width = options.width || handler.canvas.width;

        /**
         * Framebuffer width.
         * @private
         * @type {number}
         */
        this._height = options.height || handler.canvas.height;

        this._useDepth = options.useDepth != undefined ? options.useDepth : true;

        /**
         * Framebuffer activity. 
         * @private
         * @type {boolean}
         */
        this._active = false;

        /**
         * Framebuffer texture.
         * @public
         * @type {number}
         */
        this.texture = options.texture || null;
    }

    destroy() {
        var gl = this.handler.gl;
        gl.deleteTexture(this.texture);
        gl.deleteFramebuffer(this._fbo);
        gl.deleteRenderbuffer(this._rbo);

        this.texture = null;
        this._rbo = null;
        this._fbo = null;

        this._active = false;
    }

    /**
     * Framebuffer initialization.
     * @private
     */
    init() {
        var gl = this.handler.gl;

        this._fbo = gl.createFramebuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        !this.texture && this.bindOutputTexture(this.handler.createEmptyTexture_l(this._width, this._height));

        if (this._useDepth) {
            this._rbo = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, this._rbo);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this._width, this._height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._rbo);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    /**
     * Bind buffer texture.
     * @public
     * @param{Object} texture - Output texture.
     */
    bindOutputTexture(texture) {
        var gl = this.handler.gl;
        this.texture = texture;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    /**
     * Sets framebuffer viewport size.
     * @public
     * @param {number} width - Framebuffer width.
     * @param {number} height - Framebuffer height.
     */
    setSize(width, height) {
        this._width = width;
        this._height = height;
        if (this._active) {
            this.handler.gl.viewport(0, 0, this._width, this._height);
        }
        if (this._useDepth) {
            this.destroy();
            this.init();
        }
    };

    /**
     * Returns framebuffer completed.
     * @public
     * @returns {boolean}
     */
    isComplete() {
        var gl = this.handler.gl;
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE)
            return true;
        return false;
    }

    /**
     * Reads all pixels(RGBA colors) from framebuffer.
     * @public
     * @returns {Array.<number>}
     */
    readAllPixels() {
        var gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        var pixelValues = new Uint8Array(4 * this._width * this._height);
        gl.readPixels(0, 0, this._width, this._height, gl.RGBA, gl.UNSIGNED_BYTE, pixelValues);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return pixelValues;
    }

    /**
     * Gets pixel RBGA color from framebuffer by coordinates.
     * @public
     * @param {number} x - Normalized x - coordinate.
     * @param {number} y - Normalized y - coordinate.
     * @returns {Array.<number,number,number,number>}
     */
    readPixel(nx, ny) {
        var gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        var pixelValues = new Uint8Array(4);
        gl.readPixels(nx * this._width, ny * this._height, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelValues);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return pixelValues;
    }

    /**
     * Activate framebuffer frame to draw.
     * @public
     * @returns {og.webgl.Framebuffer} Returns Current framebuffer.
     */
    activate() {
        var gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        gl.viewport(0, 0, this._width, this._height);
        this._active = true;
        var c = this.handler.framebufferStack.current().data;
        c && (c._active = false);
        this.handler.framebufferStack.push(this);
        return this;
    }

    /**
     * Deactivate framebuffer frame.
     * @public
     */
    deactivate() {
        var h = this.handler,
            gl = h.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._active = false;

        var f = this.handler.framebufferStack.popPrev();

        if (f) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, f._fbo);
            gl.viewport(0, 0, f._width, f._height);
        } else {
            gl.viewport(0, 0, h.canvas.width, h.canvas.height);
        }
    }

    /**
     * Gets JavaScript image object that framebuffer has drawn.
     * @public
     * @returns {Object}
     */
    getImage() {
        var data = this.readAllPixels();
        var imageCanvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__["ImageCanvas"](this._width, this._height);
        imageCanvas.setData(data);
        return imageCanvas.getImage();
    }

    /**
     * Open dialog window with framebuffer image.
     * @public
     */
    openImage() {
        var img = this.getImage();
        var dataUrl = img.src;
        var windowContent = '<!DOCTYPE html>';
        windowContent += '<html>'
        windowContent += '<head><title>Print</title></head>';
        windowContent += '<body>'
        windowContent += '<img src="' + dataUrl + '">';
        windowContent += '</body>';
        windowContent += '</html>';
        var printWin = window.open('', '', 'width=' + img.width + 'px ,height=' + img.height + 'px');
        printWin.document.open();
        printWin.document.write(windowContent);
        printWin.document.close();
        printWin.focus();
    }
};



/***/ }),

/***/ "./src/og/webgl/Handler.js":
/*!*********************************!*\
  !*** ./src/og/webgl/Handler.js ***!
  \*********************************/
/*! exports provided: Handler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Handler", function() { return Handler; });
/* harmony import */ var _cons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cons.js */ "./src/og/cons.js");
/* harmony import */ var _Clock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Clock.js */ "./src/og/Clock.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageCanvas.js */ "./src/og/ImageCanvas.js");
/* harmony import */ var _ShaderController_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShaderController.js */ "./src/og/webgl/ShaderController.js");
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Stack.js */ "./src/og/Stack.js");
/* harmony import */ var _math_Vec2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vec2.js */ "./src/og/math/Vec2.js");
/**
 * @module og/webgl/Handler
 */










/**
 * Maximum texture image size.
 * @const
 * @type {number}
 */
const MAX_SIZE = 4096;

const vendorPrefixes = ["", "WEBKIT_", "MOZ_"];

/**
 * A WebGL handler for accessing low-level WebGL capabilities.
 * @class
 * @param {string} id - Canvas element id that WebGL handler assing with. If it's null
 * or undefined creates hidden canvas and handler bacomes hidden.
 * @param {Object} [params] - Handler options:
 * @param {number} [params.anisotropy] - Anisitropy filter degree. 8 is default.
 * @param {number} [params.width] - Hidden handler width. 256 is default.
 * @param {number} [params.height] - Hidden handler height. 256 is default.
 * @param {Object} [param.scontext] - Native WebGL context attributes. See https://www.khronos.org/registry/webgl/specs/latest/1.0/#WEBGLCONTEXTATTRIBUTES
 * @param {Array.<string>} [params.extensions] - Additional WebGL extension list. Available by default: OES_standard_derivatives, EXT_texture_filter_anisotropic.
 */
class Handler {
    constructor(id, params) {

        /**
         * Application default timer.
         * @public
         * @type {og.Clock}
         */
        this.defaultClock = new _Clock_js__WEBPACK_IMPORTED_MODULE_1__["Clock"]();

        /**
         * Custom timers.
         * @protected
         * @type{og.Clock[]}
         */
        this._clocks = [];

        /**
         * Draw frame time in milliseconds.
         * @public
         * @readonly
         * @type {number}
         */
        this.deltaTime = 0;

        /**
         * WebGL rendering canvas element.
         * @public
         * @type {Object}
         */
        this.canvas = null;

        /**
         * WebGL context.
         * @public
         * @type {Object}
         */
        this.gl = null;

        /**
         * Shader program controller list.
         * @public
         * @type {Object.<og.webgl.ShaderController>}
         */
        this.shaderPrograms = {};

        /**
         * Current active shader program controller.
         * @public
         * @type {og.webgl.ShaderController}
         */
        this.activeShaderProgram = null;

        /**
         * Handler parameters.
         * @private
         * @type {Object}
         */
        this._params = params || {};
        this._params.anisotropy = this._params.anisotropy || 8;
        var w = this._params.width;
        if (w > MAX_SIZE) {
            w = MAX_SIZE;
        }
        this._params.width = w || 256;

        var h = this._params.height;
        if (h > MAX_SIZE) {
            h = MAX_SIZE;
        }
        this._params.height = h || 256;
        this._params.context = this._params.context || {};
        this._params.extensions = this._params.extensions || [];
        this._oneByHeight = 1 / this._params.height;

        /**
         * Current WebGL extensions. Becomes here after context initialization.
         * @public
         * @type {Object}
         */
        this.extensions = {};

        /**
         * HTML Canvas object id.
         * @private
         * @type {Object}
         */
        this._id = id;

        this._lastAnimationFrameTime = 0;

        this._initialized = false;

        /**
         * Animation frame function assigned from outside(Ex. from Renderer).
         * @private
         * @type {frameCallback}
         */
        this._frameCallback = function () { };

        this.transparentTexture = null;

        this.framebufferStack = new _Stack_js__WEBPACK_IMPORTED_MODULE_4__["Stack"]();

        if (params.autoActivate) {
            this.initialize();
        }
    }

    /**
     * The return value is null if the extension is not supported, or an extension object otherwise.
     * @param {Object} gl - WebGl context pointer.
     * @param {String} name - Extension name.
     * @returns {Object}
     */
    static getExtension(gl, name) {
        var i, ext;
        for (i in vendorPrefixes) {
            ext = gl.getExtension(vendorPrefixes[i] + name);
            if (ext) {
                return ext;
            }
        }
        return null;
    }

    /**
     * Returns a drawing context on the canvas, or null if the context identifier is not supported.
     * @param {Object} canvas - HTML canvas object.
     * @params {Object} [contextAttributes] - See canvas.getContext contextAttributes.
     * @returns {Object}
     */
    static getContext(canvas, contextAttributes) {
        var ctx;
        try {
            ctx = canvas.getContext("webgl", contextAttributes) ||
                canvas.getContext("experimental-webgl", contextAttributes);
            //ctx.canvas = canvas;
        }
        catch (ex) {
            _cons_js__WEBPACK_IMPORTED_MODULE_0__["cons"].logErr("exception during the GL context initialization");
        }
        if (!ctx) {
            _cons_js__WEBPACK_IMPORTED_MODULE_0__["cons"].logErr("could not initialise WebGL");
        }
        return ctx;
    }

    /**
     * Sets animation frame function.
     * @public
     * @param {callback} - Frame callback.
     */
    setFrameCallback(callback) {
        callback && (this._frameCallback = callback);
    }

    /**
     * Creates NEAREST filter texture.
     * @public
     * @param {Object} image - Image or Canvas object.
     * @returns {Object} - WebGL texture object.
     */
    createTexture_n(image) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates Empty half float texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @returns {Object} - WebGL half float texture object.
     */
    createEmptyTexture_hf(width, height) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.HALF_FLOAT_OES, null);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates Empty float texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @returns {Object} - WebGL float texture object.
     */
    createEmptyTexture_f(width, height) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates Empty NEAREST filtered texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @returns {Object} - WebGL texture object.
     */
    createEmptyTexture_n(width, height) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates empty LINEAR filtered texture.
     * @public
     * @param {number} width - Empty texture width.
     * @param {number} height - Empty texture height.
     * @returns {Object} - WebGL texture object.
     */
    createEmptyTexture_l(width, height) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates LINEAR filter texture.
     * @public
     * @param {Object} image - Image or Canvas object.
     * @returns {Object} - WebGL texture object.
     */
    createTexture_l(image) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates MIPMAP filter texture.
     * @public
     * @param {Object} image - Image or Canvas object.
     * @returns {Object} - WebGL texture object.
     */
    createTexture_mm(image) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates ANISOTROPY filter texture.
     * @public
     * @param {Object} image - Image or Canvas object.
     * @returns {Object} - WebGL texture object.
     */
    createTexture_a(image) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameterf(gl.TEXTURE_2D, this.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._params.anisotropy);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }

    /**
     * Creates DEFAULT filter texture, ANISOTROPY is default.
     * @public
     * @param {Object} image - Image or Canvas object.
     * @returns {Object} - WebGL texture object.
     */
    createTexture(image) {
        return this.createTexture_a(image)
    }

    /**
     * Creates cube texture.
     * @public
     * @param {Object.<string>} params - Face image urls:
     * @param {string} params.px - Positive X or right image url.
     * @param {string} params.nx - Negative X or left image url.
     * @param {string} params.py - Positive Y or up image url.
     * @param {string} params.ny - Negative Y or bottom image url.
     * @param {string} params.pz - Positive Z or face image url.
     * @param {string} params.nz - Negative Z or back image url.
     * @returns {Object} - WebGL texture object.
     */
    loadCubeMapTexture(params) {
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        var faces = [[params.px, gl.TEXTURE_CUBE_MAP_POSITIVE_X],
        [params.nx, gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
        [params.py, gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
        [params.ny, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
        [params.pz, gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
        [params.nz, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]];

        var imageCanvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_2__["ImageCanvas"]();
        imageCanvas.fillEmpty();
        var emptyImage = imageCanvas.getImage();

        for (var i = 0; i < faces.length; i++) {
            var face = faces[i][1];
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, emptyImage);
        }

        for (var i = 0; i < faces.length; i++) {
            var face = faces[i][1];
            var image = new Image();
            image.crossOrigin = '';
            image.onload = function (texture, face, image) {
                return function () {
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                    gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                }
            }(texture, face, image);
            image.src = faces[i][0];
        }
        return texture;
    }

    /**
     * Adds shader program to the handler.
     * @public
     * @param {og.shaderProgram.ShaderProgram} program - Shader program.
     * @param {boolean} [notActivate] - If it's true program will not compile.
     */
    addShaderProgram(program, notActivate) {
        if (!this.shaderPrograms[program.name]) {
            var sc = new _ShaderController_js__WEBPACK_IMPORTED_MODULE_3__["ShaderController"](this, program);
            this.shaderPrograms[program.name] = sc;
            this._initShaderController(sc);
            if (notActivate)
                sc._activated = false;
        } else {
            !COMPILED && _cons_js__WEBPACK_IMPORTED_MODULE_0__["cons"].logWrn("og.webgl.Handler:284 - shader program: '" + program.name + "' is allready exists.");
        }
        return program;
    }

    /**
     * Removes shader program from handler.
     * @public
     * @param {String} program - Shader program name.
     */
    removeShaderProgram(name) {
        this.shaderPrograms[name] && this.shaderPrograms[name].remove();
    };

    /**
     * Adds shader programs to the handler.
     * @public
     * @param {Array.<og.shaderProgram.ShaderProgram>} programsArr - Shader program array.
     */
    addShaderPrograms(programsArr) {
        for (var i = 0; i < programsArr.length; i++) {
            this.addShaderProgram(programsArr[i]);
        }
    }

    /**
     * Used in addShaderProgram
     * @private
     * @param {og.webgl.ShaderController}
     */
    _initShaderController(sc) {
        if (this._initialized) {
            sc.initialize();
            if (!this.activeShaderProgram) {
                this.activeShaderProgram = sc;
                sc.activate();
            } else {
                sc.deactivate();
                this.activeShaderProgram._program.enableAttribArrays();
                this.activeShaderProgram._program.use();
            }
        }
    }

    /**
     * Used in init function.
     * @private
     */
    _initShaderPrograms() {
        for (var p in this.shaderPrograms) {
            this._initShaderController(this.shaderPrograms[p]);
        }
    }

    /**
     * Initialize additional WebGL extensions.
     * @public
     * @param {string} extensionStr - Extension name.
     */
    initializeExtension(extensionStr, showLog) {
        if (!(this.extensions && this.extensions[extensionStr])) {
            var ext = Handler.getExtension(this.gl, extensionStr);
            if (ext) {
                this.extensions[extensionStr] = ext;
            } else if (showLog) {
                !COMPILED && _cons_js__WEBPACK_IMPORTED_MODULE_0__["cons"].logWrn("og.webgl.Handler: extension '" + extensionStr + "' doesn't initialize.");
            }
        }
        return this.extensions && this.extensions[extensionStr];
    }

    /**
     * Main function that initialize handler.
     * @public
     */
    initialize() {

        if (this._id) {
            this.canvas = document.getElementById(this._id);
        } else {
            this.canvas = document.createElement("canvas");
            this.canvas.width = this._params.width;
            this.canvas.height = this._params.height;
        }

        this.gl = Handler.getContext(this.canvas, this._params.context);
        this._initialized = true;

        /** Sets deafult extensions */
        this._params.extensions.push("OES_standard_derivatives");
        this._params.extensions.push("EXT_texture_filter_anisotropic");
        this._params.extensions.push("OES_element_index_uint");

        //this._params.extensions.push('OES_texture_half_float');
        //this._params.extensions.push('OES_texture_half_float_linear');

        //this._params.extensions.push('OES_texture_float');
        //this._params.extensions.push('OES_texture_float_linear');

        var i = this._params.extensions.length;
        while (i--) {
            this.initializeExtension(this._params.extensions[i], true);
        }

        if (!this.extensions.EXT_texture_filter_anisotropic)
            this.createTexture = this.createTexture_mm;

        /** Initilalize shaders and rendering parameters*/
        this._initShaderPrograms();
        this._setDefaults();
    }

    /**
     * Sets default gl render parameters. Used in init function.
     * @private
     */
    _setDefaults() {
        this.activateDepthTest();
        this.setSize(this._params.width, this._params.height);
        this.gl.frontFace(this.gl.CCW);
        this.gl.cullFace(this.gl.BACK);
        this.activateFaceCulling();
        this.deactivateBlending();
        var that = this;
        this.createDefaultTexture({ color: "rgba(0,0,0,0.0)" }, function (t) {
            that.transparentTexture = t;
        });
    };

    /**
     * Activate depth test.
     * @public
     */
    activateDepthTest() {
        this.gl.enable(this.gl.DEPTH_TEST);
    }

    /**
     * Deactivate depth test.
     * @public
     */
    deactivateDepthTest() {
        this.gl.disable(this.gl.DEPTH_TEST);
    }

    /**
     * Activate face culling.
     * @public
     */
    activateFaceCulling() {
        this.gl.enable(this.gl.CULL_FACE);
    }

    /**
     * Deactivate face cullting.
     * @public
     */
    deactivateFaceCulling() {
        this.gl.disable(this.gl.CULL_FACE);
    }

    /**
     * Activate blending.
     * @public
     */
    activateBlending() {
        this.gl.enable(this.gl.BLEND);
    }

    /**
     * Deactivate blending.
     * @public
     */
    deactivateBlending() {
        this.gl.disable(this.gl.BLEND);
    }

    /**
     * Creates ARRAY buffer.
     * @public
     * @param {Array.<number>} array - Input array.
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {Object}
     */
    createArrayBuffer(array, itemSize, numItems, usage) {
        var buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, array, usage || this.gl.STATIC_DRAW);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        buffer.itemSize = itemSize;
        buffer.numItems = numItems;
        return buffer;
    }

    /**
     * Creates ELEMENT ARRAY buffer.
     * @public
     * @param {Array.<number>} array - Input array.
     * @param {number} itemSize - Array item size.
     * @param {number} numItems - Items quantity.
     * @param {number} [usage=STATIC_DRAW] - Parameter of the bufferData call can be one of STATIC_DRAW, DYNAMIC_DRAW, or STREAM_DRAW.
     * @return {Object}
     */
    createElementArrayBuffer(array, itemSize, numItems, usage) {
        var buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, array, usage || this.gl.STATIC_DRAW);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
        buffer.itemSize = itemSize;
        buffer.numItems = numItems || array.length;
        return buffer;
    }

    /**
     * Sets handler canvas size.
     * @public
     * @param {number} width - Canvas width.
     * @param {number} height - Canvas height.
     */
    setSize(w, h) {

        if (w > MAX_SIZE) {
            w = MAX_SIZE;
        }

        if (h > MAX_SIZE) {
            h = MAX_SIZE;
        }

        this._params.width = w;
        this._params.height = h;
        this.canvas.width = w;
        this.canvas.height = h;
        this._oneByHeight = 1 / h;

        this.gl && this.gl.viewport(0, 0, w, h);
        this.onCanvasResize && this.onCanvasResize(this.canvas);
    };

    /**
     * Returns context screen width.
     * @public
     * @returns {number}
     */
    getWidth() {
        return this.canvas.width;
    };

    /**
     * Returns context screen height.
     * @public
     * @returns {number}
     */
    getHeight() {
        return this.canvas.height;
    }

    /**
     * Returns canvas aspect ratio.
     * @public
     * @returns {number}
     */
    getClientAspect() {
        return this.canvas.clientWidth / this.canvas.clientHeight;
    }

    /**
     * Returns screen center coordinates.
     * @public
     * @returns {number}
     */
    getCenter() {
        var c = this.canvas;
        return new _math_Vec2_js__WEBPACK_IMPORTED_MODULE_5__["Vec2"](Math.round(c.width * 0.5), Math.round(c.height * 0.5));
    }

    /**
     * Draw single frame.
     * @public
     * @param {number} now - Frame current time milliseconds.
     */
    drawFrame() {

        /** Calculate frame time */
        var now = new Date().getTime();
        this.deltaTime = now - this._lastAnimationFrameTime;
        this._lastAnimationFrameTime = now;

        this.defaultClock._tick(this.deltaTime);

        for (var i = 0; i < this._clocks.length; i++) {
            this._clocks[i]._tick(this.deltaTime);
        }

        /** Canvas resize checking */
        var canvas = this.canvas;
        if (canvas.clientWidth !== canvas.width ||
            canvas.clientHeight !== canvas.height) {
            this.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        /** Draw frame */
        this._frameCallback();
    }

    /**
     * Clearing gl frame.
     * @public
     */
    clearFrame() {
        var gl = this.gl;
        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }

    /**
     * Starts animation loop.
     * @public
     */
    start() {
        if (!this._requestAnimationFrameId && this._initialized) {
            var d = new Date();
            this._lastAnimationFrameTime = d.getTime();
            this.defaultClock.setDate(d);
            this._animationFrameCallback();
        }
    };

    stop() {
        if (this._requestAnimationFrameId) {
            window.cancelAnimationFrame(this._requestAnimationFrameId);
            this._requestAnimationFrameId = null;
        }
    };

    /**
     * Make animation.
     * @private
     */
    _animationFrameCallback() {
        this._requestAnimationFrameId = window.requestAnimationFrame(() => {
            this.drawFrame();
            this._animationFrameCallback();
        });
    }

    /**
     * @public
     * @param
     */
    createDefaultTexture(params, success) {
        var imgCnv;
        var texture;
        if (params && params.color) {
            imgCnv = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_2__["ImageCanvas"](2, 2);
            imgCnv.fillColor(params.color);
            texture = this.createTexture_n(imgCnv._canvas);
            texture.default = true;
            success(texture);
        } else if (params && params.url) {
            var img = new Image();
            var that = this;
            img.onload = function () {
                texture = that.createTexture(this);
                texture.default = true;
                success(texture);
            };
            img.src = params.url;
        } else {
            imgCnv = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_2__["ImageCanvas"](2, 2);
            imgCnv.fillColor("#C5C5C5");
            texture = this.createTexture_n(imgCnv._canvas);
            texture.default = true;
            success(texture);
        }
    }

    /**
     * @public
     */
    destroy() {

        var gl = this.gl;

        this.stop();

        for (var p in this.shaderPrograms) {
            this.removeShaderProgram(p);
        }

        gl.deleteTexture(this.transparentTexture);
        this.transparentTexture = null;

        this.framebufferStack = null;
        this.framebufferStack = new _Stack_js__WEBPACK_IMPORTED_MODULE_4__["Stack"]();

        if (this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        this.canvas.width = 1;
        this.canvas.height = 1;
        this.canvas = null;

        var numAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var tmp = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tmp);
        for (var ii = 0; ii < numAttribs; ++ii) {
            gl.disableVertexAttribArray(ii);
            gl.vertexAttribPointer(ii, 4, gl.FLOAT, false, 0, 0);
            gl.vertexAttrib1f(ii, 0);
        }
        gl.deleteBuffer(tmp);

        var numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        for (var ii = 0; ii < numTextureUnits; ++ii) {
            gl.activeTexture(gl.TEXTURE0 + ii);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        gl.activeTexture(gl.TEXTURE0);
        gl.useProgram(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.disable(gl.BLEND);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.DITHER);
        gl.disable(gl.SCISSOR_TEST);
        gl.blendColor(0, 0, 0, 0);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ZERO);
        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(-1);

        this.gl = null;

        this._initialized = false;
    }

    addClock(clock) {
        if (!clock.__handler) {
            clock.__handler = this;
            this._clocks.push(clock);
        }
    }

    addClocks(clockArr) {
        for (var i = 0; i < clockArr.length; i++) {
            this.addClock(clockArr[i]);
        }
    }

    removeClock(clock) {
        if (clock.__handler) {
            var c = this._clocks;
            var i = c.length;
            while (i--) {
                if (c[i].equal(clock)) {
                    clock.__handler = null;
                    c.splice(i, 1);
                    break;
                }
            }
        }
    }
};





/***/ }),

/***/ "./src/og/webgl/MultiFramebuffer.js":
/*!******************************************!*\
  !*** ./src/og/webgl/MultiFramebuffer.js ***!
  \******************************************/
/*! exports provided: MultiFramebuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiFramebuffer", function() { return MultiFramebuffer; });
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageCanvas.js */ "./src/og/ImageCanvas.js");
/**
 * @module og/webgl/Framebuffer
 */





/**
 * Class represents multiple render framebuffer.
 * @class
 * @param {og.webgl.Handler} handler - WebGL handler.
 */
class MultiFramebuffer {
    constructor(handler, options) {

        options = options || {};

        /**
         * WebGL handler.
         * @public
         * @type {og.webgl.Handler}
         */
        this.handler = handler;

        /**
         * Framebuffer object.
         * @private
         * @type {Object}
         */
        this._fbo = null;

        /**
         * Picking color framebuffers.
         * @private
         * @type {Object}
         */
        this._pFbo = [];

        /**
         * Render buffer object.
         * @private
         */
        this._rbo = null;

        this._size = options.size || 1;

        /**
         * Framebuffer width.
         * @private
         * @type {number}
         */
        this._width = options.width || 256;

        /**
         * Framebuffer width.
         * @private
         * @type {number}
         */
        this._height = options.height || 256;

        /**
         * Buffer textures.
         * @public
         */
        this.textures = [];

        /**
         * Framebuffer activity. 
         * @private
         * @type {boolean}
         */
        this._active = false;
    }

    /**
     * Destroy framebuffer instance.
     * @public
     */
    destroy() {
        var gl = this.handler.gl;
        gl.deleteFramebuffer(this._fbo);
        this._fbo = null;
        gl.deleteRenderbuffer(this._rbo);
        this._rbo = null;
        for (var i = 0; i < this._size; i++) {
            gl.deleteTexture(this.textures[i]);
            gl.deleteFramebuffer(this._pFbo[i]);
        }
        this.textures.length = 0;
        this.textures = [];
        this._pFbo.length = 0;
        this._pFbo = [];
    }

    /**
     * Framebuffer initialization.
     * @virtual
     */
    init() {
        var gl = this.handler.gl;
        var ext = this.handler.extensions.WEBGL_draw_buffers;

        this._fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);

        var fragDataArr = [];
        for (var i = 0; i < this._size; i++) {
            fragDataArr[i] = ext.COLOR_ATTACHMENT0_WEBGL + i;
        }
        ext.drawBuffersWEBGL(fragDataArr);

        for (var i = 0; i < this._size; i++) {
            this.textures[i] = this.handler.createEmptyTexture_l(this._width, this._height);
            gl.bindTexture(gl.TEXTURE_2D, this.textures[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, this.textures[i], 0);
            gl.bindTexture(gl.TEXTURE_2D, null);
            fragDataArr[i] = ext.COLOR_ATTACHMENT0_WEBGL + i;
        }

        this._rbo = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._rbo);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._rbo);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        for (var i = 0; i < this._size; i++) {
            this._pFbo[i] = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._pFbo[i]);
            gl.bindTexture(gl.TEXTURE_2D, this.textures[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.textures[i], 0);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    /**
     * Sets framebuffer size. Must be before the activate method.
     * @public
     * @param {number} width - Framebuffer width.
     * @param {number} height - Framebuffer height.
     */
    setSize(width, height) {
        this._width = width;
        this._height = height;
        this.destroy();
        this.init();
    }

    /**
     * Reads all pixels(RGBA colors) from framebuffer.
     * @public
     * @returns {Array.<number>}
     */
    readAllPixels(index) {
        var gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._pFbo[index || 0]);
        var pixelValues = new Uint8Array(4 * this._width * this._height);
        gl.readPixels(0, 0, this._width, this._height, gl.RGBA, gl.UNSIGNED_BYTE, pixelValues);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return pixelValues;
    }

    /**
     * Gets pixel RBGA color from framebuffer by coordinates.
     * @public
     * @param {number} x - Normalized x - coordinate.
     * @param {number} y - Normalized y - coordinate.
     * @returns {Array.<number,number,number,number>}
     */
    readPixel(nx, ny, index) {
        var gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._pFbo[index || 0]);
        var pixelValues = new Uint8Array(4);
        gl.readPixels(nx * this._width, ny * this._height, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelValues);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return pixelValues;
    }

    /**
     * Returns framebuffer completed.
     * @public
     * @returns {boolean}
     */
    isComplete() {
        var gl = this.handler.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return true;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return false;
    }

    /**
     * Activate framebuffer frame to draw.
     * @public
     * @returns {og.webgl.MultiFramebuffer} Returns current framebuffer.
     */
    activate() {
        var h = this.handler,
            gl = h.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
        gl.viewport(0, 0, this._width, this._height);
        this._active = true;
        var c = this.handler.framebufferStack.current().data;
        c && (c._active = false);
        h.framebufferStack.push(this);
        return this;
    }

    /**
     * Deactivate framebuffer frame.
     * @public
     */
    deactivate() {
        var h = this.handler,
            gl = h.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, h.canvas.width, h.canvas.height);
        this._active = false;

        var f = h.framebufferStack.popPrev();
        if (f) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, f._fbo);
            gl.viewport(0, 0, f._width, f._height);
        } else {
            gl.viewport(0, 0, h.canvas.width, h.canvas.height);
        }
    }

    /**
     * Gets JavaScript image object that framebuffer has drawn.
     * @public
     * @returns {Object}
     */
    getImage(index) {
        var data = this.readAllPixels(index);
        var imageCanvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__["ImageCanvas"](this._width, this._height);
        imageCanvas.setData(data);
        return imageCanvas.getImage();
    }

    /**
     * Open dialog window with framebuffer image.
     * @public
     */
    openImage(index) {
        var img = this.getImage(index);
        var dataUrl = img.src;
        var windowContent = '<!DOCTYPE html>';
        windowContent += '<html>'
        windowContent += '<head><title>Print</title></head>';
        windowContent += '<body>'
        windowContent += '<img src="' + dataUrl + '">';
        windowContent += '</body>';
        windowContent += '</html>';
        var printWin = window.open('', '', 'width=' + img.width + 'px ,height=' + img.height + 'px');
        printWin.document.open();
        printWin.document.write(windowContent);
        printWin.document.close();
        printWin.focus();
    }
};



/***/ }),

/***/ "./src/og/webgl/ShaderController.js":
/*!******************************************!*\
  !*** ./src/og/webgl/ShaderController.js ***!
  \******************************************/
/*! exports provided: ShaderController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderController", function() { return ShaderController; });
/**
 * @module og/webgl/ShaderController
 */



/**
 * This is shader program controller that used by hadler object to access the shader 
 * program capabilities, like switching program during the rendering.
 * Get access to the program from ...handler.shaderPrograms.<program name> etc.
 * @class
 * @param {og.webgl.Handler} handler - Handler.
 * @param {og.shaderProgram.ShaderProgram} shaderProgram - Shader program.
 */
class ShaderController {
    constructor(handler, shaderProgram) {

        /**
         * Shader program.
         * @private
         * @type {og.shaderProgram.ShaderProgram}
         */
        this._program = shaderProgram;

        /**
         * Handler.
         * @private
         * @type {og.webgl.Handler}
         */
        this._handler = handler;

        /**
         * Program current frame activation flag.
         * @private
         * @type {boolean}
         */
        this._activated = false;
    }

    /**
     * Lazy create program call.
     * @public
     */
    initialize() {
        this._program.createProgram(this._handler.gl);
    }

    /**
     * Returns controller's shader program.
     * @public
     * @return {og.shaderProgram.ShaderProgram}
     */
    getProgram() {
        return this._program;
    }

    /**
     * Activates current shader program.
     * @public
     */
    activate() {
        if (!this._activated) {
            this._handler.activeShaderProgram.deactivate();
            this._handler.activeShaderProgram = this;
            var p = this._program;
            this._activated = true;
            p.enableAttribArrays();
            p.use();
        }
        return this;
    }

    /**
     * Remove program from handler
     * @public
     */
    remove() {
        var p = this._handler.shaderPrograms;
        if (p[this._program.name]) {
            if (this._activated) {
                this.deactivate();
            }
            this._program.delete();
            p[this._program.name] = null;
            delete p[this._program.name];
        }
    }

    /**
     * Deactivate shader program. This is not necessary while activae function used.
     * @public
     */
    deactivate() {
        this._program.disableAttribArrays();
        this._activated = false;
    }

    /**
     * Returns program activity.
     * @public
     * @return {boolean}
     */
    isActive() {
        return this._activated;
    }

    /**
     * Sets program uniforms and attributes values and return controller instance.
     * @public
     * @param {Object} - Object with variable name and value like { value: 12, someArray:[1,2,3], uSampler: texture,... }
     * @return {og.webgl.ShaderController}
     */
    set(params) {
        this.activate();
        this._program.set(params);
        return this;
    }

    /**
     * Draw index buffer with this program.
     * @public
     * @param {number} mode - Gl draw mode
     * @param {}
     * @return {og.webgl.ShaderController} Returns current shader controller instance.
     */
    drawIndexBuffer(mode, buffer) {
        this._program.drawIndexBuffer(mode, buffer);
        return this;
    }

    /**
     * Calls Gl drawArray function.
     * @param {number} - Gl draw mode.
     * @param {number} - draw items count.
     * @return {og.webgl.ShaderController} Returns current shader controller instance.
     */
    drawArray(mode, numItems) {
        this._program.drawArray(mode, numItems);
        return this;
    }
};



/***/ }),

/***/ "./src/og/webgl/ShaderProgram.js":
/*!***************************************!*\
  !*** ./src/og/webgl/ShaderProgram.js ***!
  \***************************************/
/*! exports provided: ShaderProgram */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderProgram", function() { return ShaderProgram; });
/* harmony import */ var _callbacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./callbacks.js */ "./src/og/webgl/callbacks.js");
/* harmony import */ var _cons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cons.js */ "./src/og/cons.js");
/**
 * @module og/webgl/ShaderProgram
 */






/**
 * Represents more comfortable using WebGL shader program.
 * @class
 * @param {string} name - Shader program name identificator.
 * @param {object} material - Object stores uniforms, attributes and program codes:
 * @param {object} material.uniforms - Uniforms definition section.
 * @param {object} material.attributes - Attributes definition section.
 * @param {string} material.vertexShader - Vertex glsl code.
 * @param {string} material.fragmentShader - Fragment glsl code.
 */
class ShaderProgram {
    constructor(name, material) {
        /**
         * Shader progarm name.
         * @public
         * @type {string}
         */
        this.name = name;

        /**
         * Attributes.
         * @public
         * @type {Object}
         */
        this.attributes = material.attributes;

        /**
         * Uniforms.
         * @public
         * @type {Object}
         */
        this.uniforms = material.uniforms;

        /**
         * Vertex shader.
         * @public
         * @type {string}
         */
        this.vertexShader = material.vertexShader;

        /**
         * Fragment shader.
         * @public
         * @type {string}
         */
        this.fragmentShader = material.fragmentShader;

        /**
         * Webgl context.
         * @public
         * @type {Object}
         */
        this.gl = null;

        /**
         * All program variables.
         * @private
         * @type {Object}
         */
        this._variables = {};

        /**
         * Program pointer.
         * @private
         * @type {Object}
         */
        this._p = null;

        /**
         * Texture counter.
         * @prvate
         * @type {number}
         */
        this._textureID = 0;

        /**
         * Program attributes array.
         * @private
         * @type {Array.<Object>}
         */
        this._attribArrays = [];
    }

    /**
     * Sets the current program frame.
     * @public
     */
    use() {
        this.gl.useProgram(this._p);
    }

    /**
     * Sets program variables.
     * @public
     * @param {Object} material - Variables and values object.
     */
    set(material) {
        this._textureID = 0;
        for (var i in material) {
            this._variables[i].value = material[i];
            this._variables[i]._callback(this, this._variables[i]);
        }
    }

    /**
     * Apply current variables.
     * @public
     */
    apply() {
        this._textureID = 0;
        var v = this._variables;
        for (var i in v) {
            v[i]._callback(this, v[i]);
        }
    }

    /**
     * Calls drawElements index buffer function.
     * @public
     * @param {number} mode - Draw mode(GL_TRIANGLES, GL_LINESTRING etc.).
     * @param {Object} buffer - Index buffer.
     */
    drawIndexBuffer(mode, buffer) {
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
        this.gl.drawElements(mode, buffer.numItems, this.gl.UNSIGNED_SHORT, 0);
    }

    /**
     * Calls drawArrays function.
     * @public
     * @param {number} mode - Draw mode(GL_TRIANGLES, GL_LINESTRING etc.).
     * @param {number} numItems - Curent binded buffer drawing items count.
     */
    drawArray(mode, numItems) {
        this.gl.drawArrays(mode, 0, numItems);
    }

    /**
     * Check and log for an shader compile errors and warnings. Returns True - if no errors otherwise returns False.
     * @private
     * @param {Object} shader - WebGl shader program.
     * @param {string} src - Shader program source.
     * @returns {boolean}
     */
    _getShaderCompileStatus(shader, src) {
        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            _cons_js__WEBPACK_IMPORTED_MODULE_1__["cons"].logErr("og/shaderProgram/ShaderProgram:" + this.name + " - " + this.gl.getShaderInfoLog(shader) + ".");
            return false;
        }
        return true;
    }

    /**
     * Returns compiled vertex shader program pointer.
     * @private
     * @param {string} src - Vertex shader source code.
     * @returns {Object}
     */
    _createVertexShader(src) {
        var shader = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (!this._getShaderCompileStatus(shader, src)) {
            return null;
        }
        return shader;
    }

    /**
     * Returns compiled fragment shader program pointer.
     * @private
     * @param {string} src - Vertex shader source code.
     * @returns {Object}
     */
    _createFragmentShader(src) {
        var shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        if (!this._getShaderCompileStatus(shader, src)) {
            return null;
        }
        return shader;
    }

    /**
     * Disable current program vertexAttribArrays.
     * @public
     */
    disableAttribArrays() {
        var gl = this.gl;
        var a = this._attribArrays;
        var i = a.length;
        while (i--) {
            gl.disableVertexAttribArray(a[i]);
        }
    }

    /**
     * Enable current program vertexAttribArrays.
     * @public
     */
    enableAttribArrays() {
        var gl = this.gl;
        var a = this._attribArrays;
        var i = a.length;
        while (i--) {
            gl.enableVertexAttribArray(a[i]);
        }
    }

    /**
     * Delete program.
     * @public
     */
    delete() {
        this.gl.deleteProgram(this._p);
    }

    /**
     * Creates program.
     * @public
     * @param {Object} gl - WebGl context.
     */
    createProgram(gl) {
        this.gl = gl;
        this._p = this.gl.createProgram();

        var fs = this._createFragmentShader(this.fragmentShader);
        var vs = this._createVertexShader(this.vertexShader);
        gl.attachShader(this._p, fs);
        gl.attachShader(this._p, vs);
        gl.linkProgram(this._p);

        if (!gl.getProgramParameter(this._p, gl.LINK_STATUS)) {
            _cons_js__WEBPACK_IMPORTED_MODULE_1__["cons"].logErr("og/shaderProgram/ShaderProgram:" + this.name + " - couldn't initialise shaders. " + gl.getProgramInfoLog(this._p) + ".");
            gl.deleteProgram(this._p);
            return;
        }

        this.use();

        for (var a in this.attributes) {
            this.attributes[a]._name = a;
            this._variables[a] = this.attributes[a];

            //Maybe, it will be better to remove enableArray option...
            this.attributes[a].enableArray = (this.attributes[a].enableArray != undefined ? this.attributes[a].enableArray : true);
            if (this.attributes[a].enableArray)
                this.attributes[a]._callback = ShaderProgram.bindBuffer;
            else
                this.attributes[a]._callback = _callbacks_js__WEBPACK_IMPORTED_MODULE_0__["callbacks"].a[this.attributes[a].type];

            this._p[a] = gl.getAttribLocation(this._p, a);

            if (this._p[a] == undefined) {
                _cons_js__WEBPACK_IMPORTED_MODULE_1__["cons"].logErr("og/shaderProgram/ShaderProgram:" + this.name + " - attribute '" + a + "' is not exists.");
                gl.deleteProgram(this._p);
                return;
            }

            if (this.attributes[a].enableArray) {
                this._attribArrays.push(this._p[a]);
                gl.enableVertexAttribArray(this._p[a]);
            }

            this.attributes[a]._pName = this._p[a];
        }

        for (var u in this.uniforms) {
            this.uniforms[u]._name = u;
            this.uniforms[u]._callback = _callbacks_js__WEBPACK_IMPORTED_MODULE_0__["callbacks"].u[this.uniforms[u].type];
            this._variables[u] = this.uniforms[u];
            this._p[u] = gl.getUniformLocation(this._p, u);

            if (this._p[u] == undefined) {
                _cons_js__WEBPACK_IMPORTED_MODULE_1__["cons"].logErr("og/shaderProgram/ShaderProgram:" + this.name + " - uniform '" + u + "' is not exists.");
                gl.deleteProgram(this._p);
                return;
            }

            this.uniforms[u]._pName = this._p[u];
        }

        //Maybe it will be better to deleteProgram...
        gl.detachShader(this._p, fs);
        gl.detachShader(this._p, vs);
    }

    /**
     * Bind program buffer.
     * @function
     * @param {og.shaderProgram.ShaderProgram} program - Used program.
     * @param {Object} variable - Variable represents buffer data.
     */
    static bindBuffer(program, variable) {
        var gl = program.gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, variable.value);
        gl.vertexAttribPointer(variable._pName, variable.value.itemSize, gl.FLOAT, false, 0, 0);
    }
};



/***/ }),

/***/ "./src/og/webgl/callbacks.js":
/*!***********************************!*\
  !*** ./src/og/webgl/callbacks.js ***!
  \***********************************/
/*! exports provided: callbacks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return callbacks; });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./src/og/webgl/types.js");
/**
 * @module og/webgl/callbacks
 */





/*=========================
   Uniforms callbacks
 =========================*/
const callbacks = {
    'u': [],
    'a': []
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].MAT4] = function (program, variable) {
    program.gl.uniformMatrix4fv(variable._pName, false, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].MAT3] = function (program, variable) {
    program.gl.uniformMatrix3fv(variable._pName, false, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].FLOAT] = function (program, variable) {
    program.gl.uniform1f(variable._pName, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].INT] = function (program, variable) {
    program.gl.uniform1i(variable._pName, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].VEC2] = function (program, variable) {
    program.gl.uniform2fv(variable._pName, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].VEC3] = function (program, variable) {
    program.gl.uniform3fv(variable._pName, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].VEC4] = function (program, variable) {
    program.gl.uniform4fv(variable._pName, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].SAMPLER2D] = function (program, variable) {
    let pgl = program.gl;
    pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
    pgl.bindTexture(pgl.TEXTURE_2D, variable.value);
    pgl.uniform1i(variable._pName, program._textureID);
    program._textureID++;
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].SAMPLERCUBE] = function (program, variable) {
    let pgl = program.gl;
    pgl.activeTexture(pgl.TEXTURE0 + program._textureID);
    pgl.bindTexture(pgl.TEXTURE_CUBE_MAP, variable.value);
    pgl.uniform1i(variable._pName, program._textureID);
    program._textureID++;
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].SAMPLER2DXX] = function (program, variable) {
    let pgl = program.gl,
        size = variable.value.length;
    let samplerArr = new Int32Array(size);
    for (let i = 0; i < size; i++) {
        pgl.activeTexture(pgl.TEXTURE0 + program._textureID + i);
        pgl.bindTexture(pgl.TEXTURE_2D, variable.value[i]);
        samplerArr[i] = i;
    }
    pgl.uniform1iv(variable._pName, samplerArr);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].INTXX] = function (program, variable) {
    pgl.uniform1iv(variable._pName, variable.value);
};

callbacks.u[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].FLOATXX] = function (program, variable) {
    program.gl.uniform1fv(variable._pName, variable.value);
};

/*========================
   Attributes callbacks
 ========================*/
callbacks.a[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].FLOAT] = function (program, variable) {
    program.gl.vertexAttrib1f(variable._pName, variable.value);
};

callbacks.a[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].VEC2] = function (program, variable) {
    program.gl.vertexAttrib2fv(variable._pName, variable.value);
};

callbacks.a[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].VEC3] = function (program, variable) {
    program.gl.vertexAttrib3fv(variable._pName, variable.value);
};

callbacks.a[_types_js__WEBPACK_IMPORTED_MODULE_0__["types"].VEC4] = function (program, variable) {
    program.gl.vertexAttrib4fv(variable._pName, variable.value);
};

/***/ }),

/***/ "./src/og/webgl/types.js":
/*!*******************************!*\
  !*** ./src/og/webgl/types.js ***!
  \*******************************/
/*! exports provided: types */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "types", function() { return types; });
/**
 * @module og/webgl/types
 */



let _declarations = ["FLOAT", "DOUBLE", "BOOL", "INT", "UINT", "VEC2", "VEC3", "VEC4", "DVEC2",
    "DVEC3", "DVEC4", "BVEC2", "BVEC3", "BVEC4", "IVEC2", "IVEC3", "IVEC4", "UVEC2",
    "UVEC3", "UVEC4", "MAT2", "DMAT2", "MAT3", "DMAT3", "MAT4", "DMAT4", "MAT2X3",
    "MAT2X4", "MAT3X2", "MAT3X4", "MAT4X2", "MAT4X3", "DMAT2X3", "DMAT2X4", "DMAT3X2", "DMAT3X4",
    "DMAT4X2", "DMAT4X3", "SAMPLER1D", "SAMPLER2D", "SAMPLER3D", "SAMPLERCUBE", "SAMPLER2DSHADOW",
    "SAMPLER2DXX", "INTXX", "FLOATXX"];


const types = {};

(function () {
    for (let i = 0; i < _declarations.length; i++)
        types[_declarations[i]] = i;
})();


/***/ })

/******/ });
//# sourceMappingURL=og.js.map